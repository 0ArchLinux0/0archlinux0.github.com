[ { "title": "Nested Interval Property - 폐구간 수렴 정리", "url": "/posts/Nested-Interval-Property/", "categories": "Math, Number Theory", "tags": "Math, Analysis, Nested Interval Property, 폐구간 수렴 정리, 해석학", "date": "2022-04-24 18:28:00 +0900", "snippet": "# Definition of the **Nested Interval** Let $(I_{n})_{n\\in \\mathbb {N}}$ be a sequence of closed intervals of the type $I_{n}=\\left[a_{n},b_{n}\\right]$, where $\\mid I_{n} \\mid \\colon = b_{n} - a_{n}$ denotes the length of such an interval. One can call $(I_{n})_{n\\in \\mathbb {N}}$ a sequence of nested intervals, if1. $\\quad \\forall n\\in \\mathbb {N} :\\;\\;I_{n+1}\\subseteq I_{n}$2. $\\quad \\forall \\varepsilon$ $ &amp;gt;0\\;\\exists N\\in \\mathbb {N} :\\;\\; \\mid I_{N} \\mid &amp;lt;\\varepsilon $(reference)축소구간열의 정의닫힌 구간 $I_{n}=\\left[a_{n},b_{n}\\right]$ 들로 구성된 열을 $(I_{n})_{n\\in \\mathbb {N}}$ 라고 두자.이때 구간의 길이는 다음과 같이 정의된다. $\\mid I_{n} \\mid \\colon = b_{n} - a_{n}$ 이때, $(I_{n})_{n\\in \\mathbb {N}}$가 축소구간열(nested interval)이기 위해서는 다음의 두가지 성질을 만족해야 한다. $\\quad \\forall n\\in \\mathbb {N} :\\;\\;I_{n+1}\\subseteq I_{n}$ $\\quad \\forall \\varepsilon$ $ &amp;gt;0\\;\\exists N\\in \\mathbb {N} :\\;\\; \\mid I_{N} \\mid &amp;lt;\\varepsilon $$i &amp;lt; j$에 대해, $I_{j} \\subseteq I_{i}$, 포함관계가 성립한다.Monotone Convergence Theorem에 따라 $\\forall i \\in \\mathbb{N},$ $\\exists sup(I_{i}), inf(I_{i})$Monotone Convergence Theorem축소하는 구간 열이 되기 위해서 이전의 구간이 현재 구간의 상한 하한을 포함해야 한다는 것은 자명한 사실이다. 어떤 0보다 큰 임의의 자연수 $\\forall \\varepsilon$에 대하여 항상 이 보다 작은 길이의 구간이 존재한다.구간의 길이가 0에 수렴한다는 성질을 엡실론-델타법으로 표현한 것이다.#Axiom of completeness Axiom of completenessIf $(I_{n})_{n\\in \\mathbb {N}}$ is a sequence of nested intervals,there always exists a real number, that is contained in every interval $I_{n}$.In formal notation this axiom guarantees, that$\\exists x\\in \\mathbb {R} :\\;x\\in \\bigcap _{n\\in \\mathbb {N} }I_{n}$(reference)​완비성의 공리이다.  축소구간열 $(I_{n})_{n\\in \\mathbb {N}}$에 대해 구간열의 모든 구간에 포함되는 실수 x는 항상 존재한다. Each sequence $(I_{n})_{n\\in \\mathbb {N} }$ of nested intervals contains exactly one real number  $x$(reference).완비성의 공리 $\\displaystyle \\exists x\\in \\mathbb {R} :\\;x\\in \\bigcap _{n\\in \\mathbb {N} }I_{n}$ 에서 얻어지는 ‘실수 $x$는 존재한다’에서 더 나아가 ‘$x$는 유일하다’라는 사실이다.증명해보자.축소구간열의 모든 구간에 포함되는 서로 다른 두 실수가 존재한다고 가정해보자.$\\exists x, y \\in \\mathbb{R}, x \\neq y$ 축소 구간열의 정의로부터$\\forall \\varepsilon$ $ &amp;gt;0\\;\\exists N\\in \\mathbb {N} :\\;\\; \\mid I_{n} \\mid &amp;lt;\\varepsilon $$이때, $\\forall n \\in \\mathbb{N}, x,y \\in I_{n}$ 이므로$\\mid x - y \\mid &amp;lt; $ $\\liminf \\mid I_{n} \\mid &amp;lt; \\mid I_{n} &amp;lt; \\varepsilon$$\\varepsilon \\to 0$ 일때 $x \\to y$이므로 서로 다른 두 실수라는 조건에 모순된다." }, { "title": "Bolzano–Weierstrass theorem - 볼차노-바이어슈트라스 정리", "url": "/posts/Bolzano-Weierstrass-theorem/", "categories": "Math, Number Theory", "tags": "Math, Analysis, Bolzano–Weierstrass theorem, 볼차노-바이어슈트라스 정리, 해석학", "date": "2022-04-24 18:28:00 +0900", "snippet": "# Definition Bolzano–Weierstrass theorem — result about convergence in a finite-dimensional Euclidean space Rn. The theorem states that each bounded sequence in Rn has a convergent subsequence.(reference)볼차노-바이어슈트라스 정리란 유클리드 공간에서 유계 닫힌집합과 점렬 콤팩트 공간의 개념이 일치한다는 정리이다. (reference)해석학과 위상수학에서 매우 중요하며 많이 쓰이는 정리이다.Definition의 정의부터 보도록하자. 유클리드 공간에서 유계 닫힌집합과 점렬 콤팩트 공간의 개념이 일치한다유클리드 공간에서 유계의 닫힌 집합이란 $R$의 Power Set으로 구성된 공간에 속하는 bounded(limit superior과 limit inferior가 존재) set이며 limit superior와 limit inferior를 구간에 포함하지 않는(closed) 집합을 의미한다.반면, 점렬 콤팩트 공간(sequentially compact space)이란 공간의 임의의 점렬을 잡았을때, 항상 수렴하는 부분 점렬을 가지는 위상 공간을 뜻한다.따라서, 위의 문장은 유클리드 공간에 속하며 유계이고 닫힌 집합에 대해임의의 부분점렬 $U$를 잡는다면 $U$는 항상 수렴하는 부분 점렬을 포함한다.라고 표현될 것이다.증명해보자.본증명에서 볼차노-바이어슈트라스 정리의 증명은 폐구간 수렴 정리를 이용한다.https://ilikechicken.tistory.com/47[Nested Interval Property - 폐구간 수렴 정리# Definition of the Nested Interval Let $(I_{n})_{n\\in \\mathbb {N}}$ be a sequence of closed intervals of the type $I_{n}=\\left[a_{n},b_{n}\\right]$, where $\\mid I_{n} \\mid \\colon = b_{n} - a_{n}$ d..ilikechicken.tistory.com](https://ilikechicken.tistory.com/47)수열 $(a_n)_{n \\in \\mathbb{N}}$를 생각하자. 집합 $\\left\\{a_{n}\\right\\}$ 은 유계이므로$\\exists M \\in \\mathbb{Z}$ $i.e)$ $M = max(\\mid sup_{n} \\mid,  \\mid inf_{n} \\mid)$를 만족한다.$\\forall n \\in \\mathbb{N}, a_{n} \\in \\left[-M, M\\right]$구간을 $\\left[-M, 0\\right]$, $\\left[0, M0\\right]$ 와 같이 반으로 나누었을때 둘 다 유한개의 원소를 가진다면수열 $(a_n)_{n \\in \\mathbb{N}}$가 무한집합이라는 것에 모순됨으로 최소한 하나는 무한집합일 것이다.일반성을 잃지 않고 무한집합인 구간(둘다 무한 집합일 경우에 어느 쪽이던 상관없다)을 골라 이를 $I_{0}$라 하자.$I_{0}$에 대하여 위의 동작을 다시 한번 수행해서 얻어지는 구간을 $I_{1}$, $I_{k-1}$에 대해 위의 동작을 수행한 후 얻어지는 구간을 $I_{k}$으로 정의해보자.이때, 너무나도 자명하게 $\\forall n\\in \\mathbb {N} :\\;\\;I_{n+1}\\subseteq I_{n}$가 성립함을 알 수 있고$\\forall n\\in \\mathbb {N} :\\;\\; \\mid I_{n+1} \\mid = \\frac{\\mid I_{n} \\mid}{2}$그리고 $\\mid I_{0} \\mid \\in \\mathbb{Z}$ 으로부터 $\\forall \\varepsilon$ $ &amp;gt;0\\;\\exists N\\in \\mathbb {N} :\\;\\; \\mid I_{N} \\mid &amp;lt;\\varepsilon $ 도 성립한다.따라서 $(I_{n})_{n\\in \\mathbb {N}}$은 Nested Interval(축소 구간열)이 되고 Nested Interval Property에 따라 Each sequence $(I_{n})_{n\\in \\mathbb {N} }$ of nested intervals contains exactly one real number  $x$(reference)수렴하는 부분 점렬을 가짐이 보여진다." }, { "title": "Monotone Convergence Theorem - 단조 수렴 정리", "url": "/posts/Monotone-Convergence-Theorem/", "categories": "Math, Number Theory", "tags": "Math, Analysis, Monotone Convergence Theorem, 단조 수렴 정리, 해석학", "date": "2022-04-24 18:28:00 +0900", "snippet": "# Definition In the mathematical field of real analysis, the monotone convergence theorem is any of a number of related theorems proving the convergence of monotonic sequences (sequences that are non-decreasing or non-increasing) that are also bounded. Informally, the theorems state that if a sequence is increasing and bounded above by a supremum, then the sequence will converge to the supremum; in the same way, if a sequence is decreasing and is bounded below by an infimum, it will converge to the infimum.(reference)실해석학에서 Monotone Convergence Theorem이란 어떤 단조 수열(monotonic sequences)의 수렴성을 증명하는 과정에서 등장하는 모든 이론을 총칭한다.따라서 일반적인 경우 Monotone Convergence Theorem이라 함은 다음을 칭하는 경우가 많다. Informally, the theorems state that if a sequence is increasing and bounded above by a supremum, then the sequence will converge to the supremum; in the same way, if a sequence is decreasing and is bounded below by an infimum, it will converge to the infimum.(reference) 단조 증가 수열이며 상계가 존재한다면 이 수열은 상한으로 수렴한다. 마찬가지로, 단조 감소 수열이며 하계가 존재한다면 하한으로 수렴한다.라는 정리이다.증명해보자.단조 증가 수열과 단조 감소 수열의 증명은 동일한 논리의 흐름을 따라 가기에 단조 증가 수열에 대해서만 증명하겠다.공집합이 아니며 상계가 존재하는 단조 증가 수열 $(a_n)_{n \\in \\mathbb{N}}$ 의 원소들로 이루어진 집합 $\\left\\{a_{n}\\right\\}$를 생각하자.이때 실수의 완비성 공리(completeness of the real numbers)에 의해(또는 최소 상계 성질, Least-upper-bound property에 의해) 상한 $ub = sup_{n}\\left\\{a_{n}\\right\\}$ 이 존재한다.$Lemma \\ 1)$   $ For \\ \\epsilon &amp;gt; 0 \\in \\mathbb{R}$ $\\exists N \\in \\mathbb{N}$ $s.t$ $a_{N} &amp;gt; sup_{n}\\left\\{a_{n}\\right\\} - \\epsilon$$a_{N} &amp;gt; sup_{n}\\left\\{a_{n}\\right\\} - \\epsilon$ 을 만족하는 N이 존재하지 않는 다고 가정하면 이는 상계이며  $sup_{n}{a_{n}}$ 보다 작기에 모순이다.$Lemma \\ 2)$   $\\limsup (a_n)_{n \\in \\mathbb{N}} = sup_{n}\\left\\{a_{n}\\right\\}$$Lemma \\ 1$에 의해, 임의의 $N$보다 크거나 같은 자연수 $\\forall n \\in \\mathbb{N}, n \\leq N$에 대하여 $sup_{n}\\left\\{a_{n}\\right\\} - a_{n} \\leq$ $sup_{n}\\left\\{a_{n}\\right\\} - a_{N} &amp;lt; \\epsilon$이 성립한다.극한의 정의에 따라 $\\limsup (a_n)_{n \\in \\mathbb{N}} = sup_{n}\\left\\{a_{n}\\right\\}$임이 증명된다.$Lemma \\ 1$, $Lemma \\ 2$ 로부터 다음과 같은 정리가 얻어진다. If $(a_{n})_{n\\in \\mathbb {N} }$ is a monotone sequence of real numbers (i.e., if $a_n \\leq a_n+1$ for every $n \\geq 1$ or $a_n \\geq a_n+1$ for every $n \\geq 1$), then this sequence has a limit if and only if the sequence is bounded.[1](reference)" }, { "title": "Analysis - 해석학(2)", "url": "/posts/Analysis-%ED%95%B4%EC%84%9D%ED%95%99(2)/", "categories": "Math, Analysis", "tags": "Math, Analysis, 수학, 해석학, 군론, 거리공간", "date": "2022-04-16 01:39:00 +0900", "snippet": " Definition 정의 1. 환, 체, 분배법칙Ring, Field, Distributive law집합과 그 집합위의 연산 $+,\\cdot$의 두가지 이항연산자로 구성되는 쌍$(X, +, \\cdot)$이 환이라함은 다음 과 같은 3가지 성질을 만족할 때이다. 덧셈에 대한 가환성(commutative) $(X, +)$에 대해서 가환군(아벨군)이다. 곱셈에 대한 결합법칙(associative law of multiplication) $\\forall x, y, z \\in X \\Rightarrow (x\\cdot y)\\cdot z = x \\cdot (y \\cdot z)$ 분배법칙 $\\forall x, y, z \\in X \\Rightarrow x \\cdot(y + z) = x \\cdot y + x \\cdot z$ $and$ $(x+y)\\cdot z = x \\cdot z + y \\cdot z라추가적으로 곱에 대한 교환법칙($\\forall x, y \\in X \\Rightarrow x \\cdot y = y \\cdot x $)을 만족할때 가환환(commutative ring)이라 불린다.또한, 가환환의 조건에 더해 다음과 같은 3가지 성질이 성립할때 체(field)라고 불린다. 곱셈에대해 닫혀있다　$\\forall x, y \\in X \\Rightarrow x\\cdot y \\in X$ 곱셈에 대한 항등원을 가진다 $\\forall x, y \\in X \\Rightarrow x\\cdot y \\in X$ 곱셈에 대한 역원을 가진다 $\\forall x, y \\in X \\Rightarrow x\\cdot y \\in X$이에 더해 곱에 대한 교환 법칙이 성립할때 가환체라고 하며 일반적으로 체라고 하면 가환체를 말하는 경우가 많다.정의 2. 거리공집합이 아닌 집합 $X$의 원소 $a,b$에 대해 실수함수 $d(x,y)$가 정의되며 다음과 같은 4가지 조건을 만족할때 $d$는 $X$의 거리라고 말할 수 있다. 거리는 음수가 아니다 $d(x, y) \\geq 0$ 대칭성 $x, y \\in X \\Rightarrow d(x,y) = d(y,x)$ 삼각부등식 $x, y, z \\in X \\Rightarrow d(x,z) \\leq d(x,y) + d(y, z)$ 식별불가능자 동일성 원리 $d(x,y) = 0 \\iff x = y $위의 성질들중 4번을 만족하지 않고 $d(x,y) = 0 \\Rightarrow x = y$만을 만족할때유사거리(pseudometric distance) 혹은 반거리(semimetric distance)라고 불린다.정의 3. 거리공간 Metric Space집합 $X$와 거리함수$d$로 이루어진 쌍 $(X, d)$를 거리공간이라고 정의한다.정의 4. 유클리드 거리 Euclidean Distancen차원 유클리드 공간 $(\\mathbb{R}^n, d)$는 대표적인 거리공간중 하나이며$\\mathbb{R}^n$는 길이 n의 벡터 $x=(x_{1], x_{2}, \\ldots , x_{n}}), x_{i} \\in \\mathbb{R}, i = 1, 2,\\ldots , n$ 전체로 구성된 집합이다.이때 두 점 x, y의 거리는 다음과 같이 정의된다.$d(x, y) \\colon = (\\displaystyle\\sum_{i=1}^n \\mid x_{i} - y {i} \\mid^2)^{1 \\over 2}$정의 5. 구 Open ball경계를 포함하지 않은 구로 중심을 $x_{0}$라고 하면 다음과 같이 표현된다.$B_{r}(x_{0}) = \\left\\{ x \\in X \\ \\mid \\ d(x_{0}, x) &amp;lt; r \\right\\}$정의 6. 근방 Neighborhood거리공간 $X$와 점 $p \\in X$, 거리 $r &amp;gt; 0$ 에 대하여 근방은 다음과 같이 정의한다.$N_{r}(p) = \\left\\{q \\ \\mid \\ q \\in X \\land d(p, q) &amp;lt; r\\right\\}$$N_{r}(p) \\setminus \\left\\{p\\right\\}$ 를 $N_{r}^{\\prime}(p)$ 라고도 표기한다.정의 7. 집적점, 한계점(Limit Point)거리공간 $X$와 $X$의 부분 집합 $E$를 잡자.점 $ p \\in X$ 에 대해$\\forall r &amp;gt; 0, N_{r}^{\\prime}(p) \\in E \\neq \\emptyset$가 만족된다면 $p$를 $E$의 집적점이라고 한다.정의 8. 내부점, 외부점(Interior Point, Exterior Point)거리공간 $X$와 $X$의 부분 집합 $E$를 잡자.점 $ p \\in X$ 에 대해 이$\\exists r &amp;gt; 0$ $such$ $that$ $N_{r}^{\\prime}(p) \\in E \\neq \\emptyset$가 만족된다면 $p$를 $E$의 내부점이라고 한다.또한, $E^c = X \\setminus E$ 의 내부점을 $E$의 외부점이라고 한다.일반적인 집합의 여접합과는 달리 $E \\cap E^c = \\emptyset$ 이 성립한다.정의 9. 열린 집합, 닫힌 집합Open set, Closed set거리공간 $(X, d)$에 대해서 $X$의 부분 집합, $E \\subseteq X$를 생각하자.다음이 성립할때$\\forall x \\in E, \\exists r &amp;gt; 0$ $such \\ that$ $B_{r}(x) \\subseteq E$$U$를 $X$의 열린 집합(open set)이라 하며 닫힌 집합(closed set)는 $closed = open^c$ 여집합이 된다.다시 표현하면 E의 모든 점이 E의 interior point일때 E는 열려있다고 하며 E를 열린 집합,E의 모든 limit point가 E의 원소일때 E는 닫혀있다고 하며 E를 닫힌 집합이라 한다.정의 10. 덮개 Cover용어대로 특정 거리공간을 덮는다.거리공간 $X$와 $X$의 부분 집합 $E$를 잡자.집합족 $\\mathcal{F} = \\left\\{\\mathit{O}_{\\alpha} \\ \\mid \\ \\alpha \\in \\mathit{I}\\right\\}$에 대해 $E \\subset \\bigcup_{\\alpha \\in \\mathit{I}} \\mathit{O}_{\\alpha}$ 일때, $\\mathcal{F}$는 $E$의 덮개라 한다. $\\mathcal{F}$의 모든 원소가 open set이라면 $\\mathcal{F}$는 open cover이다. $\\mathcal{F}$의 부분집합족(family of subsets) $\\mathcal{S} \\subset P(\\mathcal{F})$가 $E$의 cover일때, $\\mathcal{S}$을 $\\mathcal{F}$의 subcover(부분 덮개)라고 한다. $\\mid \\mathcal{F} \\mid \\in \\mathbb{N}$일때 $\\mathcal{S}$를 finite subcover(유한 부분 덮개)라고 한다.정의 11. 컴팩트 집합 Compact Setcompact한 집합이라는 어감대로 유한성과 관련이 있다.거리공간 $X$와 $X$의 부분 집합 $E$를 잡자. 이때, 한가지 표현으로$\\forall \\mathcal{C}=Open \\ cover \\ of E$, $\\exists \\mathcal{S}$ $which \\ is \\ finite$ $subcover \\ of \\ \\mathcal{C}$를 만족한다면 $E$는 compact하다고 하며 Compact Set이라고 한다. 다르게 표현하자면$\\forall \\mathcal{C}=Open \\ cover \\ of E$ 에 대해$\\exists A = \\left\\{\\alpha \\ \\mid \\ \\alpha \\in \\mathit{I} \\right\\}, s.t$$E \\subset \\bigcup_{\\alpha \\in A} \\alpha$를 만족할때 $E$는 Compact Set이다.정의 12. 순서집합 Ordered Set순서집합 $A$는 다음과 같은 3가지 성질을 만족하는 집합이다. Symmetric 반사율 $\\forall a \\in A, a \\leq a$ Anti-symmetric 반대칭율 $(a\\leq b) \\land (b \\leq c) \\Rightarrow a \\leq c$ Transitive 추이율 $(a\\leq b) \\land (b \\leq a) \\Rightarrow a = b$정의 13. 상계, 하계, 상한, 하한Upper bound, Lower bound, Supremum, InfimumOrdered Set $(X, \\leq)$의 부분 집합 $A \\subset X$에 대하여$\\exists a, \\forall x \\in A$ $s.t \\ x \\leq a$ 가 만족될때$a$를 상계(Upper bound)라부르며 $X$는 ‘위로 유계’(Bounded from above)라고 한다.$sup\\ A \\ = min(A) \\land u \\in X$ 를 상한(Supremum)이라 한다.하계(Lower bound)와 ‘아래로 유계’(Bounded from below), 하한(Infimum, $inf \\ A$)은 반대로 정의 된다.정의 14. 유리수의 조밀성, 실수의 조밀성임의의 서로 다른 두 실수를 잡았을때, 그 사이에 반드시 실수가 존재한다는 것을 실수의 조밀성이라 한다. 특히, 두 실수 사이에 반드시 무리수가 존재한다는 성질을 무리수의 조밀성이라 한다.$\\forall p, q \\in \\mathbb{R} \\land p &amp;lt; q,$ $\\exists r \\in \\mathbb{R} \\ s.t p &amp;lt; r &amp;lt; q$$\\mathbb{Q} \\subset \\mathbb{R}$ 으로부터 유리수의 조밀성이 성립함도 자명하다.정리 15. 실수의 완비성실수 $A = \\left\\{a_{1}, a_{2}, \\ldots ,a_{n}, \\ldots\\right\\}$를 생각하자.$\\forall \\epsilon &amp;gt; 0, \\exists n_{0}$ $s.t$ $\\forall n, m \\geq n_{0} \\Rightarrow \\mid a_{n} - a{m} \\mid &amp;lt; \\epsilon$ 일때, $A$는 코시 열(Cauchy sequence)이라 한다.이러한 임의 Cauchy sequence가 수렴할때 그 공간은 complete(완비)하다고 한다.$\\mathbb{R}$는 Complete metric space이며 이를 실수의 완비성이라고 한다.정리 16. 상극한, 하극한Limit superior, Limit inferior집합족 $\\mathcal{F} = \\left\\{ A_{n} \\ \\mid \\ n \\in \\mathbb{N} \\right\\}$의 상극한, 하극한은 다음과 같이 정의된다.$ \\underset{n \\to \\infty}{\\overline{\\lim}} A{n}$ $\\displaystyle = \\bigcap{n=1}^{\\infty} \\bigcup{k = n}^{\\infty}A{k}$$ \\underset{n \\to \\infty}{\\underline{\\lim}} A{n}$ $= \\displaystyle\\bigcup{n=1}^{\\infty} \\bigcap{k = n}^{\\infty}A{k}$ 수열 ${a_{n}}$에 대한 상극한 하극한은 다음과 같이 정의된다.$ \\underset{n \\to \\infty}{\\overline{\\lim}} a{n}$ $\\displaystyle = \\inf{n=1}^{\\infty} \\sup{k = n}^{\\infty}A{k}$$ \\underset{n \\to \\infty}{\\underline{\\lim}} a{n}$ $= \\displaystyle\\sup{n=1}^{\\infty} \\inf{k = n}^{\\infty}A{k}$" }, { "title": "Analysis - 해석학(1)", "url": "/posts/Analysis-%ED%95%B4%EC%84%9D%ED%95%99(1)/", "categories": "Math, Analysis", "tags": "Math, Analysis", "date": "2022-04-13 17:28:00 +0900", "snippet": " Definition 정의 1. 집합집합이란 문맥상 추정이 가능한 것들의 집합이며 이는 소속성 질문에 대답할 수 있다는 것을 뜻한다.정의 2. 집합의 외연적정의, 내포적 정의Denotation, Connotation 외연적 정의： 처음의 원소부터 일정 개수의 원소를 열거, 가능하다면 일반항 $a_{n}$의 요소를 표현하고 나머지는 $\\ldots$로 표현하는 경우가 많다. 특별히 영소문자의 경우 $\\sum$ = $\\left\\{a,b,c,…,z\\right\\}$ 로 표기 하는 경우가 있다. 내포적 정의：　집합의 요소가 만족하는 성질을 표현한 것이다.정의 3. 부분집합집합 $X$의 모든 요소가 집합 $Y$의 요소일때 집합$X$는 집합 $Y$의 부분집합이라고 하며 다음과 같이 표현한다. $X \\subseteq Y$정의 4. 합집합집합 $Z$의 모든 요소가 집합 $X$ 또는 $Y$의 요소일때 집합$Z$는 집합 $X$와 합집합 $Y$의 합집합이라고 하며 다음과 같이 표현한다. $X \\cup Y = Z합합—정의 5. 교집합집합 $Z$의 모든 요소가 집합 $X$ 과 $Y$의 요소일때 집합$Z$는 집합 $X$와 교집합 $Y$의 합집합이라고 하며 다음과 같이 표현한다. $X \\cup Y = Z합定義 5. 共通集合集合 X と集合 Y の両方に属する要素からなる集合を「X と Y の共通集合」と呼び、$X \\cup Y$と書く。定義 6. 差集合集合 X には属するが集合 Y には属さない要素からなる集合を「X の Y による差集合」と呼び、$X \\setminus Y$と書く。定義 7. 補集合全体集合 U の要素で集合 X に属さない要素からなる集合を「X の補集合」と呼び、$\\bar{X}, X^c$と書く。定義 8. 空集合$\\emptyset$ は要素を持たない集合を言う。すべての集合の部分集合となる。定義 9. べき集合一つの集合 X のすべての部分集合からなる集合。空集合と全体集合も入る。$Powerset(X), P(X), 2^X, 2^{\\mid X \\mid}$のように書く。定義 10. 直積、順序対$A \\times B = \\left\\{(a, b) \\ \\mid \\ a \\in A, b \\in B\\right\\} $(Direct product, Ordered pair)一般に、n個の集合の直積は $X_{1} \\times X_{2} \\times … \\times X_{n}$ $=\\left\\{x_{1}, x_{2},…,x_{n} \\ \\mid \\ x_{i} \\in X_{i}, 1 \\leq i \\leq n\\right\\}$特に $\\forall i, X_{i}=X$ の場合は $X^n$ と書く。定義 11. 対称差、排他的論理和(Symmetric difference, Exclusive or)$A \\Delta B \\colon = (A \\setminus B) \\cup (B \\setminus A) = (A\\cup B)\\setminus(A\\cap B)$定義 12. 群、単位半群(モノイド)、可換群、位数 (=&amp;gt; Group, Semigroup, Abel Group == Commutattive group, Order)一つの集合とその集合上の 2 項演算の組$(X, \\cdot)$が「群」であるとは、以下の４つの条件が満たされるときできる。閉性 $\\forall x, y \\in X, x \\cdot y \\in X$結合法則 $\\forall x, y, z \\in X, (x \\cdot y) \\cdot = x \\cdot (y \\cdot z)$単位元の存在 $\\exists e, \\forall x \\in X, x \\cdot e = e \\cdot x = x$逆元の存在 $\\forall x, \\exists y \\in X, x \\cdot y = y \\cdot x = e$このうち、逆元の存在だけが成立しない場合、「単位半群(モノイド)」と呼ばれる。この４つの条件に加えてさらに、(交換法則)： $\\forall x, y\\in X, x\\cdot y = y \\cdot x$が成立すると「可換群」と呼ばれる。有限群では集合 X の要素数を「位数」と呼ぶ。定義 13. 対数的数、超越数(Transcendental number)有理数係数の 0 でない多項式の根となる複素数を「代数的数」、それ以外の複素数を「超越数」と呼ぶ。定義 14. 写像(mapping)集合 X,Y について X の一つの要素に Y の要素が一つ対応するとき、この対応を「X から Y への写像」と呼ぶ。$f \\colon X \\Rightarrow Y$$X \\ni x \\mapsto y = f(x) \\in Y$X の「定義域」あるいは「始域」(domain)、Y を「終域」と呼ぶ(codomain)。さらに、$f(x)=\\left\\{y \\ \\mid y = f(x), x \\in X \\right\\} \\subseteq Y$ を「地域」と呼ぶ。(range)定義 15. 全射、単射、全単射(surjective, injective == one-to-one, bijective == one-to-one correspondence)写像　$f \\colon X \\Rightarrow Y$ において、以下の種別がある。（全射）$\\forall y \\in Y, \\exists x \\in$ $such$ $that$ $f(x) = y$（単射）$f(x)=f(x^\\prime) \\Rightarrow x = x^\\prime$（全単射）全射かつ単射定義 16.　逆写像写像 $f \\colon X \\Rightarrow Y$ が全単射であるとき $f^{-1} \\colon Y \\Rightarrow X$ と書く。$Y \\ni y \\mapsto x = f^{-1}(y)$定義 17. 対等二つの集合が「対等」であるとは、A から B への全単射が存在するときを言う。$A~B$と書く。定義 18. 濃度加算（可付番）集合の「濃度」:とは、有限集合では要素数である。それ以外の時は、$\\mathbb{N}$と対等であれば「加算濃度」や「連続濃度」と呼ばれる。加算濃度を持つ集合は「加算集合」あるいは「可付番集合」と呼ばれる。一般に$\\mid A \\mid$や$|A|$のように書かれる。定義 19. 濃度の大小A, B において、A から B への単射が存在するとき、$\\mid A \\mid \\leq \\mid B \\mid$と書き、「A（の濃度）は B（の濃度）と同じかそれより小さい。」と言う。全単射が存在せず、単射のみが存在するときは、$\\mid A \\mid &amp;lt; \\mid B \\mid$や「A（の濃度）は B（の濃度）より小さい。」と言う。" }, { "title": "Analysis - 解析学(1)", "url": "/posts/Analysis-%E8%A7%A3%E6%9E%90%E5%AD%A6-1/", "categories": "数学, 解析学", "tags": "Math, Analysis, 数学, 解析学", "date": "2022-04-13 17:28:00 +0900", "snippet": " Definition 定義 1. 集合集合とは、文脈で推定される「物の集まり」であって、その存在が示され、かつ、所属性質問に答えらるものを言う。定義 2.　外延的定義、内包的定義 外延的定義：　最初から幾つかを示し、可能でなれば第 n 番目の要素などを示す、残りは…で表現することが多い。 内包的定義：　集合の要素が満足すべき性質を記すこと。英小文字の集合は　$\\sum$ = $\\left\\{a,b,c,…,z\\right\\}$ と書かれる。定義 3. 部分集合集合 X のすべての要素がまた集合 Y の要素であるとき、「X は Y の部分集合である」といい、$X\\subseteq Y$と書く。定義 4. 合併集合集合 X または集合 Y のどちらかの要素、あるいは、両方の要素からなる集合を「X と Y の合併集合」と呼び、$X \\cup Y$と書く。定義 5. 共通集合集合 X と集合 Y の両方に属する要素からなる集合を「X と Y の共通集合」と呼び、$X \\cup Y$と書く。定義 6. 差集合集合 X には属するが集合 Y には属さない要素からなる集合を「X の Y による差集合」と呼び、$X \\setminus Y$と書く。定義 7. 補集合全体集合 U の要素で集合 X に属さない要素からなる集合を「X の補集合」と呼び、$\\bar{X}, X^c$と書く。定義 8. 空集合$\\emptyset$ は要素を持たない集合を言う。すべての集合の部分集合となる。定義 9. べき集合一つの集合 X のすべての部分集合からなる集合。空集合と全体集合も入る。$Powerset(X), P(X), 2^X, 2^{\\mid X \\mid}$のように書く。定義 10. 直積、順序対(Direct product, Ordered pair)$A \\times B = \\left\\{(a, b) \\ \\mid \\ a \\in A, b \\in B\\right\\} $一般に、n 個の集合の直積は $X_{1} \\times X_{2} \\times … \\times X_{n}$ $=\\left\\{x_{1}, x_{2},…,x_{n} \\ \\mid \\ x_{i} \\in X_{i}, 1 \\leq i \\leq n\\right\\}$特に $\\forall i, X_{i}=X$ の場合は $X^n$ と書く。定義 11. 対称差、排他的論理和(Symmetric difference, Exclusive or)$A \\Delta B \\colon = (A \\setminus B) \\cup (B \\setminus A) = (A\\cup B)\\setminus(A\\cap B)$定義 12. 群、単位半群(モノイド)、可換群、位数Group, Semigroup, Abel Group == Commutattive group, Order一つの集合とその集合上の 2 項演算の組$(X, \\cdot)$が「群」であるとは、以下の４つの条件が満たされるときできる。閉性 $\\forall x, y \\in X, x \\cdot y \\in X$結合法則 $\\forall x, y, z \\in X, (x \\cdot y) \\cdot = x \\cdot (y \\cdot z)$単位元の存在 $\\exists e, \\forall x \\in X, x \\cdot e = e \\cdot x = x$逆元の存在 $\\forall x, \\exists y \\in X, x \\cdot y = y \\cdot x = e$このうち、逆元の存在だけが成立しない場合、「単位半群(モノイド)」と呼ばれる。この４つの条件に加えてさらに、(交換法則)： $\\forall x, y\\in X, x\\cdot y = y \\cdot x$が成立すると「可換群」と呼ばれる。有限群では集合 X の要素数を「位数」と呼ぶ。定義 13. 対数的数、超越数 Transcendental number有理数係数の 0 でない多項式の根となる複素数を「代数的数」、それ以外の複素数を「超越数」と呼ぶ。定義 14. 写像 Mapping集合 X,Y について X の一つの要素に Y の要素が一つ対応するとき、この対応を「X から Y への写像」と呼ぶ。$f \\colon X \\Rightarrow Y$$X \\ni x \\mapsto y = f(x) \\in Y$X の「定義域」あるいは「始域」(domain)、Y を「終域」と呼ぶ(codomain)。さらに、$f(x)=\\left\\{y \\ \\mid y = f(x), x \\in X \\right\\} \\subseteq Y$ を「地域」と呼ぶ。(range)定義 15. 全射、単射、全単射Surjective, Injective == One-to-one, Bijective == One-to-one Correspondence写像　$f \\colon X \\Rightarrow Y$ において、以下の種別がある。（全射）$\\forall y \\in Y, \\exists x \\in$ $such$ $that$ $f(x) = y$（単射）$f(x)=f(x^\\prime) \\Rightarrow x = x^\\prime$（全単射）全射かつ単射定義 16.　逆写像写像 $f \\colon X \\Rightarrow Y$ が全単射であるとき $f^{-1} \\colon Y \\Rightarrow X$ と書く。$Y \\ni y \\mapsto x = f^{-1}(y)$定義 17. 対等二つの集合が「対等」であるとは、A から B への全単射が存在するときを言う。$A~B$と書く。定義 18. 濃度加算（可付番）集合の「濃度」:とは、有限集合では要素数である。それ以外の時は、$\\mathbb{N}$と対等であれば「加算濃度」や「連続濃度」と呼ばれる。加算濃度を持つ集合は「加算集合」あるいは「可付番集合」と呼ばれる。一般に$\\mid A \\mid$や$|A|$のように書かれる。定義 19. 濃度の大小A, B において、A から B への単射が存在するとき、$\\mid A \\mid \\leq \\mid B \\mid$と書き、「A（の濃度）は B（の濃度）と同じかそれより小さい。」と言う。全単射が存在せず、単射のみが存在するときは、$\\mid A \\mid &amp;lt; \\mid B \\mid$や「A（の濃度）は B（の濃度）より小さい。」と言う。" }, { "title": "백준 3653번 - 영화 수집", "url": "/posts/boj3653/", "categories": "PS, baekjoon", "tags": "PS, Algorithm, Baekjoon, BOJ, 백준, 자료구조, 세그먼트 트리, Segment Tree", "date": "2022-04-12 18:28:00 +0900", "snippet": "https://www.acmicpc.net/problem/3653​ 3653번: 영화 수집​각 테스트 케이스에 대해서 한 줄에 m개의 정수를 출력해야 한다. i번째 출력하는 수는 i번째로 영화를 볼 때 그 영화의 위에 있었던 DVD의 개수이다. 상근이는 매번 영화를 볼 때마다 본 영화 DVD​www.acmicpc.net​# Approach)​선형배열의 업데이트와 쿼리문이니 세그먼트 트리를 떠올리자.해당 포스트에서는 비재귀 세그먼트 트리를 이용하였다.​# Point)​DVD의 번호를 기준으로 세그먼트 트리를 만들면 로직이 꼬이기때문에 DVD 컬렉션상의 특정 위치의 DVD의 존재 유무를 기준으로 잡는 것이 좋다. ​DVD 하나를 빼서 맨 위로 올리는 것을 ‘액션’이라고 하자. 트리의 원본배열의 크기(구간합이 아닌 리프노드의 값들의 배열을 원본 배열이라고 하자)를 n으로 잡는다면 이 액션을 처리하기가 매우 까다롭기에 n+m+1으로 잡는다.​이 배열을 $arr$이라 하고 순서대로 $arr[m+1]$이 최상단 ~ $arr[m+n]$을 최하단으로 두면 초기상태의 $arr$은$arr[m+1] = 1$(최상단에 dvd가 존재), … , $arr[m+n] = 1$로 모든 $m+1~m+n$에 대해서 1의 값을 가지게 될것이다. ​액션이 발생하면 DVD들 간의 순서에 변화가 생기기때문에 DVD의 배열 arr상의 인덱스를 midx라는 배열로 저장해둘것이다. 한번에 액션에 대해 arr과 midx를 업데이트해준후 이에 따라 트리도 갱신해주면 문제가 해결된다.​예를 들어 보자.$n = 3, m = 1$)컬렉션은 (최상단 1 2 3 최하단) 이와 같은 형태를 하고 있을 것이다.초기상태 =&amp;gt; $arr[m+1] ~ arr[m+3] = 1$, $midx[1] = m+1$, $midx[2] = m + 2$, $midx[3] = m + 3$ ​2번영화의 DVD를 빼는 1번의 액션을 취해보자.​arr[midx[2]] = 0, arr[insertIdx] = 1, midx[2] = insertidx--;​$arr$상의 2번영화가 존재하는 인덱스(즉, $arr[midx[2]]$)의 값을 0으로, 적절한 위치의 인덱스 $insertIdx$를 잡아서 $arr[insertIdx]$의 값을 1로 갱신해줌으로써 $arr$의 갱신이 완료된다.이때 $arr$상에선 인덱스가 작을수록 위에 있는 것이므로 $insertIdx$를 계속 감소시키면서 갱신해주면항상 최상단에 뺀 DVD를 다시 놓는것이 된다.초기값으로는 초기상태의 1번DVD보다 위인 $insertIdx = m$으로 둔다.​$midx[2] = insertIdx$로 갱신해줌으로써 $midx$의 갱신도 완료되어 한번의 액션에 대한 처리가 완료된다. ​하단의 코드는 비재귀 세그먼트 트리를 이용하였다.​#Code(c++)​#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;tuple&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;climits&amp;gt;#include &amp;lt;float.h&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define FOR(i, s, e) for(int i = s; i &amp;lt; e; i++)#define pf first#define ps second#define pii pair&amp;lt;int,int&amp;gt; #define ll long long#define lll __int128#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int INF = 987654321;const int mod = (int)1e9+7;const ll INFLL = 1e13;const int N = (int)1e5 + 1;int n, t, sn, m;int seg[4*N];int midx[N];int insertIdx;​void init() { memset(seg, 0, sizeof(seg)); memset(midx, 0, sizeof(midx)); sn = n + m + 1; for1(i, n+1) { midx[i] = i + sn + m; // sn(=0) sn + 1 ~ sn + m// sn + m + 1 ~ sn + m + n seg[i+sn+m] = 1; } for(int i = sn - 1; i; i--) seg[i] = seg[i&amp;lt;&amp;lt;1] + seg[i&amp;lt;&amp;lt;1|1]; insertIdx = sn + m;}​void action(int idx) { //get int sum = 0; for(int l = sn, r = midx[idx]; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1) { if(l &amp;amp; 1) sum += seg[l++]; if(r &amp;amp; 1) sum += seg[--r]; } cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; dkdk; //update seg[midx[idx]] = 0; for(int i = midx[idx]; i &amp;gt; 1; i&amp;gt;&amp;gt;=1) seg[i&amp;gt;&amp;gt;1] = seg[i] + seg[i^1]; midx[idx] = insertIdx--; seg[midx[idx]] = 1; for(int i = midx[idx]; i &amp;gt; 1; i&amp;gt;&amp;gt;=1) seg[i&amp;gt;&amp;gt;1] = seg[i] + seg[i^1];}​int main() { FASTIO; cin &amp;gt;&amp;gt; t; while(t--) { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; init(); for0(i, m) { int in; cin &amp;gt;&amp;gt; in; action(in); } cout &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "백준 19565번 - 수열 만들기", "url": "/posts/boj19565/", "categories": "PS, baekjoon", "tags": "PS, Algorithm, Baekjoon, BOJ, Constructive Algorithm, Hierholzer's Algorithm, 백준, 오일러 회로", "date": "2022-04-12 18:28:00 +0900", "snippet": "https://www.acmicpc.net/problem/19565# Approach)$For$ $1 \\leq i &amp;lt; j \\leq \\mid A\\mid $,  $A_{i} \\neq A_{j}$ $\\lor A_{i+1} \\neq A_{j+1}$ $\\iff$ $ \\lnot \\left(A_{i} = A_{j} \\land A_{i+1} = A_{j+1}\\right)$ $\\iff$ $\\lnot \\left(\\left\\{ A_{i}, A_{i+1} \\right\\} = \\left\\{ A_{j}, A_{j+1} \\right\\}\\right)$이로부터 인접한 두 쌍, $A_{i}, A_{i+1}$ 이 모두 다르면 된다.$1~N$번까지의 정점으로 이루어진 방향 그래프를 생각하자.모든 쌍 $A_{i}, A_{i+1}$ 에 대해서 정점 $A_{i}$에서 정점$A_{i+1}$로 가는 간선을 대응시켰을때 같은 간선을 두 번 이상 지나지 않으면 된다. 시작점과 끝점을 1로 가지는 회로중 길이가 가장 긴 회로를 찾는 문제로 대응된다.# Definition)$E_{i,j}: $ $Edge \\ from \\ i \\ to \\ j$$edges: \\left\\{ E_{A_{i}, A_{i+1}} \\  \\mid \\ 1 \\leq i \\leq N-1 \\right\\}$$adj: \\left\\{ edge\\_index \\ \\mid \\ edges[edge\\_index] = E_{A_{i}, A_{i+1}}  \\right\\}$임의의 한 정점 $u$ 와 $u$가 아닌 다른 한 정점 $v$에 대해 생각해보자.길이가 최대로 되며 문제의 조건을 만족하려면 우리가 원하는 회로, $G_{c}$는 다음과 같은 조건을 만족해야 할 것이다.$E_{u, v}, E_{v, u} \\in G_{c}$따라서 모든 정점에 대해서 양방향으로 모든 간선이 존재하며 $E_{u, u}$도 가능함을 고려한다면$u$에서 나가는 간선의 수와 들어오는 간선의 수는 항상 같게 된다.이를 바탕으로 정점 $u$의 차수를 생각해보자.$deg(u) = deg_{in}(u) + deg_{out}(u) = 2deg_{in}(u)$모든 정점의 차수는 짝수가 되고 오일러 회로가 존재함을 뜻한다.Hierholzer’s Algorithm을 이용하여 오일러 회로를 계산해주면 된다.    # Time Complexity)인접행렬을 이용하는 경우:$O(\\mid V\\mid E\\mid )$ 이며 $V_{upper\\_limit} = 10^3$, $E_{upper\\_limit} = 2 \\times 10^6$ 의 경우를 가정하면  $O(\\mid V\\mid E\\mid ) \\leq 2 \\times 10^9$, 시간제한은 1초로  TLE의 가능성이 충분하다. 인접리스트를 이용하는 경우:$O(\\mid E\\mid ) \\leq$ $E_{upper\\_limit} = 2 \\times 10^6$ 시간제한을 넉넉히 통과한다.실제로 해당문제는 인접행렬을 이용하며 풀면 TLE를 받게 되니 시간복잡도가 낮은 인접 리스트를 이용하여 구현해야한다는 점에 유의하자.여담으로 답이 되는 수열의 길이는 cnt로 코드에서 구해도 되지만 모든 가능한 간선이 $n \\times n$개라는 것을 생각하면 수열의 길이는 그 보다 1 큰 $n^2 +1$가 됨을 알 수 있다.#Code(c++)#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define FOR(i, s, e) for(int i = s; i &amp;lt; e; i++)#define pf first#define ps second#define pii pair&amp;lt;int,int&amp;gt; #define ll long long#define lll __int128#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int INF = 987654321;const ll INFLL = 1e13;const int mod = 32768;const int N = 802;const int st = 50;int n, m, t, k, start = -1, ans = 0;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; adj;struct Edge{ int u, v; int cnt; Edge(int _u, int _v, int _c): u(_u), v(_v), cnt(_c) {};};vector&amp;lt;Edge&amp;gt; edges;void dfs(int cur) { while(adj[cur].size()) { int eidx = adj[cur].back(); if(edges[eidx].cnt) { edges[eidx].cnt--; dfs(edges[eidx].u + edges[eidx].v - cur); } else adj[cur].pop_back(); } cout &amp;lt;&amp;lt; cur &amp;lt;&amp;lt; dkdk;}void solve() { adj.resize(n+1); for1(i, n+1) { for1(j, n+1) { if(i == j) { edges.push_back(Edge(i, i, 1)); int eidx = edges.size() - 1; adj[i].push_back(eidx); } if(i &amp;lt; j) { edges.push_back(Edge(i, j, 1)); edges.push_back(Edge(j, i, 1)); int eidx = edges.size() - 2; adj[i].push_back(eidx); adj[j].push_back(eidx); eidx++; adj[i].push_back(eidx); adj[j].push_back(eidx); } } } cout &amp;lt;&amp;lt; (n*n + 1) &amp;lt;&amp;lt; endl; dfs(1);}int main() { FASTIO; cin &amp;gt;&amp;gt; n; solve();}" }, { "title": "백준 1395번 - 스위치", "url": "/posts/boj1395/", "categories": "PS, baekjoon", "tags": "PS, Algorithm, Baekjoon, BOJ, 백준, 자료구조, 느리게 갱신되는, 세그먼트 트리, Segment Tree, Lazy propagation", "date": "2022-04-12 18:28:00 +0900", "snippet": "https://www.acmicpc.net/problem/1395# Approach)선형배열의 업데이트와 쿼리문이니 세그먼트 트리를 떠올리자.해당 포스트에서는 비재귀 세그먼트 트리를 이용하였다.# Time Complexity)업데이트를 진행할때 s~t구간의 스위치를 모두 토글해야한다.각 원소를 하나하나 토글한다면 세그먼트 트리를 사용했을때 시간복잡도는최대 한번의 업데이트에 $O(log(n))$으로 전체의 쿼리에 대해 최악의 상황으로 가정한다면 $O(mnlog(n)) &amp;gt; 10^8$ 로 TLE를 받게 될 것이다.따라서 lazy propagation을 이용하여 각 업데이트를 $O(log(n))$안에 해결해주어야 한다.#Code(c++)#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define FOR(i, s, e) for(int i = s; i &amp;lt; e; i++)#define pf first#define ps second#define pii pair&amp;lt;int,int&amp;gt;#define ll long long#define lll __int128#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int N = 1 &amp;lt;&amp;lt; 17;int n,m;int seg[1&amp;lt;&amp;lt;18];bool lazy[1&amp;lt;&amp;lt;17];void apply(int idx, int len){ seg[idx]=len-seg[idx]; lazy[idx]=0; if(len!=2) lazy[idx&amp;lt;&amp;lt;1]^=1,lazy[idx&amp;lt;&amp;lt;1|1]^=1; else seg[idx&amp;lt;&amp;lt;1]^=1,seg[idx&amp;lt;&amp;lt;1|1]^=1;}void propagate(int idx,int len){ int logv=0,e=idx; while(e&amp;gt;1)e&amp;gt;&amp;gt;=1,logv++; for(int i=logv;i&amp;gt;=0;i--) if(idx&amp;gt;&amp;gt;i&amp;lt;N&amp;amp;&amp;amp;lazy[idx&amp;gt;&amp;gt;i]) apply(idx&amp;gt;&amp;gt;i,len&amp;lt;&amp;lt;i);}void query(int l,int r){ int sum=0,len=1; for(l+=N,r+=N;l&amp;lt;r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1,len&amp;lt;&amp;lt;=1) { if(l&amp;amp;1){propagate(l,len);sum+=seg[l++];} if(r&amp;amp;1){propagate(--r, len);sum += seg[r];} } cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;}void mark(int idx,int len){ propagate(idx,len); int d=len-(seg[idx]&amp;lt;&amp;lt;1); if(idx&amp;lt;N) lazy[idx]^=1; else seg[idx]+=d; while(idx&amp;gt;1) idx&amp;gt;&amp;gt;=1,seg[idx]+=d;}void update(int l,int r){ int len=1; for(l+=N,r+=N;l&amp;lt;r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1,len&amp;lt;&amp;lt;=1) { if(l&amp;amp;1) mark(l++,len); if(r&amp;amp;1) mark(--r,len); }}int main() { FASTIO; cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for0(i,m) { int o,s,t; cin&amp;gt;&amp;gt;o&amp;gt;&amp;gt;s&amp;gt;&amp;gt;t; if(o == 1) query(s,t+1); else update(s,t+1); } return 0;}" }, { "title": "백준 1035번 - 조각 움직이기", "url": "/posts/boj1035/", "categories": "PS, baekjoon", "tags": "PS, Algorithm, Baekjoon, BOJ, 완전탐색, Brute-Force, 백준", "date": "2022-04-12 18:28:00 +0900", "snippet": "https://www.acmicpc.net/problem/1035# Approach)전형적인 완전탐색 문제이다. 보드의 처음 별모양의 위치를 벡터에 넣는다. 그 순서대로 각 별모양이 어디로 이동할지 정하고 다음 별모양이 선택하도록 DFS탐색을 진행해준다.# Time Complexity)시간복잡도는 $_{25}\\mathrm{P}_{5}$ $ = 5!{25 \\choose 5} $ $= 6,375,600 &amp;lt; 10^9 $ 으로 2초안에 충분히 탐색이 가능하다.일반적으로 보드의 크기가 $n^2$, 조각이 $m$개라고 하면 $_{n^2}\\mathrm{P}_{m} $으로 매우 빠르게 증가할 것이다.따라서 숫자가 작을땐 완전탐색 문제를 의심해보면 좋다.#Code(c++)#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;tuple&amp;gt;#include &amp;lt;climits&amp;gt;#include &amp;lt;fstream&amp;gt;#include &amp;lt;sstream&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define FOR(i, s, e) for(int i = s; i &amp;lt; e; i++)#define pf first#define ps second#define pii pair&amp;lt;int,int&amp;gt;#define ll long long#define lll __int128#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int INF = 987654321;const ll INFLL = 1e13;const int mod = (int)1e9+7;const int N = 802;const int st = 50;// const int N = 1000000;int n, m, t, k, cnt, ans = INF;bool mm[5][5];bool dmm[5][5];bool visit[5][5];int di[] = { -1, 0, 1, 0 };int dj[] = { 0, 1, 0, -1 };vector&amp;lt;pii&amp;gt; pv;bool rck(int ci, int cj) { return ci &amp;gt;= 0 &amp;amp;&amp;amp; cj &amp;gt;= 0 &amp;amp;&amp;amp; ci &amp;lt; 5 &amp;amp;&amp;amp; cj &amp;lt; 5; }bool is_linked() { memset(visit, 0, sizeof(visit)); int fnct = 0, ci, cj; for0(i, 5) for0(j, 5) if(dmm[i][j]) { ci = i; cj = j; break; } queue&amp;lt;pii&amp;gt; q; q.push({ ci, cj }); while(!q.empty()) { auto p = q.front(); q.pop(); if(visit[p.pf][p.ps]) continue; visit[p.pf][p.ps] = true; fnct++; for0(k, 4) { int ai = p.pf + di[k], aj = p.ps + dj[k]; if(!rck(ai, aj) || !dmm[ai][aj]) continue; q.push({ai, aj}); } } return fnct == cnt;}void dfs(int i, int move) { if(ans &amp;lt;= move) return; if(i == cnt) { if(is_linked()) ans = min(ans, move); return; } for0(ci, 5) { for0(cj, 5) { if(dmm[ci][cj]) continue; dmm[ci][cj] = 1; dfs(i+1, move + abs(pv[i].pf - ci)+abs(pv[i].ps-cj)); dmm[ci][cj] = 0; } }}int main() { FASTIO; for0(i, 5) { string s; cin &amp;gt;&amp;gt; s; for0(j, 5) if(s[j] == &#39;*&#39;) { mm[i][j] = 1; cnt++; pv.push_back({ i, j }); } } dfs(0, 0); cout &amp;lt;&amp;lt; ans;}" }, { "title": "백준 1006번 - 습격자 초라기(증명)", "url": "/posts/boj1006/", "categories": "PS, baekjoon", "tags": "PS, Algorithm, Baekjoon, BOJ, DP, 증명, 백준", "date": "2022-04-12 18:28:00 +0900", "snippet": "https://www.acmicpc.net/problem/1006# Approach)타일링문제와 상당히 흡사하다. 고로 DP를 떠올려보자.First Try(Failed)# Definition)$dp[i][j] :$ $min \\ value \\ when$ $inner \\ circle \\ is$ $filled \\ to \\ index \\ i$, $and \\ outer \\ j$$in[i] :$ $cost \\ of \\ index \\  i $ $of \\ inner \\ circle$$out[i] :$ $cost \\ of \\ index \\  i$ $of \\ outer \\ circle$소대가 한칸을 커버하는 경우와 두칸을 커버하는 경우가 있을 것이다. 한칸을 커버한다면$ inner:$ $ dp[i+1][i] = min(dp[i+1][j], dp[i][j] + 1) $$ outer:$ $ dp[i][j+1] = min(dp[i][j+1], dp[i][j] + 1) $ 두칸을 커버한다면 $ inner: $ $ if \\ in[i+1]+in[i+2] \\leq w $   $ then $  $dp[i+2][j] = min(dp[i+2][j], dp[i][j] + 1) $$ outer: $ $ if \\ out[i+1]+out[i+2] \\leq w $   $ then $  $ dp[i][j+2] = min(dp[i][j+2], dp[i][j] + 1) $$ inner+outer: $  $ if \\ in[i+1]+out[i+1] \\leq w $   $ then $  $dp[i+1][j+1] =$ $min(dp[i+1][j+1], dp[i][j] + 1)$이를 바탕으로 대략적인 점화식을 써보면$ dp[i][j] =$ $ min( dp[i-1][j]+inner[i],$ $dp[i][j-1] + outer[j],$ $ dp[i-2][j] + inner[i-1],$ $ dp[i][j-2] + outer[j-1] ) $정도로 표현될 것이다. (깔끔함을 위해 부수적인 조건들은 생략하였다)int cdp(int ci, int cj) { if(ci == si &amp;amp;&amp;amp; cj == sj) return 0; if(dp[ci][cj] != INF) return dp[ci][cj]; int&amp;amp; ref = dp[ci][cj]; if(ci &amp;gt; si+1 &amp;amp;&amp;amp; inner[ci]+inner[ci-1] &amp;lt;= w) ref = min(ref, cdp(ci-2, cj)+1); else if(ci &amp;gt; si) ref = min(ref, cdp(ci-1, cj)+1); if(cj &amp;gt; sj+1 &amp;amp;&amp;amp; outer[cj]+outer[cj-1] &amp;lt;= w) ref = min(ref, cdp(ci, cj-2)+1); else if(cj &amp;gt; sj) ref = min(ref, cdp(ci, cj-1)+1); if(ci == cj &amp;amp;&amp;amp; ci &amp;gt; si &amp;amp;&amp;amp; cj &amp;gt; sj &amp;amp;&amp;amp; inner[ci] + outer[cj] &amp;lt;= w) ref = min(ref, cdp(ci-1,cj-1) + 1); return dp[ci][cj];}대략 이런 느낌으로 재귀 함수를 이용하여 메모제이션 배열을 채웠고 TLE를 받았다.$dp[i][j] :$ $min \\ value \\ when$ $inner \\ circle \\ is$ $filled \\ to \\ index \\ i,$ $and \\ outer \\ j$의 정의로부터 배열의 크기는 $10001\\times10001$ 이다.배열의 모든 $i, j$에 대해서 dp[i][j]를 계산해주고 있으니$O(n^2)&amp;gt;O(10^8)$ 로 당연히 시간 초과가 날 수 밖에 없었다.해결하기 위해서는 $O(n^2)$ 보다 낮은 상한의 과정으로 처리를 해주어야 할 것이다.Improvement접근을 바꿔서 효율적으로 개선해보자.기술하기 편하도록 소대가 커버하는 구역을 타일로 덮는다고 생각하여 타일링문제로 치환하겠다.모든 타일이 덮힌 최적의 해에서 반대로 타일을 하나 씩 빼가보자.타일을 덮어간 과정을 역으로, 즉 타일을 역순으로 하나씩 제거할때마다 ‘이전 상태‘로 돌린다고 표현하겠다. 초기상태: dp[n][n]으로 inner와 outer의 모든 칸이 타일로 덮혀있고 최소의 타일을 사용하여 덮은 최적해를 생각하자. 이때, 이전 상태로 돌리면 inner 혹은 outer에서 길이 1 또는 2의 타일을 하나 제거 할 것이다.1-A) 길이가 1인 타일을 제거한 경우: 타일로 덮혀진 inner와 outer의 길이차는 1이다.1-B) 길이가 2인 타일을 제거한 경우: 일반성을 잃지 않고 길이가 2인 타일을 outer에서 제거했다고 가정하자. inner에서도 마지막 타일을 제거해보자. 여기서도 두가지의 경우가 있을 있다. 1-B-a) 길이가 1인 타일인경우: 이전상태의 타일로 덮혀진 inner, outer의 길이차는 1이다. 1-B-b) 길이가 2인 타일인경우: 이전상태의 타일로 덮혀진 inner, outer의 길이차는 0이다.이쯤에서 최적해의 타일을 덮어간 과정의 모든 중간과정은, 타일로 덮혀진 inner, outer의 길이차가 0 또는 1인 상태로만 구성할 수 있다는 것을 눈채챌 수 있을 것이다. 귀납적 연결:이전상태의 타일로 덮혀진 inner, outer의 길이차가 0 또는 1인 상태의 이전 상태도모두 타일의 길이의 차가 0 또는 1인 상태로 표현 할 수 있다.2-A) 타일로 덮혀진 inner, outer의 길이차가 0인 경우: 1-A, 1-B에서 기술한 단계를 거치면 표현이 가능하다는 것을 알 수 있다.2-B) 타일로 덮혀진 inner, outer의 길이차가 1인 경우: 길이가 긴쪽에서 타일을 하나 제거하자. 2-B-a) 제거한 타일의 길이가 1인경우: 이전상태의 타일로 덮혀진 inner, outer의 길이차는 0이다. 2-B-b) 제거한 타일의 길이가 2인경우: 타일로 덮혀진 inner, outer의 길이차는 1이다.따라서 1과 2에 의해서 귀납적으로 최적해의 모든 과정은 타일로 덮혀진 inner, outer의 길이차가 0 또는 1인 상태로 표현 할 수 있다는 것을 알 수 있다.시간복잡도도 LTE를 받던$\\{$ $\\left(i, j\\right) | i,j \\in \\mathbb{N} \\land$ $1 \\leq \\forall i,j \\leq n$ $\\}$ $ \\implies O(n^2)$에서$\\{$ $\\left(i, j\\right) | i,j \\in \\mathbb{N} \\land$ $1 \\leq \\forall i,j \\leq n \\land (|i-j|=1\\lor i=j)$ $\\}$ $ \\implies O(n)$으로 개선되게 되고 TLE를 면할 수 있을 것이다.이제 원형으로 이어진 부분의 처리만 생각해주면 된다.이는 $outer[1], outer[n]$이 겹칠 수 있고, $inner[1], inner[n]$이 겹칠 수 있으니 총 4가지의 상태이고 이는 단순 분기로 충분히 처리 가능하다.디버깅에 시간이 꽤 걸렸는데 DP는 정의를 최대한 깔끔하게 하고 인덱스 실수에 주의해야 이와 같은 마음 아픈 경험을 하지 않을 수 있을 것이다.Definition)$dp[idx][state]$  $ ( 1 \\leq idx \\leq n, 0 \\leq state &amp;lt; 3) $길이의 차가 0또는 1이니 state는 3가지의 상태를 가질 것이다state 0: 길이가 같은 경우state 1: outer의 길이가 inner의 길이보다 긴 경우state 2: inner의 길이가 outer의 길이보다 긴 경우cdp함수를 호출하기전에 dp를 채우기시작하는 인덱스 si에 앞서 dp[si][]의 값들을 채워준다.cdp함수의 if문에서 $ci-1 &amp;gt;= si$ 가 아닌 $ci-1 \\geq si -1$임을 유의하자.($outer[1], outer[n]$ 혹은 $inner[1], inner[n]$이 겹친경우 dp[2]까지를 초기화하고cdp에서 탐색은 3부터 하는것으로 넘겨주었다.따라서 $ci-1\\geq 3$으로 작성하는 실수를 하기 쉽지만$inner[2]$ 혹은 $outer[2]$에서 relax되는 경우도 고려해주어야하니$ci-1 \\geq 2$여야 할 것이다).#Code(c++)#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define FOR(i, s, e) for(int i = s; i &amp;lt; e; i++)#define pf first#define ps second#define pii pair&amp;lt;int,int&amp;gt;#define ll long long#define lll __int128#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;#define print(a, i) cout &amp;lt;&amp;lt; &quot;debug: &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; dkdk &amp;lt;&amp;lt; &quot; ckp: &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;const int INF = 987654321;const ll INFLL = 1e13;const int mod = (int)1e9+7;const int N = 802;const int st = 50;int n, m, t, w;int dp[10001][3];int inner[10001];int outer[10001];int cdp(int si, int ei) { for(int ci = si; ci &amp;lt;= ei; ci++) { dp[ci][1] = dp[ci][2] = dp[ci-1][0] + 1; if(ci &amp;gt;= si &amp;amp;&amp;amp; outer[ci] + outer[ci-1] &amp;lt;= w) dp[ci][1] = min(dp[ci][1], dp[ci-1][2] + 1); if(ci &amp;gt;= si &amp;amp;&amp;amp; inner[ci] + inner[ci-1] &amp;lt;= w) dp[ci][2] = min(dp[ci][2], dp[ci-1][1] + 1); dp[ci][0] = 1 + min(dp[ci][1], dp[ci][2]); if(inner[ci] + outer[ci] &amp;lt;= w) dp[ci][0] = min(dp[ci][0], dp[ci-1][0] + 1); if(ci-1 &amp;gt;= si-1 &amp;amp;&amp;amp; outer[ci] + outer[ci-1] &amp;lt;= w &amp;amp;&amp;amp; inner[ci] + inner[ci-1] &amp;lt;= w) dp[ci][0] = min(dp[ci][0], dp[ci-2][0] + 2); } return dp[ei][0];}void solve() { for0(i, n+1) for0(j, 3) dp[i][j] = INF; dp[0][0] = dp[0][1] = dp[0][2] = 0; int ans = cdp(1, n); bool bi = inner[1] + inner[n] &amp;lt;= w, bj = outer[1] + outer[n] &amp;lt;= w; if(bi) { for0(i, n+1) for0(j, 3) dp[i][j] = INF; dp[2][2] = 2; dp[2][1] = 2 - (outer[1] + outer[2] &amp;lt;= w); dp[2][0] = min({ dp[2][1]+1, dp[2][2]+1, 3 - (inner[2] + outer[2] &amp;lt;= w) }); cdp(3, n); ans = min(ans, dp[n][1] + 1); } if(bj) { for0(i, n+1) for0(j, 3) dp[i][j] = INF; dp[2][1] = 2; dp[2][2] = 2 - (inner[1] + inner[2] &amp;lt;= w); dp[2][0] = min({ dp[2][1]+1, dp[2][2]+1, 3 - (inner[2] + outer[2] &amp;lt;= w) }); cdp(3, n); ans = min(ans, dp[n][2] + 1); } if(bi &amp;amp;&amp;amp; bj) { for0(i, n+1) for0(j, 3) dp[i][j] = INF; dp[1][0] = dp[1][1] = dp[1][2] = 0; cdp(2, n-1); ans = min(ans, dp[n-1][0]+2); } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;}int main() { FASTIO; cin &amp;gt;&amp;gt; t; while(t--) { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; w; for1(i, n+1) cin &amp;gt;&amp;gt; inner[i]; for1(i, n+1) cin &amp;gt;&amp;gt; outer[i]; solve(); }}" }, { "title": "Max-flow min-cut theorem - 최대 유량 최소 컷 정리", "url": "/posts/Max-flow-min-cut-theorem/", "categories": "Graph theory, Flow network", "tags": "Algorithm, Graph Threory, Max-flow min-cut, mfmc, flow network, 네트워크 플로우, 그래프", "date": "2022-04-12 18:28:00 +0900", "snippet": "# Definition the max-flow min-cut theorem states that in a flow network, the maximum amount of flow passing from the source to the sink is equal to the total weight of the edges in a minimum cut, i.e., the smallest total weight of the edges which if removed would disconnect the source from the sink.reference$flow(s,t)\\_{max} = cut(s,t)\\_{min}$그래프 $G$에서 최대유량 $flow(s,t)_{max}$는 항상 source와 sink의 최소컷 $cut(s,t)_{min}$과 같다​# Term Definition## Cut ## A cut is a partition of the vertices of a graph into two disjoint subsetsreference$(S, T \\in G_{V})$ $\\land$ $(S \\cup T = G_{V})$ $\\land$ $(S \\cap T = \\emptyset)$그래프 $G=(V, E)$에 대한 정점의 집합 $G_{V}$ 를 다음을 만족하는 두개의 부분집합 $S, T$으로 나누었을때,$S, T$는 $G_{V}$의 partition이며$(S \\cap T = \\emptyset)$이므로 자명하게 disjoint subsets을 만족하게 된다.Cut의 정의로부터 Cut-set의 개념이 파생된다.## Cut-set ## A cut $\\displaystyle C=(S,T)$ is a partition of ${\\displaystyle V}$ of a graph ${\\displaystyle G=(V,E)}$ into two subsets S and T.The cut-set of a cut ${\\displaystyle C=(S,T)}$ is the set $\\displaystyle \\{(u,v)\\in E\\mid u\\in S,v\\in T\\}$of edges that have one endpoint in S and the other endpoint in T. If s and t are specified vertices of the graph G, then an s–t cut is a cut in which s belongs to the set S and t belongs to the set T.reference그래프 $G=(V, E)$와 Cut $C = (S, T)$를 가정하자.이때 Cut $C = (S, T)$에 대한 Cut-set은 $\\left\\{(u, v) \\in E \\ \\mid \\ u \\in S, v \\in T \\right\\}$ 로 정의된다.다시 말해 $G$에서 모든 Cut-set의 $E$를 제거하면 partition S와 T는 서로 이어진, 혹은 흐를 수 있는 간선이 존재 하지 않게 된다.그래프 이론에서 어느 한 간선을 선택하여 삭제하였을때 component의 개수가 증가한다면 이 간선을 bridge, isthmus, cut-edge, cut arc등으로 부른다.partition에 대해 서로 흐를 수 있는 간선이 존재 하지 않는 다는 것은 bridge가 존재하지 않는다는 의미이기때문에이와 같은 상태를 bridgeless 라고 한다.## Minimum cut ##뻔한 정의지만 가능한 모든 Cut중 가중치를 최소로 하는 Cut을 의미한다.$Minimum \\ cut $ $= min( cost(C) \\ \\mid \\ \\forall C = (S, T) \\in G )$## Maximum cut ##$Maximum \\ cut $ $= max( cost(C) \\ \\mid \\ \\forall C = (S, T) \\in G )$# Proof증명과정에서 포드-풀커슨 알고리즘(Ford–Fulkerson algorithm)을 사용하기 때문에 미리 이에 대한 사전 지식이 선행되어야 한다. #$Variable \\ Definition$ $Network \\ G$ $=(V,E): source:\\ s,$ $sink: \\ t$ $Cut \\ C$ $S, T: $ $partition \\ of \\ G_{V} $ $divided \\ by$ $C(s \\in S, t \\in T, S$ $and \\ T \\ has$ $no \\ more \\ than$ $1 \\ components)$ $C(S, T) $ $= \\displaystyle\\sum_{(u, v) \\in S \\times T} c_{uv}$ $Flow \\ f_{uv}: $ $flow \\ from \\ u $ $to \\ v$ $\\mid f\\mid: \\ f_{st}$ $Lemma \\ 1)$ $\\ \\mid f\\mid \\leq C_{min}(S, T)$ $proof)$ 귀류법으로 $\\mid f\\mid &amp;gt; C_{min}(S, T)$라고 가정해보자.Conservation of Flows에 의해서 $\\mid f\\mid$ = $f_{s_{out}} = f_{t_{in}}$마찬가지로 $ f(S_{out}) = f_{s_{out}} $, $f(T_{in}) = f_{t_{in}} $ 으로부터$\\mid f\\mid = f_{s_{out}} $ $= f_{t_{in}} = f(S_{out}) $ $= f(T_{in}) = f_{ST}$ 가 얻어진다.$\\mid f\\mid = f_{ST} $ $= \\displaystyle\\sum_{(u, v) \\in S \\times T} f_{uv} $ $ \\leq $ $ \\displaystyle\\sum_{(u, v) \\in S \\times T} c_{uv} \\leq C_{min}(S, T)$ 이는가정 $\\mid f\\mid &amp;gt; C_{min}(S, T)$과 모순 됨으로$\\ \\mid f\\mid \\leq C_{min}(S, T)$임이 증명된다. $Lemma \\ 2)$ $\\exists C:\\  min(\\mid f\\mid) $ $= C_{min}(S, T)$ $proof)$ G에 대해 Ford–Fulkerson algorithm에서 마지막으로 갱신된(Augmented) 그래프를 $G_{f}$라 하자.또한, $G_{f}$의 $s$에서 유량이 흐를 수 있는 $G_{f}$안의 정점의 집합을 $A$라고 하자.partition $\\left\\{S, T\\right\\} $ $= \\left\\{A, A^c\\right\\}$ 일때, $min(\\mid f\\mid) = C_{min}(S, T)$ 만족함을 보이자.1.  $\\left\\{A, A^c\\right\\}$은 $C$의 올바른 partition이다.2.  $\\mid f\\mid = C_{min}(S, T)$이다.두가지를 보이면 될 것이다.1번은 Ford–Fulkerson algorithm에 따라 $\\forall u \\in A \\subset G_{f},$ $ v \\in G_{V}: $ $c_{f}(u, v)( = c(u, v) - f_uv) $ $= 0$이여야 하므로올바른 partition임을 알 수 있다.$C_{min}(S, T) $ $= \\sum_{(u, v) \\in A \\times A^c} c_{uv} = f_{s_{out}} $ $= \\mid f\\mid( \\because Conservation\\  of \\  Flows) =$ $ min(\\mid f\\mid)$1, 2로부터 $Lemma \\ 2) $도 증명된다.$Lemma \\ 1)$, $Lemma \\ 2)$로부터 $C_{min}(S, T) = min(\\mid f\\mid)$이며 $G_{f}$를 구함으로써min-cut을 구성함을 있음이 증명된다." }, { "title": "Floyd-Warshall Algorithm - 플로이드 워셜 알고리즘", "url": "/posts/Floyd-Warshall-Algorithm/", "categories": "Graph theory, Flow network", "tags": "Algorithm, Graph Threory, 그래프, Floyd-Warshall, 플로이드 워셜, flow network, 네트워크 플로우, shortest path, 최단 비용", "date": "2022-04-12 18:28:00 +0900", "snippet": "# Expression$ \\forall u,v \\in G: \\ \\ cost(u,v)$그래프 G에 대해서 모든 정점간의 최소 비용을 계산할때 쓰이며 음의 가중치 간선이 있어도 동작한다.이러한 최소 비용 문제를 일반적으로 Shortest Path Problem 으로 분류한다.# Algorithmpseudo codelet cost[V+1][V+1] // cost[i][j]: cost of the shortest path from i to j//initfor(i: 0~V) for(j: 0~V) if(i == j) cost[i][j] = 0 else cost[i][j] = w[i][j] ? w[i][j] : INF//relaxationfor(mid: 0~V) for(start: 0~V) for(end: 0~V) if(cost[start][mid] + cost[mid][end] &amp;lt; cost[start][end]) cost[start][end] = cost[start][mid] + cost[mid][end]# Proof of correctnessDefinition)$path\\_vertices(path)$$path\\_vertices(path) $ $= \\left\\{ v \\ \\mid v \\in G ,\\ v \\ was \\ included \\ in \\ the \\ path \\right\\}$경로 path상에서 방문한 모든 정점들의 집합$shortest\\_path(i, j, k) $ :$ path\\_vertices(shortest\\_path(i, j, k))$ $ \\subset \\left\\{ x \\mid 1 \\leq x \\leq k \\right\\} $i에서 j로 가는 경로중, 경로상의 모든 점이 {1, 2, … k }에 포함되며 최소 비용인 경로(또는 그 값)$w_{i,j}$ : i에서 j로 가는 간선의 가중치(비용)Proof)$shortest_path(i, j, k)$에 대하여 생각해보면 두가지 경우가 존재 할 수 있다.1. $k \\in $ $path\\_vertices(shortest\\_path(i, j, k)) $ (k를 포함하는 경우)$shortest\\_path(i, j, k) $ $= shortest\\_path(i, k - 1, k) + $ $shortest\\_path(k, j, k - 1)$2. $k \\not\\in $ $path\\_vertices(shortest\\_path(i, j, k))$ (k를 포함하지 않는 경우)$shortest\\_path(i, j, k) $ $= shortest\\_path(i, j, k-1)$$ \\therefore shortest\\_path(i, j, k) $ $= min(shortest\\_path(i, k - 1, k) $ $+ shortest\\_path(k, j, k - 1),$ $ shortest\\_path(i, j, k-1)$로 나타낼 수 있다.후술할 내용들#floyds-cycle-detection-algorithm#Path reconstruction" }, { "title": "Flow network - 네트워크 플로우", "url": "/posts/Flow-network/", "categories": "Graph theory, Flow network", "tags": "Algorithm, Graph Threory, Max-flow min-cut, Ford–Fulkerson algorithm, flow network, 네트워크 플로우, 그래프", "date": "2022-04-12 18:28:00 +0900", "snippet": "# Definition A flow network (also known as a transportation network) is a directed graph where each edge has a capacity and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edgereference플로우 네트워크 G는 모든 간선이 용량과 유량의 속성을 가지는 그래프이며 유량은 항상 용량을 초과할 수 없다.# Term Definition## Flows ##flow를 정의하는 방법(notation)은 다양하다. 이 중 가장 직관적이며 대표적인 의사-유량(pseudo-flow라서 대충 의사-유량으로 번역하겠다)의 notation은 다음과 같다. pseudo-fow는 함수 $f: \\ V \\times V \\Rightarrow \\mathbb{R}$ 이며$\\forall u, v \\in V$에 다음과 같은 성질을 만족한다. Capacity constraints Skew symmetry Flow conservation Value(f) 1.1번의 성질은 $\\forall(u, v) \\in E:$ $f(u, v) \\leq c(u,v)$ 으로 기본 공리같은 느낌이며 직관적으로도 자명하다.2.Skew symmetric 하다는 것은 Skew-symmetric matrix과 같은 형식으로 표현 할 수 있다는 것이다.Skew-symmetric matrix란 $A^T = -A$를 만족하는 Square matrix(정방행렬)을 의미한다.(이에 따라 $f_{uu} = 0$도 성립하게 된다)이와 비슷하게 flow에 대해서도 다음과 같은 성질이 성립한다. $f_{uv} = -f_{vu}$ 정점 u에서 v로 유량이 흐르것과 v에서 u로 같은 양의 다른 부호의 유량이 흐르는 것을동치로 취급할 수 있게 되면 flow analysis의 직관성, 논리의 흐름이 굉장히 깔끔해진다(예를 들어 유량을 더 흘려보내주는 과정에서 $f_{uv}$와 $f_{wx}$가 각각 $\\Delta f_{uv}$만큼 감소, $\\Delta f_{uv}$만큼 증가하는 경우를 생각해보자. $f_{uv}-\\Delta f_{uv}$, $f_{wx}+\\Delta f_{wx}$로 표현한다면 표현의 통일성이 없고 $\\Delta f(s, t)$의 값의 표현이 깔끔하지 않은 반면성질 2를 이용하여 표현한다면 $f_{uv}+\\Delta f_{vu}$, $f_{wx}+\\Delta f_{wx}$로통일성 있게 표현되기에 $\\Delta f(s, t)$의 표현도 깔끔해진다.)혹여 $u$에서 $v$로 $E_{uv} = 6$, $v$에서 $u$로 $E_{vu} = 2$인 경우 $f_{uv} = -f_{vu}$가 성립 안하는게 아니냐는 질문에 대한 대답은 다음과 같다.flow analysis에서 논리의 흐름을 위하여 $f_{uv}$는 단순히 u에서 v로 직접적으로(다른 정점을 거치지 않고) 흐르는 유량 뿐만 아닌 가능한 모든 경로에 대한 유량의 합을 뜻한다.다시 말하자면 모든 $u \\Rightarrow v$로 갈 수 있는 경로들의 집합$P(u,v) = \\left\\{p \\ \\mid \\ p: \\ path \\ from \\ u \\ to \\ v\\right\\}$에 대해서 유량$f_{uv}$ $=\\displaystyle\\sum_{path \\ p \\in P} f(p)$으로 표현 할 수 있다.따라서 $u$에서 $v$로 $E_{uv} = 6$, $v$에서 $u$로 $E_{vu} = 2$인 경우$f_{uv} = 6 -2 = 4 = -(2 - 6) = -f_{vu}$이 성립하게 되는 것이다.3.Flow conservation은 정점 $v$로 들어오는 유량의 합의 절댓값과 나가는 유량의 합은 동일 하다는 성질이다. $f_{v_{in}}=f_{v_{out}}$ $f_{v_{in}} = \\displaystyle\\sum_{u: (u, v) \\in E} f_{uv}$ $= \\displaystyle\\sum_{u: (u, v) \\in E} -f_{vu}$ $= \\displaystyle\\sum_{w: (w, v) \\in E} -f_{vw}$ $=f_{v_{out}}$를 얻을 수 있다.4.네트워크에서 유량의 값(value of flow)에 관한 성질이며 다음과 같다. $\\mid f\\mid = f_{s_{out}} = f_{t_{in}}$ s에서 직접적으로(다른 정점을 거치지 않고) 연결되어있는 점들의 집합을 $DS=\\left\\{u\\ \\mid \\ u: \\ directly \\ connected \\ from \\ s\\right\\}$라고 하자.Flow conservation에 의해$\\displaystyle\\sum_{u \\in V, u \\neq (s, t)}f_{u_{in}} - f_{u_{out}} = 0$$\\Rightarrow$ $0 = \\displaystyle\\sum_{u \\in V, u \\neq (s, t)}(\\displaystyle\\sum_{v: v \\Rightarrow u} f_{vu}- \\displaystyle\\sum_{w: u \\Rightarrow v} f_{uw})= 0$$=\\displaystyle\\sum_{(u, v) \\in V, u, v \\neq (s, t)}f_{uv} - f_{uv}$ $+\\displaystyle\\sum_{u: s\\Rightarrow u}f_{su}$ $-\\displaystyle\\sum_{u: u\\Rightarrow t}f_{ut}$=0+$ $\\displaystyle\\sum_{u: s\\Rightarrow u}f_{su}$ $-\\displaystyle\\sum_{u: u\\Rightarrow t}f_{ut}$$= f_{s_{out}} - f_{t_{in}}$$\\therefore f_{s_{out}} = f_{t_{in}}\\  Q.E.D$**## Residual capacity **##**** The residual capacity of an arc with respect to a pseudo-flow $f$, denoted $c_{f}$, is the difference between the arc’s capacity and its flow. That is, $c_{f} (e) = c(e) - f(e)$reference잔류 용량이란 $c_{f}$으로 표기하며 얼마만큼의 유량이 더 흐를 수 있는지를 뜻한다.용량이 유량의 최댓값이므로 잔류 용량은 $c_{f} (e) = c(e) - f(e)$ 으로 표현된다.## Residual network ##** A residual network, denoted $G_{f} (V, E_{f})$, which models the amount of available capacity on the set of arcs in $G = (V, E)$reference잔류 네트워크란 잔류 용량에 초점을 맞추어 구성한 그래프이다.$G=(V,E)$라면 간선 $E_{uv} =$ $c_{f}(u, v)$로 표현 된다.## Augmenting paths ##** An augmenting path is a path $(u_{1}, u_{2}, …, u_{k})$ in the residual network, where $u_{1} = s, u_{k} = t$, and $c_{f} (u_{i}, u_{i} + 1) &amp;gt; 0. A network is at maximum flow if and only if there is no augmenting path in the residual network $G_{f}$.referenceAugmenting path는 번역하면 증가 경로정도가 되겠다.잔류 네트워크 $G_{f}$에 대해서 $s$에서 출발하여 $t$로 흐를 수 있는 경로가 Augmenting path이다.경로는 다음과 같이 표현 할 수 있다.$(u_{1}, u_{2}, …, u_{k})$ $\\subset G$,$u_{1} = s, u_{k} = t$, $c_{f} (u_{i}, u_{i} + 1) &amp;gt; 0$증가 경로가 존재한다면 유량 $\\mid f(G_{f})\\mid $은 최댓값이 아니며증가 경로가 존재하지 않을때 $\\mid f(G_{f})\\mid $이 최댓값, 즉 maximum flow가 된다.역 또한 성립한다.이의 증명은 Ford–Fulkerson algorithm의 포스팅에서 기술하겠다." }, { "title": "Euclidean Algorithm - 유클리드 호제법", "url": "/posts/Euclidean-Algorithm/", "categories": "Math, Number Theory", "tags": "Math, Number Theory, Euclidean Algorithm, 유클리드 호제법, 증명, 정수론", "date": "2022-04-12 18:28:00 +0900", "snippet": "# Definition$ a = bq + r(0 \\le r &amp;lt; b) $ $\\Rightarrow $ $GCD(a, b) = GCD(b, r)$최대공약수에 관한 문제에서 자주 쓰이는 기본 정리 중 하나이다.증명부터 해보자. $ Lemma 1)$ $WLOG \\ a &amp;gt;= b,$ $GCD(a, b) = GCD(a-b, b) $ $proof)$$g=GCD(a,b),$ $ \\ a = gA,$ $ \\ b =gB$ 라 두자.$ GCD(a-b, b) $ $= GCD(g(A-B), gB) $ 이기에 A-B와 B가 서로소임을 보이면 Lemma 1은 증명된다.귀류법으로$ GCD(A-B, B) = g_{A,B},$ $A-B = g_{A,B}M,\\ B $ $= g_{A,B}N,\\ g_{A,B} \\neq 1$를 만족하는$\\exists g_{A,B} \\in \\mathbb{Z} $가 존재한다고 가정하자.$ B = g_{A,B}N,$ $A = (A-B) + B = g_{A,B}M + g_{A,B}N $ $= g_{A,B}(M+N) $$ a = gA $ $= gg_{A,B}(M+N),$ $ b = gB =$ $ gg_{A,B}N $ 으로 부터$ g = GCD(a, b) $ $= \\geq gg_{A,B} $$ g_{A,B} \\le 1 $이는 가정과 모순됨으로 Lemma 1이 증명된다.이제 Lemma 1으로부터 본 정리가 증명됨은 자명하다.$WLOG\\ a=bq+r(0 \\le r &amp;lt; B) $ 이라 두자.$ GCD(a, b) = GCD(a - b, b) $ $= GCD(a - 2b, b) = \\cdots $ $= GCD(a - bq, b) = GCD(r, b) $ $= GCD(b, r) $을 얻을 수 있음을 확인 할 수 있다.# Pseudo Code유클리드 호제법을 이용한 최대공약수를 구하는 코드는 다음과 같이 간결하게 쓸 수 있다.int gcd(int a, b) { if(b == 0) return a; return gcd(b, a%b);}" }, { "title": "Bézout&#39;s identity - 베주 항등식(Part. 1)", "url": "/posts/B%C3%A9zout's-identity-p1/", "categories": "Math, Number Theory", "tags": "Math, Number Theory, Bézout's identity, 베주 항등식, 증명, 정수론", "date": "2022-04-12 18:28:00 +0900", "snippet": "# DefinitionBézout’s identity — Let a and b be integers or polynomials with greatest common divisor a. Then there exist integers or polynomials x and y such that ax + by = d. Moreover, the integers or polynomials of the form az + bt are exactly the multiples of d.(reference)Extended Euclidean과 연결되는 정수론의 기본 정리 중 하나이다.증명부터 해보자. $Lemma \\ 1)$   $ For \\ \\forall a, b \\in \\mathbb{N} \\left(a \\neq 0 \\lor b \\neq 0 \\right)$ $\\ Let \\ S \\ = \\ \\left\\{ ax+by&amp;gt;0 \\ \\mid \\ x, y \\in \\mathbb{Z} \\right\\}$  $Then \\ S \\neq \\emptyset $ $proof)$$ a \\neq 0 \\lor b \\neq 0 $ 에서 일반성을 잃지않고 $ a \\neq 0 $이라 두었을 때 $ x = \\pm1, y = 0 $이라면$\\mid ax+by\\mid=a\\neq0$, $\\mid ax+by\\mid \\in S$으로 $S$가 공집합이 아님을 알 수 있다.$Proposition \\ 1)$ $For \\ \\forall \\ a,b, l \\in \\mathbb{N} \\left(a \\neq 0 \\lor b \\neq 0 \\right)$ $\\ let \\ g=GCD(a,b)$, $then$ $there$ $exists$ $\\exists x,y \\in \\mathbb{Z}$ $such$ $that$ $\\ ax+by=g$$ Let \\ S \\ = \\ \\left\\{ ax+by&amp;gt;0 \\ \\mid \\ x,y \\in \\mathbb{Z} \\right\\} $$ S \\subset \\mathbb {N} $ , $ S \\neq \\emptyset $(Lemma 1에 의해서) 가 성립하기에 Well-ordering principle에 의해 최솟값 $m \\ = \\ min\\left\\{ S \\right\\}\\left(m \\in \\mathbb{N}\\right)$ 를 잡을 수 있다( *반드시 존재한다 ).$ m = ax_{1} + bY_{1} \\left( x_{1}, y_{1} \\in \\mathbb {Z} \\right)$로 두고 다른 임의의 값 k를 잡자.$let \\  \\forall k \\in S, k = ax_{2} + by_{2} \\left( x_{2}, y_{2} \\in \\mathbb{Z} \\right) $$ k &amp;gt; m $ 일 것이고 $k = mq + r (0 \\leq r &amp;lt; m) $ 으로 표현할 수 있다.$ \\therefore \\ k$ $= mq + r$ $= \\left(ax_{1} + bY_{1}\\right)q + r$$ r $ $= k - mq $ $= \\left(ax_{2} + by_{2}\\right) - \\left(ax_{1} + by_{1}\\right) q $ $=a\\left(x_{2} - qx_{1}\\right) + b\\left(y_{2} - qy_{1}\\right) $$ m \\not\\mid k$ 라고 가정해보면$ r \\in \\mathbb{N} $임을 알 수 있고 $ r &amp;lt; m $이 성립하게 되어 m이 최솟값이라는 가정에 모순된다. 따라서 $ m \\mid k $ 가 항상 성립하게 된다.두 가지 경우로 나눠서 생각을 해보자. $ a = 0 \\lor b = 0 $일반성을 잃지 않고 $a = 0$이라고 하면 $ GCD(a,b) = GCD(b, 0) = 0 $이 얻어지고 $ x=0 \\  and \\ y =0 $라는 쌍으로 표현 할 수 있음이 자명하다.(* 본 증명에서는 증명의 간결함을 위하여 $ For \\ \\forall n \\in \\mathbb{N} \\ GCD(n, 0) = 0 $으로 정의한다.) $ a \\neq 0 \\land b \\neq 0 $$ a \\in S \\land b \\in S$ 에서 $ m\\mid a \\land m\\mid b,\\ \\therefore m\\mid g$ 임을 알 수 있다.$g = mG\\left(G \\in \\mathbb{Z} \\right)$라 두자.$g $ $= mG $ $= \\left(ax_{1} + by_{1}\\right)G $ $= a(Gx_{1}) + b(Gy_{1})$$x = Gx_{1}$, $y =  Gy_{1}$으로 표현 가능하다는 것이 얻어진다.$Proposition \\ 2)$ $For \\ \\forall \\ a,b,l \\in $ $\\mathbb{N} \\left(a \\neq 0 \\lor b \\neq 0 \\right)$ $ let $ $ g$ $=GCD(a,b)$, $then$ $there$ $exists$ $\\exists x,y \\in \\mathbb{Z} $ $such$ $that$ $\\ ax+by=gl$Proposition 1로부터 $g = ax_{1} + by_{1}$ 라 두면$gl=\\left(ax_{1}+by_{1}\\right)l $ $= a\\left(lx_{1}\\right) + b\\left(ly_{1}\\right) $ 으로 표현이 가능함을 알 수 있다.$Proposition \\ 3)$ $For \\ \\forall \\ a,b,x,y l \\in $ $\\mathbb{N} \\left(a \\neq 0 \\lor b \\neq 0 \\right)$ $let \\ g=GCD(a,b)$, $then \\ g\\mid ax+by $$g\\mid x \\land g\\mid y$ 이므로 자명하게 $g\\mid ax+by$가 성립한다.Proposition 1, 2, 3으로부터$Theorom \\ 1)$ $For \\ \\forall \\ a,b,x,y l \\in $ $\\mathbb{N} \\left(a \\neq 0 \\lor b \\neq 0 \\right)$ $let \\ g=GCD(a,b)$, $S$ $= \\ \\left\\{ax+by&amp;gt;0 \\ \\mid \\ x,y \\in \\mathbb{Z} \\right\\}$ $T\\ = \\ \\left\\{Mg \\ \\mid \\ M \\in \\mathbb{Z} \\right\\}$, $then \\ S = T $이로써 정수에 대한 Bézout’s identity의 증명이 완료된다.일반적인 확장은 Part.2에서, 다항식으로의 확장은 Part.3에서 마저 기술하겠다." }, { "title": "BOJ. Cubing (5373)", "url": "/posts/BOJ-5373/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Cubing, 큐빙", "date": "2022-03-13 18:28:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/5373Axis SettingCube[6] 0,3 +-X, 1,4 +=Y, 2,5 +=ZCube[][i][j] i, j: X,Y,Z coordinate#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int INF = 987654321;int n, t;char cube[6][3][3];char color[6] = { &#39;g&#39;, &#39;r&#39;, &#39;w&#39;, &#39;b&#39;, &#39;o&#39;, &#39;y&#39; };void rotate_face(int face_idx, bool clock) { char store[2] = { cube[face_idx][0][0], cube[face_idx][1][0] }, tmp[2]; if(clock) { for0(i, 2) tmp[i] = cube[face_idx][0][2-i]; for0(i, 2) cube[face_idx][0][2-i] = store[i], store[i] = tmp[i]; for0(i, 2) tmp[i] = cube[face_idx][2-i][2]; for0(i, 2) cube[face_idx][2-i][2] = store[i], store[i] = tmp[i]; for0(i, 2) tmp[i] = cube[face_idx][2][i]; for0(i, 2) cube[face_idx][2][i] = store[i], store[i] = tmp[i]; } else { for0(i, 2) tmp[i] = cube[face_idx][2][i]; for0(i, 2) cube[face_idx][2][i] = store[i], store[i] = tmp[i]; for0(i, 2) tmp[i] = cube[face_idx][2-i][2]; for0(i, 2) cube[face_idx][2-i][2] = store[i], store[i] = tmp[i]; for0(i, 2) tmp[i] = cube[face_idx][0][2-i]; for0(i, 2) cube[face_idx][0][2-i] = store[i], store[i] = tmp[i]; } for0(i, 2) cube[face_idx][i][0] = store[i];}void rotate_cube(char face, bool clock) { if(face == &#39;U&#39; || face == &#39;D&#39;) { clock = clock ^ (face == &#39;D&#39;); rotate_face(face == &#39;U&#39; ? 2 : 5, clock); int h = face == &#39;U&#39; ? 2 : 0; char store[3]; char tmp[3]; for0(i, 3) store[i] = cube[4][h][i]; if(clock) { for0(i, 3) tmp[i] = cube[3][2-i][h]; for0(i, 3) cube[3][2-i][h] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[1][h][2-i]; for0(i, 3) cube[1][h][2-i] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[0][i][h]; for0(i, 3) cube[0][i][h] = store[i], store[i] = tmp[i]; } else { for0(i, 3) tmp[i] = cube[0][i][h]; for0(i, 3) { cube[0][i][h] = store[i]; store[i] = tmp[i]; } for0(i, 3) tmp[i] = cube[1][h][2-i]; for0(i, 3) cube[1][h][2-i] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[3][2-i][h]; for0(i, 3) cube[3][2-i][h] = store[i], store[i] = tmp[i]; } for0(i, 3) cube[4][h][i] = store[i]; } if(face == &#39;F&#39; || face == &#39;B&#39;) { clock = clock ^ (face == &#39;B&#39;); rotate_face(face == &#39;F&#39; ? 1 : 4, clock); int h = face == &#39;F&#39; ? 2 : 0; char store[3], tmp[3]; for0(i, 3) store[i] = cube[2][2-i][h]; if(clock) { for0(i, 3) tmp[i] = cube[3][h][2-i]; for0(i, 3) cube[3][h][2-i] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[5][i][h]; for0(i, 3) cube[5][i][h] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[0][h][i]; for0(i, 3) cube[0][h][i] = store[i], store[i] = tmp[i]; } else { for0(i, 3) tmp[i] = cube[0][h][i]; for0(i, 3) cube[0][h][i] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[5][i][h]; for0(i, 3) cube[5][i][h] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[3][h][2-i]; for0(i, 3) cube[3][h][2-i] = store[i], store[i] = tmp[i]; } for0(i, 3) cube[2][2-i][h] = store[i]; } if(face == &#39;L&#39; || face == &#39;R&#39;) { clock = clock ^ (face == &#39;R&#39;); rotate_face(face == &#39;L&#39; ? 0 : 3, clock); int h = face == &#39;L&#39; ? 2 : 0; char store[3], tmp[3]; for0(i, 3) store[i] = cube[2][h][i]; if(clock) { for0(i, 3) tmp[i] = cube[1][2-i][h]; for0(i, 3) cube[1][2-i][h] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[5][h][2-i]; for0(i, 3) cube[5][h][2-i] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[4][i][h]; for0(i, 3) cube[4][i][h] = store[i], store[i] = tmp[i]; } else { for0(i, 3) tmp[i] = cube[4][i][h]; for0(i, 3) cube[4][i][h] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[5][h][2-i]; for0(i, 3) cube[5][h][2-i] = store[i], store[i] = tmp[i]; for0(i, 3) tmp[i] = cube[1][2-i][h]; for0(i, 3) cube[1][2-i][h] = store[i], store[i] = tmp[i]; } for0(i, 3) cube[2][h][i] = store[i]; }}int main(int argc, char *argv[]) { FASTIO; cin &amp;gt;&amp;gt; t; while(t--) { cin &amp;gt;&amp;gt; n; for0(i, 6) for0(j, 3) for0(k, 3) cube[i][j][k] = color[i]; for0(i, n) { string cmd; cin &amp;gt;&amp;gt; cmd; rotate_cube(cmd[0], cmd[1] == &#39;+&#39;); } for0(j, 3) { for0(i, 3) cout &amp;lt;&amp;lt; cube[2][2-i][j]; cout &amp;lt;&amp;lt; endl; } } return 0;}" }, { "title": "BOJ. K th Number (1520)", "url": "/posts/BOJ-7469/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DP, DFS, K th Number, K번째 수", "date": "2022-03-11 22:44:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1520#include &amp;lt;bits/stdc++.h&amp;gt;#define for0(i,n) for(int i=0;i&amp;lt;n;i++)using namespace std;int n,m,a,b,c,x,r;pair&amp;lt;int,int&amp;gt;l[1&amp;lt;&amp;lt;17];int main(){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;for0(i,n){cin&amp;gt;&amp;gt;x;l[i]={x,i};};sort(l,l+n); for0(i,m){ cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;a--,b--;r=0; for0(j,n)if(a&amp;lt;=l[j].second&amp;amp;&amp;amp;l[j].second&amp;lt;=b)if(++r==c){x=l[j].first;break;} cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&#39;\\n&#39;; } return 0;}Why? The code above gets AC but the code below gets TLE#include &amp;lt;bits/stdc++.h&amp;gt;#define for0(i,n) for(int i=0;i&amp;lt;n;i++)using namespace std;pair&amp;lt;int,int&amp;gt;l[1&amp;lt;&amp;lt;17];int main(){ int n,m,a,b,c,x,r;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;for0(i,n){cin&amp;gt;&amp;gt;x;l[i]={x,i};};sort(l,l+n); for0(i,m){ cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;a--,b--;r=0; for0(j,n)if(a&amp;lt;=l[j].second&amp;amp;&amp;amp;l[j].second&amp;lt;=b)if(++r==c){x=l[j].first;break;} cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&#39;\\n&#39;; } return 0;}" }, { "title": "BOJ. Down Hill (1520)", "url": "/posts/BOJ-1520/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DP, DFS, Down Hill, 내리막 길", "date": "2022-03-11 18:28:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1520#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;int hmap[500][500];ll dp[500][500];bool visit[500][500];int di[4] = { -1, 0, 1, 0 };int dj[4] = { 0, 1, 0, -1 };int n, m;ll dfs(int ci, int cj) { if(dp[ci][cj] != 0) return dp[ci][cj]; if(ci == n-1 &amp;amp;&amp;amp; cj == m-1) return dp[ci][cj] = 1; for0(k, 4) { int ai = ci + di[k], aj = cj + dj[k]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;= n || aj &amp;gt;= m || hmap[ci][cj] &amp;lt;= hmap[ai][aj]) continue; if(dfs(ai, aj) == -1) continue; dp[ci][cj] += dfs(ai, aj); } if(dp[ci][cj] == 0) dp[ci][cj] = -1; return dp[ci][cj];}int main() { FASTIO; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for0(i, n) for0(j, m) cin &amp;gt;&amp;gt; hmap[i][j]; int cnt = 0; cout &amp;lt;&amp;lt; (dfs(0, 0) == -1 ? 0 : dfs(0, 0)); return 0;}" }, { "title": "BOJ. Match The Numbers (2494)", "url": "/posts/BOJ-2494/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DP, Match The Numbers, 숫자 맞추기", "date": "2022-03-11 05:00:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2494#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int INF = 987654321;// char mm[100][100];int di[4] = { -1, 0, 1, 0 };int dj[4] = { 0, 1, 0, -1 };int t, n, m, x, d;string src, des;int inc = 0;int dp[10000][10];pair&amp;lt;int,int&amp;gt; parent_and_rot[10000][10];int ans[10000];int pre(int val) { int quo = val / 10; int ans = val - 10 * quo; if(ans &amp;gt;= 0) return ans; return ans + 10;}int main(int argc, char *argv[]) { FASTIO; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; src &amp;gt;&amp;gt; des; for0(i, n) for0(j, 10) dp[i][j] = INF; int src_num = src[0]-&#39;0&#39;, des_num = des[0] - &#39;0&#39;, rot, cur_num; rot = des_num-src_num; if(rot &amp;lt; 0) rot+=10; if(rot) { dp[0][rot] = rot, dp[0][0] = 10 - rot; parent_and_rot[0][rot] = { -1, rot }; parent_and_rot[0][0] = { -1, rot - 10 }; } else dp[0][0] = 0, parent_and_rot[0][0] = { -1, 0 }; for1(i, n) { src_num = src[i]-&#39;0&#39;, des_num = des[i] - &#39;0&#39;; for0(j, 10) { if(dp[i-1][j] == INF) continue; cur_num = pre(src_num + j), rot; rot = des_num-cur_num; if(rot &amp;lt; 0) rot+=10; if(dp[i][pre(j + rot)] &amp;gt; dp[i-1][j] + rot) { dp[i][pre(j + rot)] = dp[i-1][j] + rot; parent_and_rot[i][pre(j+rot)] = { j, rot }; } if(dp[i][j] &amp;gt; dp[i-1][j] + 10 - rot) { dp[i][j] = dp[i-1][j] + 10 - rot; parent_and_rot[i][j] = { j, rot - 10 }; } } } int minv = INF, rot_idx = 0; for0(i, 10) if(minv &amp;gt; dp[n-1][i]) { minv = dp[n-1][i]; rot_idx = i; }; cout &amp;lt;&amp;lt; minv &amp;lt;&amp;lt; endl; for(int i = n-1; i&amp;gt;=0; i--) { ans[i] = parent_and_rot[i][rot_idx].second; rot_idx = parent_and_rot[i][rot_idx].first; } for0(i, n) { cout &amp;lt;&amp;lt; i+1 &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Square (7626)", "url": "/posts/BOJ-7626/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, Sweeping Geometry, Square, Important, Difficult, Review, MIT Programming Contest Team Contest 1 2008 No.7, 직사각형", "date": "2022-03-11 05:00:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/7626#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;struct line { int x; int uy, ly; bool start;};int n;vector&amp;lt;int&amp;gt; seg;vector&amp;lt;int&amp;gt; cnt;vector&amp;lt;line&amp;gt; lines;vector&amp;lt;int&amp;gt; y_values;ll tot_size;void update(int idx, int cl, int cr, int tl, int tr, int dval) { if(cr &amp;lt; tl || tr &amp;lt; cl) return; if(tl &amp;lt;= cl &amp;amp;&amp;amp; cr &amp;lt;= tr) cnt[idx] += dval; else { ll mid = (cl + cr) / 2; update(idx&amp;lt;&amp;lt;1, cl, mid, tl, tr, dval); update(idx&amp;lt;&amp;lt;1|1, mid + 1, cr, tl, tr, dval); } if(cnt[idx]) seg[idx] = y_values[cr + 1] - y_values[cl]; else { if(cl == cr) seg[idx] = 0; else seg[idx] = seg[idx&amp;lt;&amp;lt;1] + seg[idx&amp;lt;&amp;lt;1|1]; }}int main() { FASTIO; cin &amp;gt;&amp;gt; n; for0(i, n) { line sline, eline; sline.start = 1, eline.start = 0; cin &amp;gt;&amp;gt; sline.x &amp;gt;&amp;gt; eline.x &amp;gt;&amp;gt; sline.ly &amp;gt;&amp;gt; sline.uy; eline.ly = sline.ly, eline.uy = sline.uy; lines.push_back(sline); lines.push_back(eline); y_values.push_back(sline.ly); y_values.push_back(sline.uy); } sort(y_values.begin(), y_values.end()); y_values.erase(unique(y_values.begin(), y_values.end()), y_values.end()); int N = 1 &amp;lt;&amp;lt; (int)(ceil(log2(y_values.size()) + 1)); seg.resize(N); cnt.resize(N); sort(lines.begin(), lines.end(), [](line l1, line l2) { return l1.x &amp;lt; l2.x; }); vector&amp;lt;int&amp;gt;::iterator start_iter = y_values.begin(); for0(i, lines.size() - 1) { int rank_1 = lower_bound(start_iter, y_values.end(), lines[i].ly) - start_iter; int rank_2 = lower_bound(start_iter, y_values.end(), lines[i].uy) - start_iter; update(1, 0, y_values.size() - 1, rank_1, rank_2 - 1, lines[i].start ? 1 : -1); tot_size += (ll)seg[1] * (lines[i+1].x - lines[i].x); } cout &amp;lt;&amp;lt; tot_size; return 0;}" }, { "title": "BOJ. Line Group (2162)", "url": "/posts/BOJ-2162/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Outer Product, CCW, Union Find, Geometry, Line Group, 선분 그룹", "date": "2022-03-10 16:54:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2162CCW + Union FindPoint: Line AB and CD : ccw(ABC) and ccw(ABD)if(ccw(ABC) == ccw(ABD) == 0) compare the range A B C D, C D A B#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;// const int MAX = 2002;// const int INF = 987654321;// const int OPPOSITE = 1;// const int ONEZERO = 2;// const int TWOZERO = 3;// const int SAMESIDE = 4;struct line { pair&amp;lt;int, int&amp;gt; s, e;};int n;vector&amp;lt;line&amp;gt; lines;vector&amp;lt;int&amp;gt; ancestor;ll ccw(pair&amp;lt;int,int&amp;gt; p1, pair&amp;lt;int,int&amp;gt; mid, pair&amp;lt;int,int&amp;gt; p2) { ll outer = (ll)p1.first * mid.second + (ll)mid.first *p2.second + (ll)p2.first * p1.second; outer -= ((ll)mid.first * p1.second + (ll)p1.first *p2.second + (ll)p2.first * mid.second); return outer;}bool lines_meet(line l1, line l2) { ll ccw1 = ccw(l1.s, l1.e, l2.s) * ccw(l1.s, l1.e, l2.e); ll ccw2 = ccw(l2.s, l2.e, l1.s) * ccw(l2.s, l2.e, l1.e); if(ccw1 == 0 &amp;amp;&amp;amp; ccw2 == 0) { int ax = l1.s.first, bx = l1.e.first, cx = l2.s.first, dx = l2.e.first; int ay = l1.s.second, by = l1.e.second, cy = l2.s.second, dy = l2.e.second; if(ax &amp;gt; bx) swap(ax, bx); if(cx &amp;gt; dx) swap(cx, dx); if(ay &amp;gt; by) swap(ay, by); if(cy &amp;gt; dy) swap(cy, dy); return ax &amp;lt;= dx &amp;amp;&amp;amp; cx &amp;lt;= bx &amp;amp;&amp;amp; ay &amp;lt;= dy &amp;amp;&amp;amp; cy &amp;lt;= by; } return ccw1 &amp;lt;= 0 &amp;amp;&amp;amp; ccw2 &amp;lt;= 0;}int get_parent(int a) { if(a == ancestor[a]) return a; return ancestor[a] = get_parent(ancestor[a]);}void unify(int a, int b) { int pa = get_parent(a), pb = get_parent(b); if(pa &amp;gt;= pb) ancestor[pa] = pb; else ancestor[pb] = pa;}int main() { FASTIO; cin &amp;gt;&amp;gt; n; for0(i, n) ancestor.push_back(i); lines.resize(n); for0(i, n) cin &amp;gt;&amp;gt; lines[i].s.first &amp;gt;&amp;gt; lines[i].s.second &amp;gt;&amp;gt; lines[i].e.first &amp;gt;&amp;gt; lines[i].e.second; for0(i, n) { for(int j = i+1; j &amp;lt; n; j++) { if(lines_meet(lines[i], lines[j])) unify(i, j); } } int cnt = 0; map&amp;lt;int, int&amp;gt; union_cnt; for0(i, n) { int anc_idx = get_parent(i); if(union_cnt.find(anc_idx) == union_cnt.end()) union_cnt[anc_idx] = 1; else union_cnt[anc_idx]++; } int max_v = 0; for(map&amp;lt;int, int&amp;gt;:: iterator iter = union_cnt.begin(); iter!=union_cnt.end(); iter++) { max_v = max(max_v, iter-&amp;gt;second); } cout &amp;lt;&amp;lt; union_cnt.size() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; max_v; return 0;}" }, { "title": "BOJ. Crossing Lines 3 (20149)", "url": "/posts/BOJ-20149/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Outer Product, CCW, Geometry, Crossing Lines 3, 선분 그룹 3", "date": "2022-03-10 04:54:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/20149#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;const int OPPOSITE = 1;const int ONEZERO = 2;const int TWOZERO = 3;const int SAMESIDE = 4;struct line { pair&amp;lt;int, int&amp;gt; p1, p2;};int n, size1, size2;line l1, l2;int cross_check(line base, line line) { int di1 = line.p1.first - base.p1.first, dj1 = line.p1.second - base.p1.second; int di2 = line.p2.first - base.p1.first, dj2 = line.p2.second - base.p1.second; int base_di = base.p2.first - base.p1.first, base_dj = base.p2.second - base.p1.second; ll outer_product1 = (ll)di1*base_dj - (ll)base_di*dj1, outer_product2 = (ll)di2*base_dj - (ll)base_di*dj2; if((outer_product1 &amp;gt; 0 &amp;amp;&amp;amp; outer_product2 &amp;gt; 0) || (outer_product1 &amp;lt; 0 &amp;amp;&amp;amp; outer_product2 &amp;lt; 0)) return SAMESIDE; if(outer_product1 == 0 &amp;amp;&amp;amp; outer_product2 == 0) return TWOZERO; if(outer_product1 == 0 || outer_product2 == 0) return ONEZERO; return OPPOSITE;}pair&amp;lt;double, double&amp;gt; intersection(line base, line line) { int di1 = line.p1.first - base.p1.first, dj1 = line.p1.second - base.p1.second; int di2 = line.p2.first - base.p1.first, dj2 = line.p2.second - base.p1.second; int base_di = base.p2.first - base.p1.first, base_dj = base.p2.second - base.p1.second; ll outer_product1 = (ll)di1*base_dj - (ll)base_di*dj1, outer_product2 = (ll)di2*base_dj - (ll)base_di*dj2; double ratio = (double)abs(outer_product1) / (abs(outer_product1) + abs(outer_product2)); pair&amp;lt;double, double&amp;gt; ans; ans.first = line.p1.first + (line.p2.first - line.p1.first) * ratio; ans.second = line.p1.second + (line.p2.second - line.p1.second) * ratio; return ans;}int main() { FASTIO; cout &amp;lt;&amp;lt; fixed; cout.precision(12); cin &amp;gt;&amp;gt; l1.p1.first &amp;gt;&amp;gt; l1.p1.second &amp;gt;&amp;gt; l1.p2.first &amp;gt;&amp;gt; l1.p2.second; cin &amp;gt;&amp;gt; l2.p1.first &amp;gt;&amp;gt; l2.p1.second &amp;gt;&amp;gt; l2.p2.first &amp;gt;&amp;gt; l2.p2.second; int check1 = cross_check(l1, l2), check2 = cross_check(l2, l1); // cout &amp;lt;&amp;lt; &quot;check ? &quot; &amp;lt;&amp;lt; check1 &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; check2 &amp;lt;&amp;lt; endl; if(check1 == SAMESIDE || check2 == SAMESIDE) { cout &amp;lt;&amp;lt; 0; return 0; } if(check1 == TWOZERO &amp;amp;&amp;amp; check2 == TWOZERO) { if(max(l1.p1.first, l1.p2.first) &amp;lt; min(l2.p1.first, l2.p2.first) || max(l2.p1.first, l2.p2.first) &amp;lt; min(l1.p1.first, l1.p2.first) || max(l1.p1.second, l1.p2.second) &amp;lt; min(l2.p1.second, l2.p2.second) || max(l2.p1.second, l2.p2.second) &amp;lt; min(l1.p1.second, l1.p2.second)) cout &amp;lt;&amp;lt; 0; else { cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl; if(l1.p1.first == l1.p2.first &amp;amp;&amp;amp; l2.p1.first == l2.p2.first) { if(min(l1.p1.second, l1.p2.second) &amp;lt;= min(l2.p1.second, l2.p2.second) &amp;amp;&amp;amp; min(l2.p1.second, l2.p2.second) &amp;lt; max(l1.p1.second, l1.p2.second)) return 0; if(min(l2.p1.second, l2.p2.second) &amp;lt;= min(l1.p1.second, l1.p2.second) &amp;amp;&amp;amp; min(l1.p1.second, l1.p2.second) &amp;lt; max(l2.p1.second, l2.p2.second)) return 0; } else { if(min(l1.p1.first, l1.p2.first) &amp;lt;= min(l2.p1.first, l2.p2.first) &amp;amp;&amp;amp; min(l2.p1.first, l2.p2.first) &amp;lt; max(l1.p1.first, l1.p2.first)) return 0; if(min(l2.p1.first, l2.p2.first) &amp;lt;= min(l1.p1.first, l1.p2.first) &amp;amp;&amp;amp; min(l1.p1.first, l1.p2.first) &amp;lt; max(l2.p1.first, l2.p2.first)) return 0; } pair&amp;lt;int, int&amp;gt; tmp; if(l1.p1.first == l2.p1.first &amp;amp;&amp;amp; l1.p1.second == l2.p1.second) tmp = l1.p1; if(l1.p1.first == l2.p2.first &amp;amp;&amp;amp; l1.p1.second == l2.p2.second) tmp = l1.p1; if(l1.p2.first == l2.p1.first &amp;amp;&amp;amp; l1.p2.second == l2.p1.second) tmp = l1.p2; if(l1.p2.first == l2.p2.first &amp;amp;&amp;amp; l1.p2.second == l2.p2.second) tmp = l1.p2; cout &amp;lt;&amp;lt; tmp.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; tmp.second; } return 0; } if(check1 == ONEZERO &amp;amp;&amp;amp; check2 == ONEZERO) { cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl; pair&amp;lt;int, int&amp;gt; tmp; if(l1.p1.first == l2.p1.first &amp;amp;&amp;amp; l1.p1.second == l2.p1.second) tmp = l1.p1; if(l1.p1.first == l2.p2.first &amp;amp;&amp;amp; l1.p1.second == l2.p2.second) tmp = l1.p1; if(l1.p2.first == l2.p1.first &amp;amp;&amp;amp; l1.p2.second == l2.p1.second) tmp = l1.p2; if(l1.p2.first == l2.p2.first &amp;amp;&amp;amp; l1.p2.second == l2.p2.second) tmp = l1.p2; cout &amp;lt;&amp;lt; tmp.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; tmp.second; return 0; } pair&amp;lt;double, double&amp;gt; point; if(check1 == ONEZERO) point = intersection(l2, l1); else point = intersection(l1, l2); cout &amp;lt;&amp;lt; &quot;1\\n&quot; &amp;lt;&amp;lt; point.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; point.second; return 0;}" }, { "title": "BOJ. Two Circles (7869)", "url": "/posts/BOJ-7869/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Geometry, Two Circles, 두 원", "date": "2022-03-09 23:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/7869#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;int n;int main() { // FASTIO; cout &amp;lt;&amp;lt; fixed; cout.precision(3); double x1, y1, r1, x2, y2, r2; cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; r1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; r2; double s = 0; double dis_sqr = pow(abs(x1 - x2), 2) + pow(abs(y1 - y2), 2); if(dis_sqr &amp;gt;= pow(r1 + r2, 2)) { cout &amp;lt;&amp;lt; 0.000; return 0; } if(dis_sqr &amp;lt;= pow(abs(r1 - r2), 2)) { cout &amp;lt;&amp;lt; M_PI * pow(min(r1, r2), 2); return 0; } double deg1 = acos((dis_sqr + pow(r1, 2) - pow(r2, 2)) / (2*sqrt(dis_sqr)*r1)); double deg2 = acos((dis_sqr + pow(r2, 2) - pow(r1, 2)) / (2*sqrt(dis_sqr)*r2)); s+= pow(r1, 2) * deg1; // pow(p1, 2) * (2deg1) / 2; s+= pow(r2, 2) * deg2; s-=pow(r1, 2) * sin(2*deg1) / 2; s-=pow(r2, 2) * sin(2*deg2) / 2; cout &amp;lt;&amp;lt; s; return 0;}" }, { "title": "BOJ. Two Circles (1069)", "url": "/posts/BOJ-1069/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Geometry, Two Circles, 두 원", "date": "2022-03-09 23:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1069#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;int x, y, d, t, p;int main() { FASTIO; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; d &amp;gt;&amp;gt; t; cout&amp;lt;&amp;lt;fixed; cout.precision(11); double dis = sqrt(pow(x, 2) + pow(y, 2)), r; int p = (int)dis / d; r = dis - p*d; if(p) cout &amp;lt;&amp;lt; min({ dis, t * p + r, (double)t * (p - 1) + 2 * t, t * (p + 1) + abs(r - d) }); else cout &amp;lt;&amp;lt; min({ dis, t + abs(d - r), (double)2 * t }); return 0;}short version for fun#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int x,y,d,p;double t,D,r;int main(){ cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;d&amp;gt;&amp;gt;t; D=sqrt(x*x+y*y),p=D/d,r=D-p*d; printf(&quot;%.9lf&quot;,min({D,t*p+r,max(0.0,t*--p)+2*t,t*++++p+abs(r-d)})); return 0;}" }, { "title": "BOJ. Crossing Lines (17386)", "url": "/posts/BOJ-17386/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Outer Product, CCW, Geometry, Crossing Lines, 선분 교차 1", "date": "2022-03-09 22:46:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17386## Point: Line AB and CD : ccw(ABC) and ccw(ABD)#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;int n;vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; points;bool ccw(pair&amp;lt;int, int&amp;gt; line[2], pair&amp;lt;int,int&amp;gt; p) { int dx1 = line[1].first - line[0].first, dy1 = line[1].second - line[0].second; int dx2 = p.first - line[0].first, dy2 = p.second - line[0].second; ll result = (ll)dx1*dy2 - (ll)dy1*dx2; return result &amp;gt; 0;}int main() { FASTIO; pair&amp;lt;int, int&amp;gt; l1[2], l2[2]; cin &amp;gt;&amp;gt; l1[0].first &amp;gt;&amp;gt; l1[0].second &amp;gt;&amp;gt; l1[1].first &amp;gt;&amp;gt; l1[1].second &amp;gt;&amp;gt; l2[0].first &amp;gt;&amp;gt; l2[0].second &amp;gt;&amp;gt; l2[1].first &amp;gt;&amp;gt; l2[1].second; bool meet = true; bool c1 = ccw(l1, l2[0]), c2 = ccw(l1, l2[1]); if(c1 == c2) meet = false; if(meet) { c1 = ccw(l2, l1[0]), c2 = ccw(l2, l1[1]); if(c1 == c2) meet = false; } cout &amp;lt;&amp;lt; (meet ? 1 : 0); return 0;}" }, { "title": "BOJ. Crossing Lines 2 (17387)", "url": "/posts/BOJ-17387/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Outer Product, CCW, Geometry, Crossing Lines 2, 선분 교차 2", "date": "2022-03-09 22:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17387## Point: Line AB and CD : ccw(ABC) and ccw(ABD) ## if(ccw(ABC) == ccw(ABD) == 0) compare the range A B C D, C D A B#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;int n;vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; points;int ccw(pair&amp;lt;int, int&amp;gt; line[2], pair&amp;lt;int,int&amp;gt; p) { int dx1 = line[1].first - line[0].first, dy1 = line[1].second - line[0].second; int dx2 = p.first - line[0].first, dy2 = p.second - line[0].second; ll result = (ll)dx1*dy2 - (ll)dy1*dx2; return result == 0 ? 0 : (result &amp;gt; 0 ? 1 : -1);}int main() { FASTIO; pair&amp;lt;int, int&amp;gt; l1[2], l2[2]; cin &amp;gt;&amp;gt; l1[0].first &amp;gt;&amp;gt; l1[0].second &amp;gt;&amp;gt; l1[1].first &amp;gt;&amp;gt; l1[1].second &amp;gt;&amp;gt; l2[0].first &amp;gt;&amp;gt; l2[0].second &amp;gt;&amp;gt; l2[1].first &amp;gt;&amp;gt; l2[1].second; bool meet = true; int c1 = ccw(l1, l2[0]), c2 = ccw(l1, l2[1]); if(c1 == c2) { if(c1 != 0) meet = false; else if( min(l1[0].first, l1[1].first) &amp;gt; max(l2[0].first, l2[1].first) || min(l2[0].first, l2[1].first) &amp;gt; max(l1[0].first, l1[1].first) || min(l1[0].second, l1[1].second) &amp;gt; max(l2[0].second, l2[1].second) || min(l2[0].second, l2[1].second) &amp;gt; max(l1[0].second, l1[1].second) ) meet = false; } if(meet) { c1 = ccw(l2, l1[0]), c2 = ccw(l2, l1[1]); if(c1 == c2) { if(c1 != 0) meet = false; } } cout &amp;lt;&amp;lt; (meet ? 1 : 0); return 0;}" }, { "title": "BOJ. The Area Of The Polygon (2166)", "url": "/posts/BOJ-2166/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Network Flow, CCW, Cross Product, The Area Of The Polygon, 다각형의 면적", "date": "2022-03-09 20:34:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2166#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;int n;vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; points;ll calc_size(pair&amp;lt;int,int&amp;gt; v1, pair&amp;lt;int,int&amp;gt; v2) { return (ll)v1.first * v2.second - (ll)v1.second * v2.first;}int main() { FASTIO; cin &amp;gt;&amp;gt; n; for0(i, n) { int x, y; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; points.push_back(make_pair(x, y)); } double size = 0; for1(i, n - 1) { size += calc_size( { points[i].first - points[0].first, points[i].second - points[0].second }, { points[i+1].first - points[0].first, points[i+1].second - points[0].second } ); } cout &amp;lt;&amp;lt; fixed; cout.precision(1); cout &amp;lt;&amp;lt; (abs(size)/2); return 0;}" }, { "title": "BOJ. Passionate Gang-Ho 4 (11378)", "url": "/posts/BOJ-11378/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Network Flow, Edmonds Karf, Passionate Gang-Ho 4, 열혈강호 4", "date": "2022-03-09 18:46:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11378#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 2002;const int INF = 987654321;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; edge;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; capacity;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; flow;vector&amp;lt;int&amp;gt; pre;int n, m, k;int start, second, end_idx;int edmonds_karp() { queue&amp;lt;int&amp;gt; q; int tot_flow = 0; while(1) { q = {}; q.push(0); fill(pre.begin(), pre.end(), -1); while(!q.empty()) { int cur = q.front(); q.pop(); if(cur == end_idx) break; for(int next: edge[cur]) { if(pre[next] == -1 &amp;amp;&amp;amp; capacity[cur][next] - flow[cur][next] &amp;gt; 0) { pre[next] = cur; q.push(next); } } } if(pre[end_idx] == -1) break; int min_flow = INF; for(int i = end_idx; i; i = pre[i]) min_flow = min(min_flow, capacity[pre[i]][i] - flow[pre[i]][i]); for(int i = end_idx; i; i = pre[i]) { flow[pre[i]][i] += min_flow; flow[i][pre[i]] -= min_flow; } tot_flow += min_flow; } return tot_flow;}int main() { FASTIO; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k; edge.resize(n + m + 3); pre.resize(n + m + 3); capacity.resize(n + m + 3); flow.resize(n + m + 3); start = 0, second = n+m+1, end_idx = n+m+2; for0(i, n+m+3) { capacity[i].resize(n+m+3); flow[i].resize(n+m+3); } edge[start].push_back(second); capacity[start][second] = k; edge[second].push_back(start); for1(i, n + 1) { int work_num; cin &amp;gt;&amp;gt; work_num; edge[start].push_back(i); edge[i].push_back(start); capacity[start][i] = 1; edge[second].push_back(i); edge[i].push_back(second); capacity[second][i] = k; for0(j, work_num) { int in; cin &amp;gt;&amp;gt; in; in += n; edge[i].push_back(in); capacity[i][in] = 1; edge[in].push_back(i); edge[in].push_back(end_idx); edge[end_idx].push_back(in); capacity[in][end_idx] = 1; } } cout &amp;lt;&amp;lt; edmonds_karp(); return 0;}" }, { "title": "BOJ. Maximum Flow (6086)", "url": "/posts/BOJ-6086/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Network Flow, Edmonds Karp, Maximum Flow, 최대 유량", "date": "2022-03-09 15:32:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/6086#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n;int capacity[52][52];int flow[52][52];vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; adj;int convert(char ch) { return ch &amp;gt; &#39;Z&#39; ? ch - &#39;a&#39; + 26 : ch - &#39;A&#39;;}int solve() { queue&amp;lt;int&amp;gt; q; int flow_max = 0; while(1) { q = {}; q.push(0); int prev[52]; fill(prev, prev + 52, -1); while(!q.empty()) { int cur = q.front(); q.pop(); if(cur == 25) break; for(int next : adj[cur]) { if(prev[next] == -1 &amp;amp;&amp;amp; capacity[cur][next] - flow[cur][next]) { q.push(next); prev[next] = cur; } } } if(prev[25] == -1) break; int min_flow = INF; for(int s = 25; s != 0; s = prev[s]) { min_flow = min(min_flow, capacity[prev[s]][s] - flow[prev[s]][s]); } for(int s = 25; s != 0; s= prev[s]) { flow[prev[s]][s] += min_flow; flow[s][prev[s]] -= min_flow; } flow_max += min_flow; } return flow_max;}int main() { FASTIO; cin &amp;gt;&amp;gt; n; adj.resize(52); for0(i, n) { char from, to; int c; cin &amp;gt;&amp;gt; from &amp;gt;&amp;gt; to &amp;gt;&amp;gt; c; int cfrom = convert(from), cto = convert(to); capacity[cfrom][cto] += c; capacity[cto][cfrom] += c; adj[cfrom].push_back(cto); adj[cto].push_back(cfrom); } cout &amp;lt;&amp;lt; solve(); return 0;}" }, { "title": "BOJ. Passionate Gang-Ho 2 (11376)", "url": "/posts/BOJ-11376/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Network Flow, Bipartite Matching, Passionate Gang-Ho 2, 열혈강호2", "date": "2022-03-09 02:09:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11376First method and Second method both works.But you might get TLE with second method becausethe number of candidates of previous matching(from[r_idx]) isbigger.#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m;vector&amp;lt;bool&amp;gt; updated;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; edge;vector&amp;lt;int&amp;gt; from;vector&amp;lt;int&amp;gt; doing;bool can_match(int l_idx) { if(updated[l_idx]) return false; updated[l_idx] = true; for(int r_idx: edge[l_idx]) { if(from[r_idx] == -1 || can_match(from[r_idx])) { from[r_idx] = l_idx; return true; } } return false;}int solve() { int cnt = 0; /* ---First method--- */ for0(i, n) { for0(iter, 2) { updated = vector&amp;lt;bool&amp;gt;(n, false); if(can_match(i)) cnt++; } } /* ---Second method--- */ // for0(iter, 2) { // for0(i, n) { // updated = vector&amp;lt;bool&amp;gt;(n, false); // if(can_match(i)) cnt++; // } // } return cnt;}int main() { FASTIO; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; edge.resize(n &amp;lt;&amp;lt; 1); from.resize(m, -1); for0(i, n) { int in; cin &amp;gt;&amp;gt; in; edge[i].resize(in); for0(j, edge[i].size()) { cin &amp;gt;&amp;gt; in; edge[i][j] = in - 1; }; } cout &amp;lt;&amp;lt; solve(); return 0;}" }, { "title": "BOJ. Passionate Gang-Ho (11375)", "url": "/posts/BOJ-11375/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Network Flow, Bipartite Matching, Passionate Gang-Ho, 열혈강호", "date": "2022-03-09 01:49:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11375#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)#define command_param int argc, char *argv[]#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m;vector&amp;lt;bool&amp;gt; updated;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; edge;vector&amp;lt;int&amp;gt; from;bool can_match(int l_idx) { if(updated[l_idx]) return false; updated[l_idx] = true; for(int r_idx: edge[l_idx]) { if(from[r_idx] == -1 || can_match(from[r_idx])) { from[r_idx] = l_idx; return true; } } return false;}int solve() { int cnt = 0; for0(i, n) { updated = vector&amp;lt;bool&amp;gt;(n, false); if(can_match(i)) cnt++; } return cnt;}int main() { FASTIO; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; edge.resize(n); from.resize(m, -1); for0(i, n) { int in; cin &amp;gt;&amp;gt; in; edge[i].resize(in); for0(j, edge[i].size()) { cin &amp;gt;&amp;gt; in; edge[i][j] = in - 1; }; } cout &amp;lt;&amp;lt; solve(); return 0;}" }, { "title": "BOJ. Palindrome Is Not A Palindrome (15927)", "url": "/posts/BOJ-15927/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Z Algorithm, String, Palindrome Is Not A Palindrome, 회문은 회문아니야!!", "date": "2022-03-09 01:07:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/15927#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;string s;int solve() { int l = 0, r = s.size() - 1; bool all_same = true, is_pal = true; while(l &amp;lt;= r) { if(s[l] != s[r]) { all_same = false; is_pal = false; break; } if(l &amp;amp;&amp;amp; s[l-1] != s[l]) all_same = false; l++; r--; } return is_pal ? (all_same ? -1 : s.size() - 1) : s.size();}int main(int argc, char *argv[]) { cin &amp;gt;&amp;gt; s; cout &amp;lt;&amp;lt; solve(); return 0;}" }, { "title": "BOJ. Allocating Cattle Shed (2188)", "url": "/posts/BOJ-2188/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Bipartite Matching, Allocating Cattle Shed, 축사 배정", "date": "2022-03-08 11:58:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2188#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; edge;vector&amp;lt;bool&amp;gt; visit;vector&amp;lt;int&amp;gt; from;bool dfs(int from_idx) { if(visit[from_idx]) return false; visit[from_idx] = true; for(int to: edge[from_idx]) { if(from[to] == -1 || dfs(from[to])) { from[to] = from_idx; return true; } } return false;}int main(int argc, char *argv[]) { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; from = vector&amp;lt;int&amp;gt;(m, -1); edge.resize(n); for0(i, n) { int in; cin &amp;gt;&amp;gt; in; edge[i].resize(in); for0(j, in) { int in; cin &amp;gt;&amp;gt; in; edge[i][j] = in - 1; } } int cnt = 0; for0(i, n) { visit = vector&amp;lt;bool&amp;gt;(n, false); if(dfs(i)) cnt++; } cout &amp;lt;&amp;lt; cnt; return 0;}" }, { "title": "BOJ. Round Trip From City To City (17412)", "url": "/posts/BOJ-17412/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Network Flow, Bipartite Matching, Round Trip From City To City, 도시 왕복하기 1", "date": "2022-03-08 10:58:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17412#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;cmath&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, p, flow_tot;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; adj;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; capacity;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; flow;void edmonds_karp() { // vector&amp;lt;int&amp;gt; prev(n+1); queue&amp;lt;int&amp;gt; q; while(true) { vector&amp;lt;int&amp;gt; prev(n+1, -1); q.push(1); while(!q.empty()) { int cur = q.front(); q.pop(); for(int next: adj[cur]) { if(prev[next] == -1 &amp;amp;&amp;amp; capacity[cur][next] - flow[cur][next] &amp;gt; 0) { prev[next] = cur; q.push(next); if(next == 2) break; } } } if(prev[2] == -1) break; int min_flow = INF; for(int i = 2; i != 1; i = prev[i]) min_flow = min(min_flow, capacity[prev[i]][i] - flow[prev[i]][i]); for(int i = 2; i != 1; i = prev[i]) { flow[prev[i]][i] += min_flow; flow[i][prev[i]] -= min_flow; } flow_tot += min_flow; }}int main(int argc, char *argv[]) { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p; adj.resize(n+1); flow.resize(n+1); for0(i, n+1) flow[i].resize(n+1); capacity.resize(n+1); for0(i, n+1) capacity[i].resize(n+1); for0(i, p) { int from, to; cin &amp;gt;&amp;gt; from &amp;gt;&amp;gt; to; adj[from].push_back(to); adj[to].push_back(from); capacity[from][to] = 1; } edmonds_karp(); cout &amp;lt;&amp;lt; flow_tot; return 0;}" }, { "title": "BOJ. Repeated Pattern (16229)", "url": "/posts/BOJ-16229/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Z Algorithm, String, Repeated Pattern, 반복 패턴", "date": "2022-03-07 10:58:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16229#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;string s;vector&amp;lt;int&amp;gt; z;void __z() { z.resize(s.size()); int l = s.size(), r = s.size() - 1; z[s.size() - 1] = s.size(); for(int i = s.size() - 2; i &amp;gt;= 0; i--) { z[i] = (l &amp;lt;= i) ? min(z[i-r+s.size()-1], i-l+1) : 0; // cout &amp;lt;&amp;lt; &quot; z : &quot; &amp;lt;&amp;lt; z[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; l &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; while(i - z[i] &amp;gt;= 0 &amp;amp;&amp;amp; s[i-z[i]] == s[s.size() - 1 - z[i]]) z[i]++; if(i - z[i] + 1 &amp;lt; l) { l = i - z[i] + 1; r = i; } }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; s; int m; cin &amp;gt;&amp;gt; m; __z(); for0(i, m) { int in; cin &amp;gt;&amp;gt; in; cout &amp;lt;&amp;lt; z[in - 1] &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. String And Query (13713)", "url": "/posts/BOJ-13713/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Z Algorithm, String, String And Query, 문자열과 쿼리", "date": "2022-03-07 10:58:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/13713Getting Longest Common Suffix#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;string s;vector&amp;lt;int&amp;gt; z;void __z() { z.resize(s.size()); int l = s.size(), r = s.size() - 1; z[s.size() - 1] = s.size(); for(int i = s.size() - 2; i &amp;gt;= 0; i--) { z[i] = (l &amp;lt;= i) ? min(z[i-r+s.size()-1], i-l+1) : 0; // cout &amp;lt;&amp;lt; &quot; z : &quot; &amp;lt;&amp;lt; z[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; l &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; while(i - z[i] &amp;gt;= 0 &amp;amp;&amp;amp; s[i-z[i]] == s[s.size() - 1 - z[i]]) z[i]++; if(i - z[i] + 1 &amp;lt; l) { l = i - z[i] + 1; r = i; } }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; s; int m; cin &amp;gt;&amp;gt; m; __z(); for0(i, m) { int in; cin &amp;gt;&amp;gt; in; cout &amp;lt;&amp;lt; z[in - 1] &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "AtCoder. ABC 238 D ABC Transform", "url": "/posts/Atcoder-D-ABC-Transform/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-03-06 09:00:00 +0900", "snippet": "[Link] https://atcoder.jp/contests/abc242/tasks/abc242_d#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;string s;int q;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; q; for0(i, q) { ll t, k, plus = 0; cin &amp;gt;&amp;gt; t &amp;gt;&amp;gt; k; k--; while(k != 0 &amp;amp;&amp;amp; t) { plus += (k &amp;amp; 1) ? 2 : 1; k &amp;gt;&amp;gt;= 1; t--; } ll idx = (plus + s[k] - &#39;A&#39; + t) % 3; cout &amp;lt;&amp;lt; (char)(&#39;A&#39; + idx) &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "AtCoder. ABC 238 C 1111gal password", "url": "/posts/Atcoder-C-1111gal-password/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-03-06 09:00:00 +0900", "snippet": "[Link] https://atcoder.jp/contests/abc242/tasks/abc242_c#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;const ll mod = 998244353;int n;vector&amp;lt;vector&amp;lt;ll&amp;gt;&amp;gt; dp;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; dp.resize(n + 1); dp[1].resize(10); for1(i, 10) dp[1][i] = 1l; for(int i = 2; i &amp;lt;= n; i++) { dp[i].resize(10); dp[i][1] = dp[i-1][1] + dp[i-1][2]; dp[i][9] = dp[i-1][9] + dp[i-1][8]; for(int j = 2; j &amp;lt; 9; j++) dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1]; for1(j, 10) { if(dp[i][j] &amp;gt;= mod&amp;lt;&amp;lt;1) dp[i][j] -= mod&amp;lt;&amp;lt;1; else if(dp[i][j] &amp;gt;= mod) dp[i][j] -= mod; } } ll ans = 0; for1(j, 10) ans+=dp[n][j]; ans%=mod; cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. Report Problem No.15164 (16163)", "url": "/posts/BOJ-16163/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Manacher, Report Problem No.15164, 15164번_제보", "date": "2022-03-05 15:55:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16163#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;string s;ll ans = 0;void solve() { int l_odd = 0, r_odd = -1; int l_even = 0, r_even = -1; vector&amp;lt;int&amp;gt; odd(s.size(), 1); vector&amp;lt;int&amp;gt; even(s.size(), 0); for(int i = 0; i &amp;lt; s.size(); i++) { if(i &amp;lt;= r_odd) odd[i] = min(r_odd - i + 1, odd[l_odd+r_odd-i]); if(i &amp;lt;= r_even) even[i] = min(r_even - i, even[l_even+r_even - i - 1]); while(i-odd[i]&amp;gt;=0 &amp;amp;&amp;amp; i+odd[i]&amp;lt;s.size() &amp;amp;&amp;amp; s[i-odd[i]] == s[i+odd[i]]) odd[i]++; while(i-even[i]&amp;gt;=0 &amp;amp;&amp;amp; i+even[i]+1&amp;lt;s.size() &amp;amp;&amp;amp; s[i-even[i]] == s[i+even[i]+1]) even[i]++; if(i + odd[i] - 1 &amp;gt; r_odd) { r_odd = i + odd[i] - 1; l_odd = i - odd[i] + 1; } if(i + even[i] &amp;gt; r_even) { r_even = i + even[i]; l_even = i + 1 - even[i]; } ans += (odd[i] + even[i]); }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; s; solve(); cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. Find Kth Shortest Path (1854)", "url": "/posts/BOJ-1854/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Dijkstra, Graph, MST, Find Kth Shortest Path, K번째 최단경로 찾기", "date": "2022-03-05 04:34:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1854#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m, k;vector&amp;lt;map&amp;lt;int, int&amp;gt;&amp;gt; time;int update_cnt[1000];int dijk[1000];struct cmp { bool operator()(pair&amp;lt;int, int&amp;gt; p1, pair&amp;lt;int, int&amp;gt; p2) { return p1.first &amp;gt; p2.first; }};int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k; time.resize(n); for0(i, m) { int a, b, c; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c; a--, b--; time[a][b] = c; } priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;, cmp&amp;gt; pq; dijk[0] = 0; pq.push({ 0, 0 }); while(!pq.empty()) { pair&amp;lt;int,int&amp;gt; p = pq.top(); pq.pop(); int v = p.first, idx = p.second; if(update_cnt[idx] &amp;gt;= k) continue; update_cnt[idx]++; dijk[idx] = v; for(auto map_p: time[idx]) { int dest = map_p.first, edge_val = map_p.second; if(update_cnt[dest] &amp;gt;= k) continue; pq.push({ v + edge_val, dest }); } } for0(i, n) { if(update_cnt[i] &amp;lt; k) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; dijk[i] &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Ship (1092)", "url": "/posts/BOJ-1092/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Ship, K번째 최단경로 찾기", "date": "2022-03-05 02:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1092#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m;vector&amp;lt;int&amp;gt; crane;multiset&amp;lt;int&amp;gt; lugage;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; crane.resize(n); for0(i, n) cin &amp;gt;&amp;gt; crane[i]; cin &amp;gt;&amp;gt; m; for0(i, m) { int in; cin &amp;gt;&amp;gt; in; lugage.insert(in); } sort(crane.begin(), crane.end(), greater&amp;lt;int&amp;gt;()); int time = 0; bool can = true, break_all = false;; while(1) { for0(i, n) { multiset&amp;lt;int&amp;gt;::iterator iter = upper_bound(lugage.begin(), lugage.end(), crane[i]); if(iter == lugage.begin()) { if(i == 0) { cout &amp;lt;&amp;lt; -1; return 0; } break; } lugage.erase(--iter); if(lugage.empty()) { break_all = true; break; } } time++; if(break_all) break; } cout &amp;lt;&amp;lt; time; return 0;}" }, { "title": "BOJ. Sensor (2212)", "url": "/posts/BOJ-2212/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sensor, 센서", "date": "2022-03-04 23:44:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2212#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, k;set&amp;lt;int&amp;gt; sensors;vector&amp;lt;int&amp;gt; svec;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for0(i, n) { int in; cin &amp;gt;&amp;gt; in; sensors.insert(in);}; if((int)sensors.size() == 1) { cout &amp;lt;&amp;lt; 0; return 0; } svec.resize(sensors.size()); copy(sensors.begin(), sensors.end(), svec.begin()); sort(svec.begin(), svec.end()); vector&amp;lt;int&amp;gt; dis; for(int i = 0; i &amp;lt; (int)svec.size() - 1; i++) dis.push_back(svec[i+1] - svec[i]); sort(dis.begin(), dis.end(), greater&amp;lt;int&amp;gt;()); int erase_cnt = min(k - 1, (int)dis.size()), erase_len = 0; for0(i, erase_cnt) erase_len+=dis[i]; cout &amp;lt;&amp;lt; (svec.back() - svec.front() - erase_len); return 0;}" }, { "title": "BOJ. Castle Difense (17135)", "url": "/posts/BOJ-17135/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Castle Difense, 캐슬 디펜스", "date": "2022-03-04 22:46:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17135#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m, d, ans, enemy_cnt;bool mm[15][15];bool tmp[15][15];bool swap_arr[15][15];set&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; kill;vector&amp;lt;int&amp;gt; list;void calc() { for0(i, n) for0(j, m) tmp[i][j] = mm[i][j]; int e_cnt = enemy_cnt, kill_cnt = 0; while(e_cnt) { kill.clear(); for0(k, 3) { memset(swap_arr, 0, sizeof(swap_arr)); int min_dis = INF, ii = 0, jj = 0; for0(i, n) for0(j, m) { if(tmp[i][j] == false) continue; if(abs(j - list[k]) + n - i == min_dis) { if(j &amp;lt; jj) ii = i, jj = j; } else if(abs(j - list[k]) + n - i &amp;lt; min_dis) { min_dis = abs(j - list[k]) + n - i; ii = i, jj = j; } } if(min_dis &amp;lt;= d) kill.insert({ ii, jj }); } kill_cnt += (int)kill.size(); for(auto p: kill) tmp[p.first][p.second] = false; for0(i, n-1) for0(j, m) swap_arr[i+1][j] = tmp[i][j]; e_cnt = 0; for0(i, n) for0(j, m) { tmp[i][j] = swap_arr[i][j]; if(tmp[i][j]) e_cnt++; } } ans = max(ans, kill_cnt);}void dfs(int startIdx) { if(list.size() == 3) { calc(); return; } for(int i = startIdx; i &amp;lt; m; i++) { list.push_back(i); dfs(i+1); list.pop_back(); }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; d; for0(i, n) for0(j, m) { int in; cin &amp;gt;&amp;gt; in; if(in) { enemy_cnt++; mm[i][j] = true; } } dfs(0); cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. Castle Difense (2473)", "url": "/posts/BOJ-2473/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Castle Difense, 세 용액", "date": "2022-03-04 22:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2473#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n;ll min_val = 3e9+1;int liq_arr[3];vector&amp;lt;int&amp;gt; liq;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; liq.resize(n); for0(i, n) cin &amp;gt;&amp;gt; liq[i]; sort(liq.begin(), liq.end()); ll ans = 1e10; for(int i = 0; i &amp;lt; n; i++) { int l = i + 1, r = n - 1; int target = - (l + r); while(l &amp;lt; r) { ll v = (ll)liq[i] + liq[l] + liq[r]; if(abs(v) &amp;lt; abs(min_val)) { min_val = v; liq_arr[0] = liq[i], liq_arr[1] = liq[l], liq_arr[2] = liq[r]; } if(v == 0) break; if(v &amp;gt; 0) r--; else l++; } } for(int e : liq_arr) cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; &quot; &quot; ; return 0;}" }, { "title": "BOJ. Puyo Puyo (11559)", "url": "/posts/BOJ-11559/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Puyo Puyo", "date": "2022-03-04 14:55:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11559#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int mm[12][6];bool visit[12][6];bool erase[12][6];int newmap[12][6];int di[4] = { -1, 0, 1, 0 };int dj[4] = { 0, 1, 0, -1 };vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; pop_list;queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q;bool no_pop = true;void bfs(int ci, int cj) { int cnt = 0; pop_list.clear(); q.push({ ci, cj}); int color = mm[ci][cj]; while(!q.empty()) { pair&amp;lt;int, int&amp;gt; p = q.front(); q.pop(); if(visit[p.first][p.second]) continue; visit[p.first][p.second] = true; cnt++; pop_list.push_back(p); for0(rp, 4) { int ai = p.first + di[rp], aj = p.second + dj[rp]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;= 12 || aj &amp;gt;= 6 || visit[ai][aj]) continue; if(mm[ai][aj] == color) q.push({ ai, aj }); } } if(cnt &amp;gt;= 4) { for(auto p : pop_list) erase[p.first][p.second] = true; no_pop = false; }}void solve() { int step = 0; while(true) { // cout &amp;lt;&amp;lt; &quot; -----------\\n&quot;; // for0(i, 12) { for0(j, 6) cout &amp;lt;&amp;lt; mm[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; } for0(i, 12) for0(j, 6) { visit[i][j] = erase[i][j] = false; } no_pop = true; for0(j, 6) { for(int i = 11; i &amp;gt;= 0; i--) { if(mm[i][j] == 0) break; if(visit[i][j]) continue; bfs(i, j); } } if(no_pop) break; step++; for0(i, 12) for0(j, 6) newmap[i][j] = 0; for0(j, 6) { int orig_idx = 11, new_idx = 11; while(orig_idx &amp;gt;= 0) { if(mm[orig_idx][j] == 0) break; if(erase[orig_idx][j]) { orig_idx--; continue; } newmap[new_idx--][j] = mm[orig_idx--][j]; } } memcpy(mm, newmap, sizeof(newmap)); } cout &amp;lt;&amp;lt; step;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); for0(i, 12) { for0(j, 6) { char in; cin &amp;gt;&amp;gt; in; if(in == &#39;.&#39;) continue; if(in == &#39;R&#39;) mm[i][j] = 1; if(in == &#39;G&#39;) mm[i][j] = 2; if(in == &#39;B&#39;) mm[i][j] = 3; if(in == &#39;P&#39;) mm[i][j] = 4; if(in == &#39;Y&#39;) mm[i][j] = 5; } } solve(); return 0;}" }, { "title": "BOJ. King Of Fishing (17143)", "url": "/posts/BOJ-17143/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, King Of Fishing, 낚시왕", "date": "2022-03-04 14:01:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17143#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int r, c, m;struct shark { int speed, dir, size, idx; int i, j; bool caught = false; shark(int i, int j, int speed, int dir, int size, int idx): i(i), j(j), speed(speed), dir(dir), size(size), idx(idx) {}};vector&amp;lt;shark&amp;gt; sharks;vector&amp;lt;int&amp;gt; idx_map;int mm[100][100];int tmp[100][100];bool cmp(shark l, shark r) { return l.size &amp;lt; r.size;}void solve() { int pos = -1, fish_sum= 0; for0(iter, c) { pos++; for0(i, r) { if(mm[i][pos]) { sharks[idx_map[mm[i][pos]]].caught= true; fish_sum += sharks[idx_map[mm[i][pos]]].size; mm[i][pos] = 0; break; } } for0(i, m) { if(sharks[i].caught) continue; if(sharks[i].dir == 1 || sharks[i].dir == 2) { int ai = sharks[i].i + (sharks[i].dir == 1 ? -1 : 1) * sharks[i].speed, aj = sharks[i].j; bool dir_change = false; while(true) { if(0 &amp;lt;= ai &amp;amp;&amp;amp; ai &amp;lt; r) break; if(ai &amp;lt; 0) ai *= -1; else ai = 2*(r-1) - ai; dir_change = !dir_change; } if(dir_change) sharks[i].dir = sharks[i].dir == 1 ? 2 : 1; if(tmp[ai][aj] &amp;amp;&amp;amp; idx_map[tmp[ai][aj]] &amp;lt; i) sharks[idx_map[tmp[ai][aj]]].caught = true; tmp[ai][aj] = sharks[i].idx; sharks[i].i = ai; } else if(sharks[i].dir == 3 || sharks[i].dir == 4) { int ai = sharks[i].i, aj = sharks[i].j + (sharks[i].dir == 3 ? 1 : -1) * sharks[i].speed; bool dir_change = false; while(true) { if(0 &amp;lt;= aj &amp;amp;&amp;amp; aj &amp;lt; c) break; if(aj &amp;lt; 0) aj *= -1; else aj = 2*(c-1) - aj; dir_change = !dir_change; } if(dir_change) sharks[i].dir = sharks[i].dir == 3 ? 4 : 3; if(tmp[ai][aj] &amp;amp;&amp;amp; idx_map[tmp[ai][aj]] &amp;lt; i) sharks[idx_map[tmp[ai][aj]]].caught = true; tmp[ai][aj] = sharks[i].idx; sharks[i].j = aj; } } for0(i, r) for0(j, c) { mm[i][j] = tmp[i][j], tmp[i][j] = 0; } } cout &amp;lt;&amp;lt; fish_sum;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c &amp;gt;&amp;gt; m; idx_map.resize(m + 1); for0(i, m) { int r, c, s, d, z; cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d &amp;gt;&amp;gt; z; r--, c--; sharks.push_back(shark(r, c, s, d, z, i+1)); mm[r][c] = i+1; } sort(sharks.begin(), sharks.end(), cmp); for0(i, m) { idx_map[sharks[i].idx] = i; } solve(); return 0;}" }, { "title": "BOJ. Synthesize Solutions (14921)", "url": "/posts/BOJ-14921/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Two Pointer, Synthesize Solutions, 용액 합성하기", "date": "2022-03-04 03:53:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14921#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n;vector&amp;lt;int&amp;gt; liq;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for0(i, n) { int in; cin &amp;gt;&amp;gt; in; liq.push_back(in); } int l = 0, r = n-1, min = INF; while(l &amp;lt; r) { int v = liq[l] + liq[r]; if(abs(v) &amp;lt; abs(min)) min = v; if(v == 0) break; if(v &amp;gt; 0) r--; else l++; } cout &amp;lt;&amp;lt; min; return 0;}" }, { "title": "BOJ. Convey News (1135)", "url": "/posts/BOJ-1135/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Tree, Convey News, 뉴스 전하기", "date": "2022-03-04 03:40:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1135#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;const int INF = 987654321;int n, m, min_time;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; child;int dfs(int idx) { if(child[idx].size() == 0) return 0; vector&amp;lt;int&amp;gt; vec; for(int child_idx: child[idx]) { vec.push_back(dfs(child_idx)); } int local_min = 0, t_local = 0; sort(vec.begin(), vec.end(), greater&amp;lt;int&amp;gt;()); for0(i, vec.size()) { local_min = max(local_min, i+1 + vec[i]); } return local_min;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; child.resize(n); int in; cin &amp;gt;&amp;gt; in; for1(i, n) { int in; cin &amp;gt;&amp;gt; in; child[in].push_back(i); } cout &amp;lt;&amp;lt; dfs(0); return 0;}" }, { "title": "BOJ. Make A Big Number (16496)", "url": "/posts/BOJ-16496/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Two Pointer, Make A Big Number, 큰 수 만들기", "date": "2022-03-04 03:23:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16496#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n, m, time;bool cmp(string s1, string s2) { return s1+s2 &amp;gt; s2+s1;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; vector&amp;lt;string&amp;gt; svec; svec.resize(n); for0(i, n) cin &amp;gt;&amp;gt; svec[i]; sort(svec.begin(), svec.end(), cmp); if(svec[0] == &quot;0&quot;) cout &amp;lt;&amp;lt; 0; else for(string s: svec) cout &amp;lt;&amp;lt; s; return 0;}" }, { "title": "BOJ. Cheese (2638)", "url": "/posts/BOJ-2638/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, BFS, Cheese, 치즈", "date": "2022-03-04 03:15:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2638#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n, m, time;bool mm[100][100];bool visit[100][100];int deg[100][100];int di[4] = { -1, 0, 1, 0 };int dj[4] = { 0, 1, 0, -1 };queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q;void bfs(int i, int j) { // q = {}; // clear; if(visit[i][j]) return; q.push({ i, j }); while(!q.empty()) { pair&amp;lt;int, int&amp;gt; p = q.front(); q.pop(); int ci = p.first, cj = p.second; if(visit[ci][cj]) continue; visit[ci][cj] = true; for0(k, 4) { int ai = ci + di[k], aj = cj + dj[k]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai&amp;gt;= n || aj &amp;gt;= m) continue; if(visit[ai][aj]) continue; if(mm[ai][aj]) { deg[ai][aj]++; continue; } q.push({ ai, aj }); } }}void solve() { while(true) { bool cheese = false; for0(i, n) for0(j, m) if(mm[i][j]) { cheese = true; break; } if(cheese == false) break; for0(i, n) for0(j, m) { visit[i][j] = false; deg[i][j] = 0; } for0(i, n) { bfs(i, 0); bfs(i, m-1); } for0(j, m) { bfs(0, j); bfs(n-1, j); } for0(i, n) for0(j, m) if(deg[i][j] &amp;gt;= 2) mm[i][j] = false; time++; }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for0(i, n) for0(j, m) cin &amp;gt;&amp;gt; mm[i][j]; solve(); cout &amp;lt;&amp;lt; time; return 0;}" }, { "title": "BOJ. Two-Dimenstion Array And Operation (17140)", "url": "/posts/BOJ-17140/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Two-Dimenstion Array And Operation, 이차원 배열과 연산", "date": "2022-03-04 02:43:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17140#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int r, c, k;int a[100][100];bool cmp(pair&amp;lt;int, int&amp;gt; p1, pair&amp;lt;int, int&amp;gt; p2) { if(p1.second == p2.second) return p1.first &amp;lt; p2.first; return p1.second &amp;lt; p2.second;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c &amp;gt;&amp;gt; k; r--, c--; for0(i, 3) for0(j, 3) cin &amp;gt;&amp;gt; a[i][j]; int time = 0, row = 3, col = 3; map&amp;lt;int, int&amp;gt; cntm; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; cvec; while(true) { if(a[r][c] == k) break; if(time == 100) { cout &amp;lt;&amp;lt; -1; return 0; } if(row &amp;gt;= col) { int max_col = 0; for0(i, row) { cntm.clear(); cvec.clear(); for0(j, col) { if(a[i][j]) cntm[a[i][j]]++; a[i][j] = 0; } cvec.resize(cntm.size()); copy(cntm.begin(), cntm.end(), cvec.begin()); sort(cvec.begin(), cvec.end(), cmp); int ub = min(50, (int)cvec.size()); max_col = max(max_col, ub&amp;lt;&amp;lt;1); for0(j, ub) { a[i][j&amp;lt;&amp;lt;1] = cvec[j].first; a[i][j&amp;lt;&amp;lt;1|1] = cvec[j].second; } } col = max(col, max_col); } else { int max_row = 0; for0(j, col) { cntm.clear(); cvec.clear(); for0(i, row) { if(a[i][j]) cntm[a[i][j]]++; a[i][j] = 0; } cvec.resize(cntm.size()); copy(cntm.begin(), cntm.end(), cvec.begin()); sort(cvec.begin(), cvec.end(), cmp); int ub = min(50, (int)cvec.size()); max_row = max(max_row, ub&amp;lt;&amp;lt;1); for0(i, ub) { a[i&amp;lt;&amp;lt;1][j] = cvec[i].first; a[i&amp;lt;&amp;lt;1|1][j] = cvec[i].second; } } row = max(row, max_row); } time++; } cout &amp;lt;&amp;lt; time; return 0;}" }, { "title": "BOJ. CCW (11758)", "url": "/posts/BOJ-11758/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Geometry, CCW", "date": "2022-03-04 01:29:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11758#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n, m, k;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; p(3); for0(i, 3) { cin &amp;gt;&amp;gt; p[i].first &amp;gt;&amp;gt; p[i].second; } int dx1 = p[0].first - p[1].first, dy1 = p[0].second - p[1].second; int dx2 = p[2].first - p[1].first, dy2 = p[2].second - p[1].second; int v = dy2 * dx1 - dy1 * dx2; if(v == 0) cout &amp;lt;&amp;lt; 0; else if(v &amp;gt; 0) cout &amp;lt;&amp;lt; -1; else cout &amp;lt;&amp;lt; 1; return 0;}" }, { "title": "BOJ. Tree Investment (16235)", "url": "/posts/BOJ-16235/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Tree Investment, 나무 재테크", "date": "2022-03-04 00:29:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16235#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n, m, k;int add[10][10];int farm[10][10];int update[10][10];int di[8] = { -1, -1, -1, 0, 0, 1, 1, 1};int dj[8] = { -1, 0, 1, -1, 1, -1, 0, 1};vector&amp;lt;vector&amp;lt;deque&amp;lt;int&amp;gt;&amp;gt;&amp;gt; tree;int solve() { for0(year, k) { for0(row, n) for0(col, n) update[row][col] = 0; //spring for0(i, n) { for0(j, n) { int tree_num = tree[i][j].size(); for0(p, tree_num) { if(farm[i][j] &amp;lt; tree[i][j][p]) { for0(dd, tree_num - p) { int dead_age = tree[i][j].back(); tree[i][j].pop_back(); update[i][j] += dead_age &amp;gt;&amp;gt; 1; } break; } farm[i][j] -= tree[i][j][p]; tree[i][j][p]++; } } } //summer for0(i, n) for0(j, n) farm[i][j] += update[i][j]; //autumn for0(i, n) for0(j, n) { for0(p, tree[i][j].size()) { if(tree[i][j][p] %5 == 0) { for0(p, 8) { int ai = i + di[p], aj = j + dj[p]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;= n || aj &amp;gt;= n) continue; tree[ai][aj].push_front(1); } } } } //winter for0(i, n) for0(j, n) farm[i][j] += add[i][j]; } int cnt = 0; for0(i, n) for0(j, n) cnt += tree[i][j].size(); return cnt;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k; for0(i, n) { for0(j, n) cin &amp;gt;&amp;gt; add[i][j]; } for0(i, n) for0(j, n) farm[i][j] = 5; tree.resize(n); for0(i, n) tree[i].resize(n); for0(i, m) { int x, y, z; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z; x--, y--; tree[x][y].push_back(z); } for0(i, n) for0(j, n) sort(tree[i][j].begin(), tree[i][j].end()); cout &amp;lt;&amp;lt; solve(); return 0;}" }, { "title": "BOJ. Four Numbers Of With Sum (7453)", "url": "/posts/BOJ-7453/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Two Pointer, Four Numbers Of With Sum, 합이 0인 네 정수", "date": "2022-03-03 23:39:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/7453#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n;vector&amp;lt;int&amp;gt; a, b, c, d;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; a.resize(n); b.resize(n); c.resize(n); d.resize(n); for0(i, n) cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i] &amp;gt;&amp;gt; c[i] &amp;gt;&amp;gt; d[i]; sort(a.begin(), a.end()); sort(b.begin(), b.end()); sort(c.begin(), c.end()); sort(d.begin(), d.end()); vector&amp;lt;int&amp;gt; ab, cd; for0(i, n) { for0(j, n) { ab.push_back(a[i] + b[j]); cd.push_back(c[i] + d[j]); } } sort(ab.begin(), ab.end()); sort(cd.begin(), cd.end()); int ab_idx = 0, cd_idx = cd.size() - 1; ll cnt = 0; while(ab_idx &amp;lt; ab.size() &amp;amp;&amp;amp; cd_idx &amp;gt;= 0) { int ab_val = ab[ab_idx], cd_val = cd[cd_idx]; int sum = ab_val + cd_val; if(sum == 0) { int abcnt = 1, cdcnt = 1; while(ab_idx + 1 &amp;lt; ab.size() &amp;amp;&amp;amp; ab[ab_idx + 1] == ab_val) { abcnt++; ab_idx++; } while(cd_idx - 1 &amp;gt;= 0 &amp;amp;&amp;amp; cd[cd_idx - 1] == cd_val) { cdcnt++; cd_idx--; } cnt+=(ll)abcnt * cdcnt; ab_idx++; cd_idx--; } else if(sum &amp;gt; 0) cd_idx--; else ab_idx++; } cout &amp;lt;&amp;lt; cnt; return 0;}" }, { "title": "BOJ. Lecture Room Assignment (11000)", "url": "/posts/BOJ-11000/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Lecture Room Assignment, 강의실 배정", "date": "2022-03-03 22:09:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11000#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n;bool cmp(pair&amp;lt;int, bool&amp;gt; pl, pair&amp;lt;int, bool&amp;gt; pr) { if(pl.first == pr.first) return pl.second == pr.second ? false : (!pl.second || pr.second); return pl.first &amp;lt; pr.first;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; vector&amp;lt;pair&amp;lt;int, bool&amp;gt;&amp;gt; schedule; for0(i, n) { int s, t; cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t; schedule.push_back({ s, true }); schedule.push_back({ t, false }); } sort(schedule.begin(), schedule.end(), cmp); int cnt = 0, max_val = 0; for(auto e: schedule) { if(e.second) cnt++; else cnt--; max_val = max(max_val , cnt); } cout &amp;lt;&amp;lt; max_val; return 0;}" }, { "title": "BOJ. N th Biggest Number (2075)", "url": "/posts/BOJ-2075/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, N th Biggest Number, N번째 큰 수", "date": "2022-03-03 21:01:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2075#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n;priority_queue&amp;lt;ll, vector&amp;lt;ll&amp;gt;, greater&amp;lt;ll&amp;gt;&amp;gt; big;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for0(j, n) { int in; cin &amp;gt;&amp;gt; in; big.push(in); } for1(i, n) for0(j, n){ int in; cin &amp;gt;&amp;gt; in; if(in &amp;lt;= big.top()) continue; big.pop(); big.push(in); } cout &amp;lt;&amp;lt; big.top(); return 0;}" }, { "title": "LeetCode. 1028. Recover a Tree From Preorder Traversal", "url": "/posts/Leetcode-1028.-Recover-a-Tree-From-Preorder-Traversal/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, C++, Algorithm, Coding Interview, LeetCode, Divide And Conquer, Recover a Tree From Preorder Traversal", "date": "2022-03-03 16:50:00 +0900", "snippet": "[Link] https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/#include &amp;lt;bits/stdc++.h&amp;gt;/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; nodes; TreeNode* div_con(int l, int r) { if(l == r) return new TreeNode(nodes[l].first); else if(l+1 == r) { TreeNode *child_node = new TreeNode(nodes[r].first); return new TreeNode(nodes[l].first, child_node, nullptr); } int top_depth = nodes[l].second; vector&amp;lt;int&amp;gt; next_nodes; for(int i = l+1; i &amp;lt;= r; i++) { if(nodes[i].second == top_depth + 1) next_nodes.push_back(i); } if(next_nodes.size() == 1) { return new TreeNode(nodes[l].first, div_con(next_nodes[0], r), nullptr); } else if(next_nodes.size() == 2) { return new TreeNode(nodes[l].first,div_con(next_nodes[0], next_nodes[1] - 1), div_con(next_nodes[1], r)); } return new TreeNode(nodes[l].first); } TreeNode* recoverFromPreorder(string s) { int i = 0, depth = 0, tot = 0; string str; while(i &amp;lt; s.size()) { depth = 0; str = &quot;&quot;; while(s[i]==&#39;-&#39;) { depth++; i++; } while(i &amp;lt; s.size() &amp;amp;&amp;amp; s[i]!=&#39;-&#39;) str+=s[i++]; int node_val = stoi(str); nodes.push_back({ node_val, depth }); TreeNode* node = new TreeNode(node_val); tot++; } return div_con(0, tot - 1); }};" }, { "title": "BOJ. Race (2517)", "url": "/posts/BOJ-2517/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, Race, 달리기", "date": "2022-03-03 12:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2517#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n;int seg[MAX &amp;lt;&amp;lt; 1];vector&amp;lt;int&amp;gt; abilities;void insert(int ability) { for(ability+=MAX; ability &amp;gt; 0; ability&amp;gt;&amp;gt;=1) seg[ability]++;}int query(int ability) { int rank = 0; for(int l = MAX, r = MAX + ability; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1) { if(l &amp;amp; 1) rank += seg[l++]; if(r &amp;amp; 1) rank += seg[--r]; } return rank;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; n; int cur_rank = 1; for0(i, n) { int ability; cin &amp;gt;&amp;gt; ability; abilities.push_back(ability); } vector&amp;lt;int&amp;gt; cp = abilities; sort(cp.begin(), cp.end(), greater&amp;lt;int&amp;gt;()); for0(i, n) { int rank = lower_bound(cp.begin(), cp.end(), abilities[i], greater&amp;lt;int&amp;gt;()) - cp.begin(); cout &amp;lt;&amp;lt; min(query(rank), i) + 1 &amp;lt;&amp;lt; endl; insert(rank); } return 0;}" }, { "title": "BOJ. Candy Box (2243)", "url": "/posts/BOJ-2243/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, Candy Box, 사탕상자", "date": "2022-03-03 03:39:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2243#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 1e6 + 1;const int log = 20;const NUM = 1e6;int n;int seg[1 &amp;lt;&amp;lt; log+1];void update(int v, int amount, int idx, int l, int r) { if(r &amp;lt; v || v &amp;lt; l) return; int mid = l+r&amp;gt;&amp;gt;1; seg[idx]+=amount; if(l == r) return; update(v, amount, idx&amp;lt;&amp;lt;1, l, mid); update(v, amount, idx&amp;lt;&amp;lt;1|1, mid + 1, r);}int pull(int rank) { int seg_idx = 1, l = 1, r = NUM; while(l != r) { int left_cnt = seg[seg_idx&amp;lt;&amp;lt;1]; if(left_cnt &amp;gt;= rank) { seg_idx&amp;lt;&amp;lt;=1; r = l+r&amp;gt;&amp;gt;1; } else { rank -= left_cnt; seg_idx = seg_idx&amp;lt;&amp;lt;1|1; int mid = l+r&amp;gt;&amp;gt;1; l = mid + 1; } } update(l, -1, 1, 1, NUM); return l;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; n; while(n--) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; if(a == 1) { cout &amp;lt;&amp;lt; pull(b) &amp;lt;&amp;lt; endl; } else { int c; cin &amp;gt;&amp;gt; c; update(b, c, 1, 1, NUM); } } return 0;}" }, { "title": "BOJ. Scale (2437)", "url": "/posts/BOJ-2437/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Scale, 저울", "date": "2022-03-03 02:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2437#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;int n, m, h;vector&amp;lt;set&amp;lt;int&amp;gt;&amp;gt; link;int ans;bool all_end = false;bool satisfy() { for0(i, n) { int pos = i; for0(height, h) { if(link[height].count(pos)) { pos++; } else if(pos &amp;gt; 0 &amp;amp;&amp;amp; link[height].count(pos-1)) { pos--; } } if(pos != i) { return false; } } return true;}void select(int cur_cnt, int max_cnt, int s_idx, int s_height) { if(cur_cnt == max_cnt) { if(satisfy()) { ans = max_cnt; all_end = true; } return; } for(int height = s_height; height &amp;lt; h; height++) { if(link[height].count(s_idx)) continue; if(s_idx-1 &amp;gt;= 0 &amp;amp;&amp;amp; link[height].count(s_idx-1)) continue; if(s_idx+1 &amp;lt; n-1 &amp;amp;&amp;amp; link[height].count(s_idx+1)) continue; link[height].insert(s_idx); if(height == h - 1) select(cur_cnt+1, max_cnt, s_idx+1, 0); else select(cur_cnt + 1, max_cnt, s_idx, height + 1); if(all_end) return; link[height].erase(s_idx); } for(int i = s_idx + 1; i &amp;lt; n-1; i++) { for(int height = 0; height &amp;lt; h; height++) { if(link[height].count(i)) continue; if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; link[height].count(i-1)) continue; if(i+1 &amp;lt; n-1 &amp;amp;&amp;amp; link[height].count(i+1)) continue; link[height].insert(i); if(height == h - 1) select(cur_cnt+1, max_cnt, i+1, 0); else select(cur_cnt + 1, max_cnt, i, height + 1); if(all_end) return; link[height].erase(i); } }}void solve() { for0(i, 4) { select(0, i, 0, 0); if(all_end) return; }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; h; link.resize(h); for0(i, m) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; a--, b--; link[a].insert(b); } solve(); cout &amp;lt;&amp;lt; (all_end ? ans : -1); return 0;}" }, { "title": "BOJ. Bind A Number (1744)", "url": "/posts/BOJ-1744/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Bind A Number, 수 묶기", "date": "2022-03-03 02:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1744#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define ll long long#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;const int MAX = 5e5 + 1;int n;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; n; vector&amp;lt;int&amp;gt; nvec; bool zero_exist = false; for0(i, n) { int in; cin &amp;gt;&amp;gt; in; if(in) nvec.push_back(in); else zero_exist = true; } sort(nvec.begin(), nvec.end()); int lb_zero = upper_bound(nvec.begin(), nvec.end(), 0) - nvec.begin(); int ub_one = upper_bound(nvec.begin() + lb_zero, nvec.end(), 1) - nvec.begin(); int lb_one = lower_bound(nvec.begin() + lb_zero, nvec.end(), 1) - nvec.begin(); int sum = 0, i = nvec.size() - 1; while(i-1 &amp;gt;= ub_one) { sum += nvec[i]*nvec[i-1]; i-=2; } if(i == ub_one) sum+=nvec[i]; sum+= ub_one - lb_one; i = 0; while(i+1&amp;lt;lb_zero) { sum+=nvec[i]*nvec[i+1]; i+=2; } if(i == lb_zero -1 &amp;amp;&amp;amp; !zero_exist) sum+=nvec[lb_zero-1]; cout &amp;lt;&amp;lt; sum; return 0;}" }, { "title": "BOJ. Manipulate Ladder (15684)", "url": "/posts/BOJ-15684/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, Manipulate Ladder, 사다리 조작", "date": "2022-03-03 02:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/15684Not to make mistakes–multiple ladder can be added in the same vertical line–dfs range!#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;int n, m, h;vector&amp;lt;set&amp;lt;int&amp;gt;&amp;gt; link;int ans;bool all_end = false;bool satisfy() { for0(i, n) { int pos = i; for0(height, h) { if(link[height].count(pos)) { pos++; } else if(pos &amp;gt; 0 &amp;amp;&amp;amp; link[height].count(pos-1)) { pos--; } } if(pos != i) { return false; } } return true;}void select(int cur_cnt, int max_cnt, int s_idx, int s_height) { if(cur_cnt == max_cnt) { if(satisfy()) { ans = max_cnt; all_end = true; } return; } for(int height = s_height; height &amp;lt; h; height++) { if(link[height].count(s_idx)) continue; if(s_idx-1 &amp;gt;= 0 &amp;amp;&amp;amp; link[height].count(s_idx-1)) continue; if(s_idx+1 &amp;lt; n-1 &amp;amp;&amp;amp; link[height].count(s_idx+1)) continue; link[height].insert(s_idx); if(height == h - 1) select(cur_cnt+1, max_cnt, s_idx+1, 0); else select(cur_cnt + 1, max_cnt, s_idx, height + 1); if(all_end) return; link[height].erase(s_idx); } for(int i = s_idx + 1; i &amp;lt; n-1; i++) { for(int height = 0; height &amp;lt; h; height++) { if(link[height].count(i)) continue; if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; link[height].count(i-1)) continue; if(i+1 &amp;lt; n-1 &amp;amp;&amp;amp; link[height].count(i+1)) continue; link[height].insert(i); if(height == h - 1) select(cur_cnt+1, max_cnt, i+1, 0); else select(cur_cnt + 1, max_cnt, i, height + 1); if(all_end) return; link[height].erase(i); } }}void solve() { for0(i, 4) { select(0, i, 0, 0); if(all_end) return; }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; h; link.resize(h); for0(i, m) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; a--, b--; link[a].insert(b); } solve(); cout &amp;lt;&amp;lt; (all_end ? ans : -1); return 0;}" }, { "title": "BOJ. Perfect Binary Tree (9934)", "url": "/posts/BOJ-9934/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, Perfect Binary Tree, 완전 이진 트리", "date": "2022-03-02 21:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/9934#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;int k;// vector&amp;lt;int&amp;gt; ans;vector&amp;lt;int&amp;gt; record;void conquer(vector&amp;lt;int&amp;gt; *ans, int left, int right, int idx) { if(left == right) { (*ans)[idx-1] = record[left - 1]; return; } int mid = (left + right) &amp;gt;&amp;gt; 1; (*ans)[idx-1] = record[mid - 1]; conquer(ans, left, mid - 1, 2*idx); conquer(ans, mid + 1, right, 2*idx+1);}void solve(vector&amp;lt;int&amp;gt; *ans) { ans-&amp;gt;resize((1 &amp;lt;&amp;lt; k) - 1); conquer(ans, 1, (1 &amp;lt;&amp;lt; k) - 1, 1);}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; k; int i = (1 &amp;lt;&amp;lt; k) - 1; while(i--) { int in; cin &amp;gt;&amp;gt; in; record.push_back(in); } i = 0; vector&amp;lt;int&amp;gt; ans; solve(&amp;amp;ans); int stair = 1; int idx = 0; for(int stair = 1; stair &amp;lt;= k; stair++) { for0(i, 1 &amp;lt;&amp;lt; (stair-1)) cout &amp;lt;&amp;lt; ans[idx++] &amp;lt;&amp;lt; dkdk; cout &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Boggle (9202)", "url": "/posts/BOJ-9202/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Trie, DFS, Boggle", "date": "2022-03-02 20:29:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/9202#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;#define nulls &#39;\\0&#39;#define dkdk &quot; &quot;struct trie{ trie *tries[26]; string orig_str; bool last = false; int len; trie() { memset(tries, 0, sizeof(tries)); } ~trie() { fori(0, 26) delete tries[i]; } void insert(string str, int idx) { if(str.size() == idx) { this-&amp;gt;last = true; this-&amp;gt;len = str.size(); this-&amp;gt;orig_str = str; return; } int char_code = str[idx] - &#39;A&#39;; if(this-&amp;gt;tries[char_code] == NULL) this-&amp;gt;tries[char_code] = new trie(); this-&amp;gt;tries[char_code]-&amp;gt;insert(str, idx + 1); } bool search(char* cptr) { trie* t = this; while(*cptr != nulls) { if(t -&amp;gt; tries[*cptr-&#39;A&#39;] == NULL) return false; t = t -&amp;gt; tries[*cptr-&#39;A&#39;]; cptr++; } return t-&amp;gt;last; }};typedef long long ll;const int INF = 987654321;const int MAX = 123456;const int log = 17;int n, w, b, score;char board[4][4];bool visit[4][4];int di[8] = { -1, 0, 1, 0, 1, -1, 1, -1 };int dj[8] = { 0, 1, 0, -1, 1, -1, -1, 1 };map&amp;lt;string, bool&amp;gt; counted;string longest_word;int cnt = 0;trie t;int to_score(int len) { if(len &amp;lt; 3) return 0; if(len &amp;lt; 5) return 1; if(len &amp;lt; 6) return 2; if(len &amp;lt; 7) return 3; if(len &amp;lt; 8) return 5; return 11;}void dfs(int ci, int cj, trie *ct) { if(ct -&amp;gt; tries[board[ci][cj]-&#39;A&#39;] == NULL) return; ct = ct -&amp;gt; tries[board[ci][cj] - &#39;A&#39;]; if(ct -&amp;gt; last &amp;amp;&amp;amp; !counted[ct-&amp;gt;orig_str]) { counted[ct-&amp;gt;orig_str] = true; if(longest_word.size() &amp;lt; ct-&amp;gt;orig_str.size()) longest_word = ct-&amp;gt;orig_str; else if(longest_word.size() == ct-&amp;gt;orig_str.size()) { if(longest_word &amp;gt; ct -&amp;gt; orig_str) longest_word = ct-&amp;gt;orig_str; } cnt++; score += to_score(ct -&amp;gt; len); } for0(i, 8) { int ai = ci + di[i], aj = cj + dj[i]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;=4 || aj &amp;gt;=4) continue; if(visit[ai][aj]) continue; visit[ai][aj] = true; dfs(ai, aj, ct); visit[ai][aj] = false; }}void solve() { for0(i, 4) { for0(j, 4) { visit[i][j] = true; dfs(i, j, &amp;amp;t); visit[i][j] = false; } }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); cin &amp;gt;&amp;gt; w; for0(i, w) { string word; cin &amp;gt;&amp;gt; word; t.insert(word, 0); counted.insert({ word, false }); } cin &amp;gt;&amp;gt; b; for0(i, b) { for0(j, 4) for0(k, 4) cin &amp;gt;&amp;gt; board[j][k]; for(auto iter = counted.begin(); iter!=counted.end(); iter++) iter-&amp;gt;second = false; score = cnt = 0; longest_word = &quot;&quot;; solve(); cout &amp;lt;&amp;lt; score &amp;lt;&amp;lt; dkdk &amp;lt;&amp;lt; longest_word &amp;lt;&amp;lt; dkdk &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Save The Sheep (16437)", "url": "/posts/BOJ-16437/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Topological Sort, Save The Sheep, 양 구출 작전", "date": "2022-03-02 00:41:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16437#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 123456;const int log = 17;int n;ll sheep[MAX];int deg[MAX];vector&amp;lt;int&amp;gt; bridge;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; bridge.resize(n); for0(i, n-1) { char t; int a, p; cin &amp;gt;&amp;gt; t &amp;gt;&amp;gt; a &amp;gt;&amp;gt; p; p--; deg[p]++; sheep[i+1] = t == &#39;S&#39; ? a : -a; bridge[i+1] = p; } queue&amp;lt;int&amp;gt; q; for0(i, n) if(deg[i] == 0) q.push(i); while(!q.empty()) { int cur = q.front(); q.pop(); if(cur == 0) continue; int next = bridge[cur]; if(sheep[cur] &amp;gt; 0) sheep[next] += sheep[cur]; if(--deg[next] == 0) q.push(next); } cout &amp;lt;&amp;lt; sheep[0]; return 0;}" }, { "title": "BOJ. Distance Between Vertices (1761)", "url": "/posts/BOJ-1761/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, LCA, Lowest Common Ancestor, Distance Between Vertices, 정점들의 거리", "date": "2022-03-01 21:10:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1761#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 4e4 + 1;const int log = 17;int n, m;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; edges;int dis[MAX][log];int parent[MAX][log];int depth[MAX];void get_root_dfs(int idx) { for(pair&amp;lt;int,int&amp;gt; p: edges[idx]) { if(parent[idx][0] == p.first) continue; parent[p.first][0] = idx; depth[p.first] = depth[idx] + 1; dis[p.first][0] = p.second; get_root_dfs(p.first); }}void calc_sparse() { for1(i, log) { for1(j, n + 1) { parent[j][i] = parent[parent[j][i - 1]][i - 1]; dis[j][i] = dis[j][i-1] + dis[parent[j][i-1]][i-1]; } }}int get_lca(int a, int b) { if(depth[a] &amp;lt; depth[b]) swap(a, b); for(int i = log - 1; i &amp;gt;= 0; i--) { if(depth[a] - depth[b] &amp;gt;= 1 &amp;lt;&amp;lt; i) { a = parent[a][i]; } } if(a == b) return a; for(int i = log - 1; i &amp;gt;= 0; i--) { if(parent[a][i] != parent[b][i]) { a = parent[a][i]; b = parent[b][i]; } } return parent[a][0];}int get_dis(int child, int anc) { int distance = 0; for(int i = log - 1; i &amp;gt;= 0; i--) { if(depth[child] - depth[anc] &amp;gt;= 1 &amp;lt;&amp;lt; i) { distance += dis[child][i]; child = parent[child][i]; } } return distance;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; edges.resize(n + 1); for0(i, n-1) { int a, b, dis; cin&amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; dis; edges[a].push_back(make_pair(b, dis)); edges[b].push_back(make_pair(a, dis)); } get_root_dfs(1); calc_sparse(); cin &amp;gt;&amp;gt; m; for0(i, m) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; int lca = get_lca(a, b); cout &amp;lt;&amp;lt; get_dis(a, lca) + get_dis(b, lca) &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Cheese (2636)", "url": "/posts/BOJ-2636/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, BFS, Implementation, Cheese, 치즈", "date": "2022-03-01 18:29:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2636#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, m;bool air[100][100];bool cheese[100][100];bool visit[100][100];bool update[100][100];int di[4] = { -1, 0, 1, 0 };int dj[4] = { 0, 1, 0, -1 };void solve() { queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; int left_cheese = 0, time = 0; for0(i, n) for0(j, m) if(cheese[i][j]) left_cheese++; if(!left_cheese) { cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; 0; return; } while(true) { time++; for0(i, n) for0(j, m) visit[i][j] = update[i][j] = false; q.push(make_pair(0, 0)); while(!q.empty()) { pair&amp;lt;int, int&amp;gt; p = q.front(); q.pop(); if(visit[p.first][p.second]) continue; visit[p.first][p.second] = true; for0(i, 4) { int ai = p.first + di[i], aj = p.second + dj[i]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;= n || aj &amp;gt;= m) continue; if(visit[ai][aj]) continue; if(cheese[ai][aj]) { update[ai][aj] = true; visit[ai][aj] = true; continue; } q.push(make_pair(ai, aj)); } } int cheese_cnt = 0; for0(i, n) for0(j, m) { if(update[i][j]) { cheese[i][j] = false; } else if(cheese[i][j]) cheese_cnt++; } if(cheese_cnt) left_cheese = cheese_cnt; else break; } cout &amp;lt;&amp;lt; time &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; left_cheese;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for0(i, n) for0(j, m) { int in; cin &amp;gt;&amp;gt; in; if(!in) continue; cheese[i][j] = true; } solve();}" }, { "title": "BOJ. Is This Tree? (6416)", "url": "/posts/BOJ-6416/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, Is This Tree, 트리인가", "date": "2022-03-01 14:44:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/6416#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 123456;const int log = 17;int n;map&amp;lt;int, int&amp;gt; deg;map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; edges;set&amp;lt;int&amp;gt; v;bool bfs(int root) { queue&amp;lt;int&amp;gt; q; q.push(root); set&amp;lt;int&amp;gt; visit_set; bool is_tree = true; int v_cnt = 0; while(!q.empty()) { int cur = q.front(); q.pop(); if(visit_set.count(cur)) { is_tree = false; break; } visit_set.insert(cur); v_cnt++; for(int child: edges[cur]) q.push(child); } return is_tree ? v_cnt == v.size() : false;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); bool end = false; int case_idx = 1; while(true) { deg.clear(); edges.clear(); v.clear(); while(true) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; if(!a &amp;amp;&amp;amp; !b) break; if(a == -1 &amp;amp;&amp;amp; b == -1) { end = true; break; } v.insert(a); v.insert(b); edges[a].push_back(b); deg[b]++; } if(end) break; if(!v.size()) { cout &amp;lt;&amp;lt; &quot;Case &quot; &amp;lt;&amp;lt; case_idx++ &amp;lt;&amp;lt; &quot; is a tree.&quot; &amp;lt;&amp;lt; endl; continue; } int zero_deg_cnt = 0, root = 0; for(int vertex: v) if(deg[vertex] == 0) { zero_deg_cnt++; root = vertex; } if(zero_deg_cnt != 1) cout &amp;lt;&amp;lt; &quot;Case &quot; &amp;lt;&amp;lt; case_idx++ &amp;lt;&amp;lt; &quot; is not a tree.&quot; &amp;lt;&amp;lt; endl; else { if(bfs(root)) cout &amp;lt;&amp;lt; &quot;Case &quot; &amp;lt;&amp;lt; case_idx++ &amp;lt;&amp;lt; &quot; is a tree.&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;Case &quot; &amp;lt;&amp;lt; case_idx++ &amp;lt;&amp;lt; &quot; is not a tree.&quot; &amp;lt;&amp;lt; endl; } } return 0;}" }, { "title": "BOJ. Factory (7578)", "url": "/posts/BOJ-7578/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, Non-Recursive Segement Tree, Factory, 공장", "date": "2022-03-01 14:22:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/7578#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;const int N = 5e5;int n;vector&amp;lt;int&amp;gt; seg(2*N);vector&amp;lt;int&amp;gt; idx_vec;void insert(int val) { int idx = N + val; seg[idx]++; while(idx &amp;gt; 1) { idx &amp;gt;&amp;gt;= 1; seg[idx] = seg[idx &amp;lt;&amp;lt; 1] + seg[idx &amp;lt;&amp;lt; 1 | 1]; }}int get(int val) { int ans = 0; for(int l = N + val, r = 2 * N; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1) { if(l &amp;amp; 1) ans+=seg[l++]; if(r &amp;amp; 1) ans+=seg[--r]; } return ans;}void solve() { ll ans = 0; for(int e: idx_vec) { ans += get(e); insert(e); } cout &amp;lt;&amp;lt; ans;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; idx_vec.resize(n); map&amp;lt;int, int&amp;gt; number_idx; for0(i, n) { int in; cin &amp;gt;&amp;gt; in; number_idx[in] = i; } for0(i, n) { int in; cin &amp;gt;&amp;gt; in; idx_vec[number_idx[in]] = i; } solve();}" }, { "title": "BOJ. Dragon Curve (15685)", "url": "/posts/BOJ-15685/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Dragon Curve, 드래곤 커브", "date": "2022-03-01 14:22:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/15685#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, m, ans = 0;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sub;vector&amp;lt;int&amp;gt; sum;bool mm[101][101];int cx, cy;int dx[4] = { 1, 0, -1, 0 };int dy[4] = { 0, -1, 0, 1 };vector&amp;lt;int&amp;gt; directions;void draw(int generation) { fori(i, generation) { int start_idx = directions.size(); for(int i = start_idx - 1; i &amp;gt;= 0; i--) { int dir = directions[i]; if(++dir == 4) dir = 0; cx += dx[dir], cy += dy[dir]; if(0 &amp;lt;= cx &amp;amp;&amp;amp; 0 &amp;lt;= cy &amp;amp;&amp;amp; cx &amp;lt;= 100 &amp;amp;&amp;amp; cy &amp;lt;= 100) mm[cx][cy] = true; directions.push_back(dir); } }}int count() { int ans = 0; for0(i, 100) { for0(j, 100) { if(mm[i][j] &amp;amp;&amp;amp; mm[i+1][j] &amp;amp;&amp;amp; mm[i][j+1] &amp;amp;&amp;amp; mm[i+1][j+1]) ans++; } } return ans;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for0(i, n) { int d, g; cin &amp;gt;&amp;gt; cx &amp;gt;&amp;gt; cy &amp;gt;&amp;gt; d &amp;gt;&amp;gt; g; directions.clear(); mm[cx][cy] = true; cx += dx[d], cy += dy[d]; mm[cx][cy] = true; directions.push_back(d); draw(g); } cout &amp;lt;&amp;lt; count() &amp;lt;&amp;lt; endl;}" }, { "title": "BOJ. Company Culture 1 (14267)", "url": "/posts/BOJ-14267/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Company Culture 1, Tree, 회사 문화 1", "date": "2022-03-01 12:48:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14267#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, m, ans = 0;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sub;vector&amp;lt;int&amp;gt; sum;void propagate(int idx, int inc) { sum[idx] += inc; for(int sub_idx : sub[idx]) { propagate(sub_idx, sum[idx]); }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; sub.resize(n); sum.resize(n); fill(sum.begin(), sum.end(), 0); for0(i, n) { int super; cin &amp;gt;&amp;gt; super; if(super == -1) continue; super--; sub[super].push_back(i); } for0(i, m) { int emp, compli; cin &amp;gt;&amp;gt; emp &amp;gt;&amp;gt; compli; sum[--emp] += compli; } propagate(0, 0); for(int v : sum) cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &quot; &quot;; return 0;}" }, { "title": "BOJ. Binary Tree (13325)", "url": "/posts/BOJ-13325/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Binary Tree, 이진 트리", "date": "2022-03-01 10:20:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/13325#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, m, ans = 0;vector&amp;lt;int&amp;gt; edges;int dfs(int idx) { if(idx &amp;lt;&amp;lt; 1 &amp;gt;= (1 &amp;lt;&amp;lt; n+1)) return 0; int dfs_left = dfs(idx &amp;lt;&amp;lt; 1), dfs_right = dfs(idx &amp;lt;&amp;lt; 1 | 1); int max_val = max(dfs_left + edges[idx &amp;lt;&amp;lt; 1], dfs_right + edges[idx &amp;lt;&amp;lt; 1 | 1]); edges[idx &amp;lt;&amp;lt; 1] += max_val - (dfs_left + edges[idx &amp;lt;&amp;lt; 1]); edges[idx &amp;lt;&amp;lt; 1 | 1] += max_val - (dfs_right + edges[idx &amp;lt;&amp;lt; 1 | 1]); return max_val;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; edges.push_back(0); edges.push_back(0); for0(i, (1 &amp;lt;&amp;lt; n+1) - 2) { int in; cin &amp;gt;&amp;gt; in; edges.push_back(in); } dfs(1); long sum = 0l; for0(i, 1 &amp;lt;&amp;lt; n+1) sum+=edges[i]; cout &amp;lt;&amp;lt; sum; return 0;}" }, { "title": "BOJ. Tree (4256)", "url": "/posts/BOJ-4256/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, 트리", "date": "2022-03-01 03:20:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/4256#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;struct Node { int left = -1; int right = -1;};int n;vector&amp;lt;int&amp;gt; pre;vector&amp;lt;int&amp;gt; mid;vector&amp;lt;int&amp;gt; mid_idx_vec;vector&amp;lt;Node&amp;gt; nodes;int idx = 0;int patch(int mid_left, int mid_right) { if(mid_left &amp;gt; mid_right) return -1; int node_val = pre[idx++]; int mid_idx = mid_idx_vec[node_val]; nodes[node_val].left = patch(mid_left, mid_idx - 1); nodes[node_val].right = patch(mid_idx + 1, mid_right); return node_val;}void post_order(int idx) { if(nodes[idx].left != -1) post_order(nodes[idx].left); if(nodes[idx].right != -1) post_order(nodes[idx].right); cout &amp;lt;&amp;lt; idx &amp;lt;&amp;lt; &quot; &quot;;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin &amp;gt;&amp;gt; t; while(t--) { int n; cin &amp;gt;&amp;gt; n; pre.clear(); mid.clear(); mid_idx_vec.resize(n+1); nodes.clear(); idx = 0; for0(i, n) { int in; cin &amp;gt;&amp;gt; in; pre.push_back(in); } for0(i, n) { int in; cin &amp;gt;&amp;gt; in; mid.push_back(in); mid_idx_vec[in] = i; } for(int i = 0; i &amp;lt;= n; i++) nodes.push_back(Node()); patch(0, n - 1); post_order(pre[0]); cout &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Height And Width Of Tree (2250)", "url": "/posts/BOJ-2250/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, Height And Width Of Tree, 트리의 높이와 너비", "date": "2022-03-01 02:30:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2250#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, mmax = 1, space_from_left = 0, max_depth;int depth = 0, width = 0;class Node { public: int idx; int depth = 0; int space_from_left = 0; Node* left; Node* right; Node(int _idx): idx(_idx), left(NULL), right(NULL) {} Node() {}};vector&amp;lt;Node&amp;gt; nodes;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; min_max;void set_depth_dfs(Node *node, int depth) { node-&amp;gt;depth = depth; max_depth = max(max_depth, depth); if(node -&amp;gt; left != NULL) set_depth_dfs(node-&amp;gt;left, depth + 1); node -&amp;gt; space_from_left = space_from_left++; min_max[depth].first = min(min_max[depth].first, space_from_left); min_max[depth].second = max(min_max[depth].second, space_from_left); if(node -&amp;gt; right != NULL) set_depth_dfs(node-&amp;gt;right, depth+1);}void get_max_bfs(Node *node) { for0(i, max_depth + 1) { if(width == abs(min_max[i].first - min_max[i].second)) { depth = min(depth, i); } else if(width &amp;lt; abs(min_max[i].first - min_max[i].second)) { depth = i; width = abs(min_max[i].first - min_max[i].second); } }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for0(i, n) { nodes.push_back(Node(i)); min_max.push_back(make_pair(INF, -INF)); } vector&amp;lt;bool&amp;gt; is_root(n, true); for0(i, n) { int node, a, b; cin &amp;gt;&amp;gt; node &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; if(a != -1) { nodes[node - 1].left = &amp;amp;nodes[a - 1]; is_root[a - 1] = false; } if(b != -1) { nodes[node - 1].right = &amp;amp;nodes[b - 1]; is_root[b - 1] = false; } } int root = 0; for0(i, n) if(is_root[i]) root = i; set_depth_dfs(&amp;amp;nodes[root], 0); get_max_bfs(&amp;amp;nodes[root]); cout &amp;lt;&amp;lt; depth + 1 &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; width + 1; return 0;}" }, { "title": "BOJ. Distance Between Nodes (1240)", "url": "/posts/BOJ-1240/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Distance Between Nodes, 노드사이의 거리", "date": "2022-03-01 01:20:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1240#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)#define endl &quot;\\n&quot;typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, m, ans = 0;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; edges;vector&amp;lt;int&amp;gt; parent;void dfs(int cur, int des, int dis) { if(cur == des) { ans = dis; return; } for(pair&amp;lt;int, int&amp;gt; p : edges[cur]) { if(parent[cur] == p.first) continue; parent[p.first] = cur; dfs(p.first, des, dis + p.second); }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for0(i, n) edges.push_back(vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;(0, make_pair(0, 0))); parent.resize(n); fill(parent.begin(), parent.end(), -1); for0(i, n-1) { int a, b, dis; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; dis; a--, b--; edges[a].push_back(make_pair(b, dis)); edges[b].push_back(make_pair(a, dis)); } for0(i, m) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; a--, b--; ans = 0; fill(parent.begin(), parent.end(), -1); dfs(a, b, 0); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Slope (14890)", "url": "/posts/BOJ-14890/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, Slope, 경사로", "date": "2022-02-28 22:20:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14890#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt; n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;const int MAX = 100;int n, l, ans;int mm[MAX][MAX];int mm_rev[MAX][MAX];void init_rev_mm() { for0(i, n) { for0(j, n) { mm_rev[i][j] = mm[j][i]; } }}void count(int mm[MAX][MAX]) { for0(i, n) { int tmp = mm[i][0]; int cnt = 1; bool decreased = false; bool can = true; for1(j, n) { if(mm[i][j] == tmp) { cnt++; continue; } if(abs(mm[i][j] - tmp) &amp;gt; 1) { can = false; break; } else if(mm[i][j] &amp;gt; tmp) { if(decreased) { if(cnt &amp;lt; l &amp;lt;&amp;lt; 1) { can = false; break; } } else { if(cnt &amp;lt; l) { can = false; break; } } cnt = 1; decreased = false; tmp = mm[i][j]; } else { if(decreased) { if(cnt &amp;lt; l) { can = false; break; } } cnt = 1; decreased = true; tmp = mm[i][j]; } } if(decreased) if(cnt &amp;lt; l) can = false; if(can) ans++; }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l; for0(i, n) { for0(j, n) cin &amp;gt;&amp;gt; mm[i][j]; } init_rev_mm(); count(mm); count(mm_rev); cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. LCA (11437)", "url": "/posts/BOJ-11437/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Tree, Lowest Common Ancestor, LCA", "date": "2022-02-28 20:29:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11437#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;queue&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;class Node { public: vector&amp;lt;int&amp;gt; child;};int n, k;vector&amp;lt;Node&amp;gt; nodes(50001);int parent[50001][17];int depth[50001];void dfs(int idx) { for(int child: nodes[idx].child) { if(child == parent[idx][0]) continue; depth[child] = depth[idx] + 1; parent[child][0] = idx; dfs(child); }}void calc_sparse() { for1(j, 16) { for1(i, n) { parent[i][j] = parent[parent[i][j-1]][j-1]; } }}int lca(int a, int b) { if(depth[a] &amp;lt; depth[b]) swap(a, b); for(int i = 16; i &amp;gt;= 0; i--) { if(depth[a] - depth[b] &amp;gt;= 1&amp;lt;&amp;lt;i) a = parent[a][i]; } if(a == b) return a; for(int i = 16; i &amp;gt;= 0; i--) { if(parent[a][i] != parent[b][i]) { a = parent[a][i]; b = parent[b][i]; } } return parent[a][0];}int main() { ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for0(i, n-1) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; nodes[b].child.push_back(a); nodes[a].child.push_back(b); } dfs(1); calc_sparse(); int m; cin &amp;gt;&amp;gt; m; for0(i, m) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; cout &amp;lt;&amp;lt; lca(a, b) &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "BOJ. Phone Number List (5052)", "url": "/posts/BOJ-5052/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, Phone Number List, 전화번호 목록", "date": "2022-02-28 17:43:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/5052#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;int n;// vector&amp;lt;long&amp;gt; a;vector&amp;lt;string&amp;gt; numbers;set&amp;lt;string&amp;gt; number_set;int main() { ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0); int t; cin &amp;gt;&amp;gt; t; while(t--) { int n; cin &amp;gt;&amp;gt; n; numbers.clear(); for0(i, n) { string in; cin &amp;gt;&amp;gt; in; numbers.push_back(in); } sort(numbers.begin(), numbers.end()); bool match_exist = false; for0(i, n - 1) { bool match = true; for0(j, min(numbers[i + 1].size(), numbers[i].size())) { if(numbers[i][j] != numbers[i+1][j]) { match = false; break; } } if(match) { match_exist = true; break; } if(match_exist) break; } cout &amp;lt;&amp;lt; (match_exist ? &quot;NO&quot;:&quot;YES&quot;) &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "Memo. To prove", "url": "/posts/Memo-To-prove/", "categories": "Record, Code", "tags": "Prove, Todo", "date": "2022-02-26 18:48:00 +0900", "snippet": "증명해야할것들백준 시계 kmp 알고리즘 문자열 제곱 의 증명트리에서 지름 = 임의의 정점에서 제일 먼 정점 &amp;amp; 그 정점에서 제일 먼 정점kmp, 매니커 알고리즘 증명 =&amp;gt; pi(i) = p일때 s.length - p길이가 반복된다. 또한 pi(i)*2 &amp;gt; length일경우:a s b라고하면(s공통부분) a == s== b이거나 a는 같은 문자가 반복된다 증명z알고리즘 증명구간 쿼리의 재귀식 코드의 증명크루스칼, 다익스트라 증명벨만포드, 플로이드 워셜=&amp;gt; 시간복잡도도 유도이분매칭, 에드몬드 증명manber myers algorithm공부해야할것들네트워크 플로우, 접미사 배열, Z알고리즘(문자열), 아호 코라식,Mo’s algorithm, persistant seg tree, 이분 매칭 알고리즘, MCMF(최대 유량),고속 푸리에 변환증명 or 해설: 스위치 배열, 최대 거리, 떨어지는 개미, 홀수와 짝수의 대결?… , a+b, 직사각형,정사각형 만들기, 이분매칭 증명 3038번완전 이진 트리 애드훅 문제들…리스트:bfs, dfs브루트포스,백트래킹,그리디,스택, 큐, 힙, 우큐,분할 정복,이분 탐색,동적 프로그래밍,manber myers algorithm투포인터,역추적,트리,그래프,유니온 파인드,MST,(벨만 포드, 다익, 플로이드 워셜, 크루스칼, 프림),네트워크 플로우(이분매칭, 에드몬드 증명)비트마스크,KMP알고리즘,트라이구조,Strongly connected component,segment tree,convex hall,biparate matching,network flow,mcmf(max flux),math(number theory, mod),FFT,Manecher,Z, surfix arr, aho-korazik,lazy propagation,mo’s algorithm,persistant segent tree,schedulling,lowest common ancestor,sparse table,topological sort,sweeping algorithm," }, { "title": "BOJ. Goody Bye Find Dust! (17144)", "url": "/posts/BOJ-17144/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Implementation, 로봇 조종하기, Goody Bye Find Dust!", "date": "2022-02-26 13:41:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17144#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;int r, c, t;int airi, airj;int mm[50][50];int update[50][50];int didown[4] = { 0, 1, 0, -1 };int djdown[4] = { 1, 0, -1, 0 };int diup[4] = { 0, -1, 0, 1 };int djup[4] = { 1, 0, -1, 0 };vector&amp;lt;string&amp;gt; str_vec;#define out_of_range ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;= r || aj &amp;gt;= cvoid solve() { for0(iter, t) { for0(i, r) for0(j, c) update[i][j] = 0; for0(i, r) { for0(j, c) { if(!mm[i][j] || mm[i][j] == -1) continue; int adj_cnt = 0; for0(k, 4) { int ai = i + diup[k], aj = j + djup[k]; if(out_of_range || mm[ai][aj] == -1) continue; adj_cnt++; update[ai][aj] += mm[i][j] / 5; } update[i][j] -= mm[i][j] / 5 * adj_cnt; } } for0(i, r) { for0(j, c) { mm[i][j] += update[i][j]; } } int cairi = airi - 1 , cairj = airj + 1; int prev = mm[cairi][cairj]; mm[cairi][cairj] = 0; for0(dir, 4) { while(true) { int ai = cairi + diup[dir], aj = cairj + djup[dir]; if(out_of_range || (ai == airi - 1&amp;amp;&amp;amp; aj == airj)) break; int swap = mm[ai][aj]; mm[ai][aj] = prev; prev = swap; cairi = ai, cairj = aj; } } cairi = airi, cairj = airj + 1; prev = mm[cairi][cairj]; mm[cairi][cairj] = 0; for0(dir, 4) { while(true) { int ai = cairi + didown[dir], aj = cairj + djdown[dir]; if(out_of_range || (ai == airi&amp;amp;&amp;amp; aj == airj)) break; int swap = mm[ai][aj]; mm[ai][aj] = prev; prev = swap; cairi = ai, cairj = aj; } } }}int main() { ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c &amp;gt;&amp;gt; t; for0(i, r) { for0(j, c) { cin &amp;gt;&amp;gt; mm[i][j]; if(mm[i][j] == -1) airi = i, airj = j; } } solve(); int sum = 0; for0(i, r) { for0(j, c) { if(mm[i][j] &amp;amp;&amp;amp; mm[i][j] != -1) sum += mm[i][j]; } } cout &amp;lt;&amp;lt; sum; return 0;}" }, { "title": "BOJ. Word Math (1339)", "url": "/posts/BOJ-1339/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Sort, 단어 수학, Word Math", "date": "2022-02-26 03:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1339#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;int n;vector&amp;lt;string&amp;gt; str_vec;bool cmp(pair&amp;lt;char, int&amp;gt; l, pair&amp;lt;char, int&amp;gt; r) { return l.second &amp;gt; r.second;}void solve() { map&amp;lt;char, int&amp;gt; val; for(string str: str_vec) { int ten = 1; for(int i = str.size() - 1; i &amp;gt;= 0; i--) { val[str[i]] += ten; ten *= 10; } } vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt; vec(val.begin(), val.end()); sort(vec.begin(), vec.end(), cmp); int sum = 0; int num = 9; for(pair&amp;lt;char, int&amp;gt; ploop: vec) sum += ploop.second * num--; cout &amp;lt;&amp;lt; sum;}int main() { ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for0(i, n) { string s; cin &amp;gt;&amp;gt; s; str_vec.push_back(s); } solve(); return 0;}" }, { "title": "BOJ. Control Robot (2169)", "url": "/posts/BOJ-2169/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DP, 로봇 조종하기, Control Robot", "date": "2022-02-26 02:41:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2169Point:Have to initialize left_dp[0] to -INF#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;int n, m, ans = INF;int mm[1000][1000];int left_dp[1000][1000];int right_dp[1000][1000];void solve() { right_dp[0][0] = mm[0][0]; left_dp[0][0] = -INF; for1(i, m) { right_dp[0][i] = right_dp[0][i-1] + mm[0][i]; left_dp[0][i] = -INF; } for1(i, n) { right_dp[i][0] = max(left_dp[i-1][0], right_dp[i-1][0]) + mm[i][0]; for1(j, m) { right_dp[i][j] = max({ left_dp[i-1][j], right_dp[i-1][j], right_dp[i][j-1] }) + mm[i][j]; } left_dp[i][m-1] = max(left_dp[i-1][m-1], right_dp[i-1][m-1]) + mm[i][m-1]; for(int j = m - 2; j &amp;gt;= 0; j--) { left_dp[i][j] = max({ left_dp[i-1][j], right_dp[i-1][j], left_dp[i][j+1] }) + mm[i][j]; } }}int main() { ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for0(i, n) { for0(j, m) { cin &amp;gt;&amp;gt; mm[i][j]; } } solve(); cout &amp;lt;&amp;lt; max(left_dp[n-1][m-1], right_dp[n-1][m-1]); return 0;}" }, { "title": "BOJ. Inspect (15683)", "url": "/posts/BOJ-15683/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, Implementation, 감시, Inspect", "date": "2022-02-25 21:07:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/15683#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;int n, m, ans = INF;int mm[8][8];int di[4] = { -1, 0, 1, 0 };int dj[4] = { 0, 1, 0, -1 };bool inspect[8][8];vector&amp;lt;int&amp;gt; cctv_vec;vector&amp;lt;int&amp;gt; rot_vec;// Long initialization code because of the auto-build parse errorvector&amp;lt;int&amp;gt; cctv_1 = {1};vector&amp;lt;int&amp;gt; cctv_2 = {1, 3};vector&amp;lt;int&amp;gt; cctv_3 = {0, 1};vector&amp;lt;int&amp;gt; cctv_4 = {0, 1, 3};vector&amp;lt;int&amp;gt; cctv_5 = {0, 1, 2, 3};cctvs.push_back(cctv_1);cctvs.push_back(cctv_2);cctvs.push_back(cctv_3);cctvs.push_back(cctv_4);cctvs.push_back(cctv_5);void inspect_dir(int ci, int cj, int dir) { while(true) { inspect[ci][cj] = true; int ai = ci + di[dir], aj = cj + dj[dir]; if(ai &amp;lt; 0 || aj &amp;lt; 0 || ai &amp;gt;= n || aj &amp;gt;= m) break; if(mm[ai][aj] == 6) break; ci = ai, cj = aj; }}void clear_inspect() { for0(i, 8) for0(j, 8) inspect[i][j] = false;}void dfs(int nth) { if(nth == cctv_vec.size()) { clear_inspect(); int cctv_order = 0; for0(i, n) { for0(j, m) { if(mm[i][j] == 0) continue; else if(mm[i][j] == 6) { inspect[i][j] = true; continue; } int cctv = cctv_vec[cctv_order]; for(int ldir: cctvs[cctv - 1]) { ldir += rot_vec[cctv_order]; if(ldir &amp;gt;= 4) ldir -= 4; inspect_dir(i, j, ldir); } cctv_order++; } } int non_inspect_cnt = 0; for0(i, n) for0(j, m) if(inspect[i][j] == false) non_inspect_cnt++; ans = min(ans, non_inspect_cnt); return; } int examin_cnt; switch(cctv_vec[nth]) { case 5: examin_cnt = 1; break; case 2: examin_cnt = 2; break; default: examin_cnt = 4; break; }; for(int i = 0; i &amp;lt; examin_cnt; i++) { rot_vec[nth]+=i; dfs(nth + 1); rot_vec[nth]-=i; }}void solve() { rot_vec.resize(cctv_vec.size(), 0); dfs(0);}int main() { ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int cctv_cnt = 0; for0(i, n) for0(j, m) { cin &amp;gt;&amp;gt; mm[i][j]; if(mm[i][j] != 0 &amp;amp;&amp;amp; mm[i][j] != 6) cctv_vec.push_back(mm[i][j]); } solve(); cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. Populatoin Migration (16234)", "url": "/posts/BOJ-16234/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, Implementation, 인구 이동, Populatoin Migration", "date": "2022-02-25 19:38:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16234#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;// #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for0(i, n) for(int i = 0; i &amp;lt; n; i++)#define for1(i, n) for(int i = 1; i &amp;lt;= n; i++)#define fori(s, e) for(int i = s; i &amp;lt; e; i++)typedef long long ll;const int INF = 987654321;int n, l, r;int a[100][100];int dayCnt = 0;int di[2] = { 1, 0 };int dj[2] = { 0, 1 };int uni[2500];int sum[2500];int nation_num[2500];void clear() { for0(i, n*n) uni[i] = i, nation_num[i] = 0, sum[i] = 0;}int union_get(int point) { if(uni[point] == point) return point; return uni[point] = union_get(uni[point]);}void unify(int ai, int aj, int bi, int bj) { int p1 = n*ai + aj, p2 = n*bi + bj; // cout &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; &quot; unify &quot; &amp;lt;&amp;lt; p2 &amp;lt;&amp;lt; endl; int u1 = union_get(p1), u2 = union_get(p2); if(u1 &amp;lt; u2) uni[u2] = u1; else uni[u1] = u2;}void solve() { while(true) { clear(); bool border_open = false; for0(i, n) { for0(j, n) { for0(k, 2) { if(i+di[k] &amp;gt;= n || j+dj[k] &amp;gt;= n) continue; int diff = abs(a[i][j] - a[i+di[k]][j+dj[k]]); if(l &amp;lt;= diff &amp;amp;&amp;amp; diff &amp;lt;= r) { unify(i, j, i + di[k], j + dj[k]); border_open = true; } } } } if(border_open == false) break; for0(i, n) { for0(j, n) { int union_idx = union_get(n*i + j); sum[union_idx] += a[i][j]; nation_num[union_idx]++; } } for0(i, n * n) { int ci = i / n, cj = i - n * ci; a[ci][cj] = sum[union_get(i)] / nation_num[union_get(i)]; } dayCnt++; }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); solve(); cout &amp;lt;&amp;lt; dayCnt; return 0;}" }, { "title": "BOJ. Marble Escape 2 (13460)", "url": "/posts/BOJ-13460/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, Implementation, 구슬 탈출 2, Marble Escape 2", "date": "2022-02-25 00:59:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/13460#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n, m, maxv;const int INF = 987654321;int gi, gj, ans = INF;bool bmap[20][20];int di[4] = { 0, -1, 0, 1 };int dj[4] = { -1, 0, 1, 0 };void dfs(int cnt, int ri, int rj, int bi, int bj) { if(cnt &amp;gt; 10) return; if(ri == gi &amp;amp;&amp;amp; rj == gj &amp;amp;&amp;amp; (bi != gi || bj != gj)) { ans = min(ans, cnt); return; } for(int i = 0; i &amp;lt; 4; i++) { bool rstop = false, bstop = false, rgoal = false, bgoal = false; int sri = ri, srj = rj, sbi = bi, sbj = bj; while(true) { if(sri == gi &amp;amp;&amp;amp; srj == gj) sri = -1, srj = -1, rgoal = true; if(sbi == gi &amp;amp;&amp;amp; sbj == gj) sbi = -1, sbj = -1, bgoal = true; if(!rstop) if(sri + di[i] &amp;lt; 0 || srj + dj[i] &amp;lt; 0 || sri + di[i] &amp;gt;= n || srj + dj[i] &amp;gt;= m || !bmap[sri+di[i]][srj+dj[i]]) rstop = true; if(!bstop) if(sbi + di[i] &amp;lt; 0 || sbj + dj[i] &amp;lt; 0 || sbi + di[i] &amp;gt;= n || sbj + dj[i] &amp;gt;= m || !bmap[sbi+di[i]][sbj+dj[i]]) bstop = true; if(rstop &amp;amp;&amp;amp; bstop) break; else if(!rstop &amp;amp;&amp;amp; !bstop) sbi+=di[i], sbj+=dj[i], sri+=di[i], srj+=dj[i]; else if(rstop) { if(sbi+di[i] == sri &amp;amp;&amp;amp; sbj+dj[i] == srj) break; sbi+=di[i], sbj+=dj[i]; } else { if(sri+di[i] == sbi &amp;amp;&amp;amp; srj+dj[i] == sbj) break; sri+=di[i], srj+=dj[i]; } } if(bgoal) continue; if(rgoal) { if(cnt + 1 &amp;gt; 10) continue; ans = min(ans, cnt + 1); return; } if(sri == ri &amp;amp;&amp;amp; srj == rj &amp;amp;&amp;amp; sbi == bi &amp;amp;&amp;amp; sbj == bj) continue; dfs(cnt+1, sri, srj, sbi, sbj); }}int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int ri, rj, bi, bj; for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; m; j++) { char c; cin &amp;gt;&amp;gt; c; if(c == &#39;#&#39;) continue; bmap[i][j] = true; if(c == &#39;O&#39;) gi = i, gj = j; else if(c == &#39;R&#39;) ri = i, rj = j; else if(c == &#39;B&#39;) bi = i, bj = j; } } dfs(0, ri, rj , bi, bj); cout &amp;lt;&amp;lt; (ans == INF ? -1 : ans); return 0;}" }, { "title": "BOJ. Tetromino (14500)", "url": "/posts/BOJ-14500/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, Implementation, 테트로미노, Tetromino", "date": "2022-02-24 21:48:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14500Express block with DFS of length 4#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int n, m, ans = INF;struct point{ int i, j; };vector&amp;lt;point&amp;gt; chicken;vector&amp;lt;point&amp;gt; home;vector&amp;lt;point&amp;gt; select_chicken;int distance(point p1, point p2) { return abs(p1.i - p2.i) + abs(p1.j - p2.j); }void dfs(int startIdx, int cnt) { if(cnt == m) { int mintmp = 0; for(point hp: home) { int dis = INF; for(point cp : select_chicken) dis = min(dis, distance(hp, cp)); mintmp += dis; } ans = min(ans, mintmp); return; } if(cnt &amp;lt; m - ((int)chicken.size() - startIdx)) return; for(int i = startIdx; i &amp;lt; chicken.size(); i++) { select_chicken.push_back(chicken[i]); dfs(i + 1, cnt + 1); select_chicken.pop_back(); }}int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; n; j++) { int in; cin &amp;gt;&amp;gt; in; if(in == 0) continue; point p; p.i = i, p.j = j; if(in == 1) home.push_back(p); else chicken.push_back(p); } } dfs(0, 0); cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. Snake (3190)", "url": "/posts/BOJ-3190/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, 뱀, Implementation, Snake", "date": "2022-02-24 15:49:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3190#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;// #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int n, m, ans = 0, time = 0, shark_len = 2, ate_fish = 0, ci, cj, elapse;int map[500][500];bool visit[500][500];struct point { int i, j, dis; point(int i, int j, int dis) : i(i), j(j), dis(dis) {};};int di[] = { -1, 0, 0, 1 };int dj[] = { 0, -1, 1, 0 };void bfs() { queue&amp;lt;point&amp;gt; q; q.push(point(ci, cj, 0)); int close_i = INF, close_j = INF, min_dis = INF; elapse = 0; while(!q.empty()) { point p = q.front(); q.pop(); if(visit[p.i][p.j]) continue; visit[p.i][p.j] = true; if(map[p.i][p.j] &amp;amp;&amp;amp; map[p.i][p.j] &amp;lt; shark_len) { if(p.dis &amp;lt; min_dis) { close_i = p.i; close_j = p.j; min_dis = p.dis; } else if(p.dis == min_dis) { if(close_i == p.i) close_j = min(close_j, p.j); else if(close_i &amp;gt; p.i) { close_i = p.i; close_j = p.j; } } } for(int i = 0; i &amp;lt; 4; i++) { int ii = p.i + di[i], jj = p.j + dj[i]; if(ii &amp;lt; 0 || jj &amp;lt; 0 || ii &amp;gt;= n || jj &amp;gt;= n || visit[ii][jj]) continue; if(map[ii][jj] &amp;gt; shark_len) continue; q.push(point(ii, jj, p.dis + 1)); } } for(int i = 0; i &amp;lt; n; i++) for(int j = 0; j &amp;lt; n; j++) visit[i][j] = false; if(close_i == INF) return; if(++ate_fish == shark_len) shark_len++, ate_fish = 0; ci = close_i, cj = close_j, elapse = min_dis; map[ci][cj] = 0;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; time = 0; for(int i = 0; i &amp;lt; n; i++) { int fish = 0; for(int j = 0; j &amp;lt; n; j++) { int in; cin &amp;gt;&amp;gt; in; if(in == 9) ci = i , cj = j; else { map[i][j] = in; fish++; } } } while(1) { int si = ci, sj = cj; bfs(); if(ci == si &amp;amp;&amp;amp; cj == sj) break; time += elapse; } cout &amp;lt;&amp;lt; time; return 0;}" }, { "title": "BOJ. Robot Vaccum Cleaner (14503)", "url": "/posts/BOJ-14503/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, 로봇 청소기, Implementation, Robot Vaccum Cleaner", "date": "2022-02-24 15:49:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14503#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;set&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int n, m, cnt;int ci, cj, dir;int di[4] = {-1, 0, 1, 0};int dj[4] = {0, 1, 0, -1};int map[50][50];bool visit[50][50];void solve() { cnt = 1; while(true) { bool breakloop = false; visit[ci][cj] = true; for(int i = 0; i &amp;lt; 4; i++) { if(--dir &amp;lt; 0) dir = 3; int ii = ci + di[dir], jj = cj + dj[dir]; if(ii &amp;lt; 0 || jj &amp;lt; 0 || ii &amp;gt;= n || jj &amp;gt;= m || visit[ii][jj] || map[ii][jj]) continue; visit[ii][jj] = true; cnt++; ci = ii, cj = jj; breakloop = true; break; } if(breakloop) continue; int back = dir - 2; if(back &amp;lt; 0) back += 4; int ii = ci + di[back], jj = cj + dj[back]; if(ii &amp;lt; 0 || jj &amp;lt; 0 || ii &amp;gt;= n || jj &amp;gt;= m || map[ii][jj]) return; ci = ii, cj = jj; if(!map[ci][cj] &amp;amp;&amp;amp; !visit[ci][cj]) { visit[ci][cj] = true; cnt++; } }}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; cin &amp;gt;&amp;gt; ci &amp;gt;&amp;gt; cj &amp;gt;&amp;gt; dir; for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; } solve(); cout &amp;lt;&amp;lt; cnt; return 0;}" }, { "title": "BOJ. Roll The Dice (14499)", "url": "/posts/BOJ-14499/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, 주사위 굴리기, Implementation, Roll The Dice", "date": "2022-02-24 14:22:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14499#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;// #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int n, m, ci, cj, k;int map[20][20];int dice[6] = { 0, 0, 0, 0, 0, 0 }; // x y z -x -y -zvoid move(int dir) { if(dir == 4){ if(ci == n - 1) return; ci++; int top = dice[2]; dice[2] = dice[3], dice[3] = dice[5], dice[5] = dice[0], dice[0] = top; } else if(dir == 3){ if(ci == 0) return; ci--; int top = dice[2]; dice[2] = dice[0], dice[0] = dice[5], dice[5] = dice[3], dice[3] = top; } else if(dir == 2){ if(cj == 0) return; cj--; int top = dice[2]; dice[2] = dice[1], dice[1] = dice[5], dice[5] = dice[4], dice[4] = top; } else { if(cj == m - 1) return; cj++; int top = dice[2]; dice[2] = dice[4], dice[4] = dice[5], dice[5] = dice[1], dice[1] = top; } if(map[ci][cj]) { dice[5] = map[ci][cj]; map[ci][cj] = 0; } else map[ci][cj] = dice[5]; cout &amp;lt;&amp;lt; dice[2] &amp;lt;&amp;lt; &#39;\\n&#39;;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; ci &amp;gt;&amp;gt; cj &amp;gt;&amp;gt; k; for(int i = 0; i &amp;lt; n; i++) for(int j = 0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; int dir; for(int i = 0; i &amp;lt; k; i++) { cin &amp;gt;&amp;gt; dir; move(dir); } return 0;}" }, { "title": "BOJ. Baby Shark (16236)", "url": "/posts/BOJ-16236/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, 아기 상어, Implementation, Baby Shark", "date": "2022-02-23 19:22:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16236#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;// #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int n, m, ans = 0, time = 0, shark_len = 2, ate_fish = 0, ci, cj, elapse;int map[500][500];bool visit[500][500];struct point { int i, j, dis; point(int i, int j, int dis) : i(i), j(j), dis(dis) {};};int di[] = { -1, 0, 0, 1 };int dj[] = { 0, -1, 1, 0 };void bfs() { queue&amp;lt;point&amp;gt; q; q.push(point(ci, cj, 0)); int close_i = INF, close_j = INF, min_dis = INF; elapse = 0; while(!q.empty()) { point p = q.front(); q.pop(); if(visit[p.i][p.j]) continue; visit[p.i][p.j] = true; if(map[p.i][p.j] &amp;amp;&amp;amp; map[p.i][p.j] &amp;lt; shark_len) { if(p.dis &amp;lt; min_dis) { close_i = p.i; close_j = p.j; min_dis = p.dis; } else if(p.dis == min_dis) { if(close_i == p.i) close_j = min(close_j, p.j); else if(close_i &amp;gt; p.i) { close_i = p.i; close_j = p.j; } } } for(int i = 0; i &amp;lt; 4; i++) { int ii = p.i + di[i], jj = p.j + dj[i]; if(ii &amp;lt; 0 || jj &amp;lt; 0 || ii &amp;gt;= n || jj &amp;gt;= n || visit[ii][jj]) continue; if(map[ii][jj] &amp;gt; shark_len) continue; q.push(point(ii, jj, p.dis + 1)); } } for(int i = 0; i &amp;lt; n; i++) for(int j = 0; j &amp;lt; n; j++) visit[i][j] = false; if(close_i == INF) return; if(++ate_fish == shark_len) shark_len++, ate_fish = 0; ci = close_i, cj = close_j, elapse = min_dis; map[ci][cj] = 0;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; time = 0; for(int i = 0; i &amp;lt; n; i++) { int fish = 0; for(int j = 0; j &amp;lt; n; j++) { int in; cin &amp;gt;&amp;gt; in; if(in == 9) ci = i , cj = j; else { map[i][j] = in; fish++; } } } while(1) { int si = ci, sj = cj; bfs(); if(ci == si &amp;amp;&amp;amp; cj == sj) break; time += elapse; } cout &amp;lt;&amp;lt; time; return 0;}" }, { "title": "BOJ. Chicken Delivery (15686)", "url": "/posts/BOJ-15686/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, DFS, Review, Important, String, 치킨 배달, Implementation, Chicken Delivery", "date": "2022-02-22 21:48:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/15686#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int n, m, ans = INF;struct point{ int i, j; };vector&amp;lt;point&amp;gt; chicken;vector&amp;lt;point&amp;gt; home;vector&amp;lt;point&amp;gt; select_chicken;int distance(point p1, point p2) { return abs(p1.i - p2.i) + abs(p1.j - p2.j); }void dfs(int startIdx, int cnt) { if(cnt == m) { int mintmp = 0; for(point hp: home) { int dis = INF; for(point cp : select_chicken) dis = min(dis, distance(hp, cp)); mintmp += dis; } ans = min(ans, mintmp); return; } if(cnt &amp;lt; m - ((int)chicken.size() - startIdx)) return; for(int i = startIdx; i &amp;lt; chicken.size(); i++) { select_chicken.push_back(chicken[i]); dfs(i + 1, cnt + 1); select_chicken.pop_back(); }}int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; n; j++) { int in; cin &amp;gt;&amp;gt; in; if(in == 0) continue; point p; p.i = i, p.j = j; if(in == 1) home.push_back(p); else chicken.push_back(p); } } dfs(0, 0); cout &amp;lt;&amp;lt; ans; return 0;}" }, { "title": "BOJ. Longest Palindrome Substring (13275)", "url": "/posts/BOJ-13275/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Manacher Algorithm, Review, Important, String, 가장 긴 팰린드롬 부분 문자열, Longest Palindrome Substring", "date": "2022-02-22 18:13:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/13275Manacher Algorithm#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef long long ll;const int INF = 987654321;int main() { string s; cin &amp;gt;&amp;gt; s; int len = s.size(); vector&amp;lt;int&amp;gt; odd; vector&amp;lt;int&amp;gt; even; odd.resize(len); even.resize(len); int oddMax = -1, evenMax = -1; //even[i] : i - 1 == i int l_odd = 0, r_odd = -1; int l_even = 0, r_even = -1; for(int i = 0; i &amp;lt; len; i++) { odd[i] = i &amp;lt;= r_odd ? min(r_odd - i + 1, odd[l_odd + r_odd - i]) : 1; even[i] = i &amp;lt;= r_even ? min(r_even - i + 1, even[l_even + r_even - i + 1]) : 0; while( 0 &amp;lt;= i - odd[i] &amp;amp;&amp;amp; i + odd[i] &amp;lt; len &amp;amp;&amp;amp; s[i - odd[i]] == s[i + odd[i]] ) odd[i]++; while( 0 &amp;lt;= i - 1 - even[i] &amp;amp;&amp;amp; i + even[i] &amp;lt; len &amp;amp;&amp;amp; s[i - 1 - even[i]] == s[i + even[i]] ) even[i]++; oddMax = max(oddMax, odd[i]); evenMax = max(evenMax, even[i]); if(i + odd[i] - 1 &amp;gt; r_odd) { r_odd = i + odd[i] - 1; l_odd = i - odd[i] + 1; } if(i + even[i] - 1 &amp;gt; r_even) { r_even = i + even[i] - 1; l_even = i - even[i]; } } cout &amp;lt;&amp;lt; max(2 * evenMax, 2 * oddMax - 1); return 0;}" }, { "title": "BOJ. Reason the fox came up to Island (17131)", "url": "/posts/BOJ-17131/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, 여우가 정보섬에 올라온 이유, Reason the fox came up to Island, Non Recursive Segment Tree, Sweeping", "date": "2022-02-21 18:01:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17131Lazy propagation with non recursive segment tree.There was no code sample of using lazy propagation with recursive segment tree so I’ll share this code.Hope this help some one.*Not to using scanf and cin when ios_base::sync_with_stdio(0)(turn off the sync to stdio);#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef long long ll;const int N = 1 &amp;lt;&amp;lt; 20;const int mod = 1e9 + 7;const int adjust = 2e5;int n;int seg[2 * N];struct point { int x; int y; int idx;};vector&amp;lt;point&amp;gt; points;vector&amp;lt;point&amp;gt; sweep;void update(int y) { for(y+=N; y &amp;gt; 0; y&amp;gt;&amp;gt;=1) seg[y]++;}int get(int basis) { int cnt = 0; for(int l=basis + 1 + N, r = 2*N - 1; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1) { if(l &amp;amp; 1) cnt+=seg[l++]; if(r &amp;amp; 1) cnt+=seg[--r]; } return cnt;}void clearSeg() { for(int i = 0; i &amp;lt; 2*N; i++) seg[i] = 0;}bool cmp(point p1, point p2) { return p1.x &amp;lt; p2.x; }int main() { cin &amp;gt;&amp;gt; n; for(int i = 0; i &amp;lt; n; i++) { point ptmp; cin &amp;gt;&amp;gt; ptmp.x &amp;gt;&amp;gt; ptmp.y; ptmp.idx = i; ptmp.y += adjust; points.push_back(ptmp); } sort(points.begin(), points.end(), cmp); int staging_x = points[0].x; int left[n], right[n]; vector&amp;lt;vector&amp;lt;point&amp;gt;&amp;gt; x_group; vector&amp;lt;point&amp;gt; tmp; for(point p : points) { if(staging_x != p.x) { x_group.push_back(tmp); tmp.clear(); tmp.push_back(p); staging_x = p.x; } else tmp.push_back(p); } if(tmp.size()) x_group.push_back(tmp); for(vector&amp;lt;point&amp;gt; vec: x_group) { for(point p: vec) left[p.idx] = get(p.y); for(point p: vec) update(p.y); } clearSeg(); x_group.clear(); tmp.clear(); staging_x = points.back().x; for(int i = points.size() - 1; i &amp;gt;= 0; i--) { point p = points[i]; if(staging_x != p.x) { x_group.push_back(tmp); tmp.clear(); tmp.push_back(p); staging_x = p.x; } else { tmp.push_back(p); } } if(tmp.size()) x_group.push_back(tmp); for(vector&amp;lt;point&amp;gt; vec: x_group) { for(point p: vec) { right[p.idx] = get(p.y); } for(point p: vec) { update(p.y); } } long sum = 0; for(int i = 0; i &amp;lt; n; i++) { sum = sum + (long)left[i] * right[i]; sum %=mod; } cout &amp;lt;&amp;lt; sum; return 0;}" }, { "title": "LeetCode. 43. Multiply Strings", "url": "/posts/Leetcode-43.-Multiply-Strings/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, String, LeetCode, Multiply Strings", "date": "2022-02-21 05:52:00 +0900", "snippet": "[Link] https://leetcode.com/problems/multiply-strings/class Solution { public String multiply(String num1, String num2) { StringBuilder sb = new StringBuilder(); int len1 = num1.length(), len2 = num2.length(); int[] arr = new int[len1 + len2]; for(int i = 0; i &amp;lt; len1; i++) for(int j = 0; j &amp;lt; len2; j++) arr[i + j + 1] += (num1.charAt(i) - &#39;0&#39;) * (num2.charAt(j) - &#39;0&#39;); for(int i = arr.length - 1; i &amp;gt;= 0; i--) { if(arr[i] == -1) continue; if(arr[i] &amp;gt; 9) { int remainder = arr[i] / 10; arr[i - 1] += remainder; arr[i] -= 10 * remainder; } } boolean zero = true; for(int i = 0; i &amp;lt;= len1 + len2 - 1; i++) { if(zero) { if(arr[i] == 0) continue; else zero = false; } if(!zero) sb.append(Integer.toString(arr[i])); } return sb.length() == 0 ? &quot;0&quot; : sb.toString(); }}" }, { "title": "BOJ. Minimum Value (10999)", "url": "/posts/BOJ-10999/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, 최솟값, Minimum Value, Non Recursive Segment Tree, Lazy Propagation", "date": "2022-02-21 05:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/10999Lazy propagation with non recursive segment tree.There was no code sample of using lazy propagation with recursive segment tree so I’ll share this code.Hope this help some one.*Not to using scanf and cin when ios_base::sync_with_stdio(0)(turn off the sync to stdio);#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;typedef long long ll;const int N = 1024 * 1024;ll seg[2 * N];ll lazy[2 * N];int n;int segH = 0;ll arr[N];void init() { for(int i = N - 1; i &amp;gt; 0; i--) seg[i] = seg[i &amp;lt;&amp;lt; 1] + seg[i &amp;lt;&amp;lt; 1 | 1]; int i = N; while(i &amp;gt; 0) i&amp;gt;&amp;gt;=1, segH++;}void apply(int idx) { seg[idx] += lazy[idx]; if(idx &amp;lt; N) { lazy[idx&amp;lt;&amp;lt;1] += lazy[idx]&amp;gt;&amp;gt;1; lazy[idx&amp;lt;&amp;lt;1|1] += lazy[idx]&amp;gt;&amp;gt;1; } lazy[idx] = 0l;}void propagate(int idx) { int nn = idx, log = 0; while(nn &amp;gt; 0) nn&amp;gt;&amp;gt;=1, log++; for(int i = segH; i &amp;gt;= 0; i--) { int index = idx &amp;gt;&amp;gt; i; if(lazy[index] != 0l) { apply(index); } }}void updateParent(int idx, ll add) { propagate(idx); if(idx &amp;lt; N) lazy[idx]+=add; else seg[idx] += add; while(idx &amp;gt; 1) idx&amp;gt;&amp;gt;=1, seg[idx]+=add;}void update(int l, int r, ll add) { for(l+=N, r+=N; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1, add&amp;lt;&amp;lt;=1) { if(l &amp;amp; 1) updateParent(l++, add); if(r &amp;amp; 1) updateParent(--r, add); }}ll query(int l, int r) { ll sum = 0l; for(l+=N, r+=N; l&amp;lt;r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1) { if(l &amp;amp; 1) { propagate(l); sum+=seg[l++]; } if(r &amp;amp; 1) { propagate(--r); sum+=seg[r]; } } return sum;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m, k, mk; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k; mk = m + k; for(int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; seg[N + i]; init(); for(int i = 0; i &amp;lt; m + k; i++) { int a, b, c; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c; if(a == 1) { ll d; cin &amp;gt;&amp;gt; d; update(b - 1, c, d); } else cout &amp;lt;&amp;lt; query(b - 1, c) &amp;lt;&amp;lt; &#39;\\n&#39;; } return 0;}" }, { "title": "BOJ. Histogram (1725)", "url": "/posts/BOJ-1725/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, 히스토그램, Histogram, Divide And Conquer, Non Recursive Segment Tree", "date": "2022-02-18 12:33:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1725#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;typedef long long ll;const int N = 1e5 + 1;int seg[2 * N];ll h[N];int n;ll ans = 0;void init() { for(int i = 0; i &amp;lt; n; i++) seg[i + n] = i; for(int i = n - 1; i &amp;gt; 0; i--) seg[i] = h[seg[i&amp;lt;&amp;lt;1]] &amp;lt; h[seg[i&amp;lt;&amp;lt;1|1]] ? seg[i&amp;lt;&amp;lt;1] : seg[i&amp;lt;&amp;lt;1|1];}int query(int l, int r) { int min = 1e9, minIdx = 0; for(l += n, r += n; l &amp;lt; r; l &amp;gt;&amp;gt;= 1, r &amp;gt;&amp;gt;= 1) { if(l &amp;amp; 1) { if(min &amp;gt; h[seg[l]]) { minIdx = seg[l]; min = h[minIdx]; } l++; } if(r &amp;amp; 1) { if(min &amp;gt; h[seg[--r]]) { minIdx = seg[r]; min = h[minIdx]; } } } return minIdx;}void bipartite(int l, int r) { //Does not include r if(l &amp;gt;= r) return; if(l + 1 == r) { ans = max(ans, h[l]); return; } int minIdx = query(l, r); ans = max(ans, h[minIdx] * (r - l)); bipartite(l, minIdx); bipartite(minIdx + 1, r);}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; h[i]; init(); bipartite(0, n); cout &amp;lt;&amp;lt; ans;}" }, { "title": "BOJ. Sum of numbers 7 (2268)", "url": "/posts/BOJ-2268/", "categories": "Record, Code", "tags": "C++, Algorithm, BOJ, Segment Tree, 수들의 합 7, Sum of numbers 7, Non Recursive Segment Tree", "date": "2022-02-18 09:28:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2268#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;typedef long long ll;const int N=1e6+1;ll seg[2*N];int n;void modify(int pos, int v){ for(seg[pos+=n]=v; pos&amp;gt;1; pos&amp;gt;&amp;gt;=1) seg[pos&amp;gt;&amp;gt;1] = seg[pos]+seg[pos^1];}ll sum(int l, int r){ ll sum=0; for(l+=n, r+=n; l&amp;lt;r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1){ if(l&amp;amp;1) sum+=seg[l++]; if(r&amp;amp;1) sum+=seg[--r]; } return sum;}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; while(m--){ int query, a, b; cin&amp;gt;&amp;gt;query&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; if(query!=0) modify(a,b); else { if(a&amp;gt;b) swap(a,b); cout&amp;lt;&amp;lt;sum(a,b+1)&amp;lt;&amp;lt;&#39;\\n&#39;; } } return 0;}" }, { "title": "BOJ. Coffe Shop (1275)", "url": "/posts/BOJ-1275/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, Segment Tree, 커피숍2, Coffe Shop, Non Recursive Segment Tree", "date": "2022-02-18 08:37:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1275import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static long[] seg; static int n; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); sb = new StringBuilder(); int[] rl = getArr(); int[] arr; n = rl[0]; int q = rl[1]; seg = new long[2*n]; arr = getArr(); init(arr); for(int i = 0; i &amp;lt; q; i++) { rl = getArr(); int x = rl[0], y = rl[1], a = rl[2] - 1, b = rl[3]; if(x &amp;gt; y) { int tmp = x; x = y; y = tmp; } sb.append(get(x - 1, y)).append(&quot;\\n&quot;); update(a, b); } print(sb); } static void init(int[] arr) { for(int i=0; i&amp;lt;n; i++) seg[i+n]=arr[i]; for(int i=n-1; i&amp;gt;0; i--) seg[i]=seg[i&amp;lt;&amp;lt;1]+seg[i&amp;lt;&amp;lt;1|1]; } static long get(int l, int r) { long sum = 0l; for(l+=n, r+=n; l&amp;lt;r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1) { if((l &amp;amp; 1)!=0) sum+=seg[l++]; if((r &amp;amp; 1)!=0) sum+=seg[--r]; } return sum; } static void update(int pos, int v) { pos+=n; seg[pos]=v; for(; pos&amp;gt;1; pos&amp;gt;&amp;gt;=1) { seg[pos&amp;gt;&amp;gt;1]=seg[pos]+seg[pos^1]; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Minimum Value (10868)", "url": "/posts/BOJ-10868/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, Segment Tree, 최솟값, Minimum Value, Non Recursive Segment Tree", "date": "2022-02-18 01:25:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/10868import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] seg; static int n; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); sb = new StringBuilder(); int[] line = getArr(); n = line[0]; int m = line[1]; int[] arr = new int[n]; for(int i = 0; i &amp;lt; n; i++) arr[i] = toi(br.readLine()); seg = new int[n &amp;lt;&amp;lt; 1]; init(arr); while(m-- &amp;gt; 0) { line = getArr(); int a = line[0] - 1, b = line[1]; sb.append(get(a, b)).append(&quot;\\n&quot;); } print(sb); } public static void init(int[] arr) { for(int i = 0; i &amp;lt; n; i++) seg[i + n] = arr[i]; for(int i = n - 1; i &amp;gt; 0; i--) seg[i] = Math.min(seg[i&amp;lt;&amp;lt;1], seg[i&amp;lt;&amp;lt;1|1]); } public static int get(int l, int r) { int ans = Integer.MAX_VALUE; for(l += n, r += n; l &amp;lt; r; l &amp;gt;&amp;gt;= 1, r &amp;gt;&amp;gt;= 1) { if((l &amp;amp; 1) != 0) ans = Math.min(ans, seg[l++]); if((r &amp;amp; 1) != 0) ans = Math.min(ans, seg[--r]); } return ans; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Water taxi (2836)", "url": "/posts/BOJ-2836/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, Sweeping, Segment Tree, 수상 택시, Water taxi", "date": "2022-02-17 12:24:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2836import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] seg; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); sb = new StringBuilder(); int[] arr = getArr(); int n = arr[0], m = arr[1]; ArrayList&amp;lt;Line&amp;gt; lines = new ArrayList&amp;lt;&amp;gt;(); int incLeft = m, incRight = 0, decLeft = m, decRight = 0; while(n-- &amp;gt; 0) { arr = getArr(); int pos = arr[0], dest = arr[1]; if(dest &amp;lt; pos) lines.add(new Line(dest, pos)); } if(lines.isEmpty()) { print(m); return; } Collections.sort(lines, (l, r) -&amp;gt; l.left &amp;gt; r.left ? 1 : -1 ); int preRight = lines.get(0).right, dis = preRight - lines.get(0).left; for(int i = 1; i &amp;lt; lines.size(); i++) { Line line = lines.get(i); if(line.right &amp;lt;= preRight) continue; if(preRight &amp;lt;= line.left) dis += line.right - line.left; else dis += line.right - preRight; preRight = line.right; } print(m + 2 * (long)dis); } static class Line { int left, right; Line(int left, int right) { this.left = left; this.right = right; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Northwesterly Wind (5419)", "url": "/posts/BOJ-5419/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, Sweeping, Segment Tree, 북서풍, Northwesterly Wind", "date": "2022-02-17 10:57:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/5419import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] seg; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); sb = new StringBuilder(); int[] arr; int test = toi(br.readLine()); while(test-- &amp;gt; 0) { int n = toi(br.readLine()); ArrayList&amp;lt;Point&amp;gt; points = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { arr = getArr(); points.add(new Point(arr[0], arr[1])); } Collections.sort(points, (l, r) -&amp;gt; Integer.compare(l.y, r.y)); int rankIdx = 0, cmp = points.get(0).y; for(Point p : points) { if(p.y != cmp) p.rank = ++rankIdx; else p.rank = rankIdx; cmp = p.y; } Collections.sort(points, (l, r) -&amp;gt; { if(l.x == r.x) return l.y &amp;lt; r.y ? 1 : -1; return l.x &amp;gt; r.x ? 1 : -1; }); seg = new int[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(rankIdx + 1) / Math.log(2)) + 1]; long cnt = 0; for(Point p : points) { cnt += get(0, rankIdx, 1, p.rank); update(0, rankIdx, 1, p.rank); } sb.append(cnt).append(&quot;\\n&quot;); } print(sb); } static void update(int left, int right, int idx, int h) { if(right &amp;lt; h || h &amp;lt; left) return; seg[idx]++; if(left == right) return; int mid = (left + right) &amp;gt;&amp;gt; 1; if(mid + 1 &amp;lt;= h) update(mid + 1, right, 2 * idx + 1, h); else update(left, mid, 2 * idx, h); } static int get(int left, int right, int idx, int h) { if(left &amp;gt;= h) return seg[idx]; if(right &amp;lt; h) return 0; int mid = (right + left) &amp;gt;&amp;gt; 1; return get(left, mid, 2 * idx, h) + get(mid + 1, right, 2 * idx + 1, h); } static class Point { int x, y, rank; Point(int x, int y) { this.x = x; this.y = y; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. line Drawing (2170)", "url": "/posts/BOJ-2170/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, SCC, Graph, Sweeping, 선 긋기, line Drawing", "date": "2022-02-16 02:27:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2170import java.util.*;import java.io.*;public class Main { static BufferedReader br; // static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()); String[] line; ArrayList&amp;lt;Line&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { line = br.readLine().split(&quot; &quot;); long a = Long.parseLong(line[0]), b = Long.parseLong(line[1]); al.add(new Line(a, b)); } al.sort((l, r) -&amp;gt; { if(l.left == r.left) return l.right &amp;lt; r.right ? 1 : -1; else return l.left &amp;gt; r.left ? 1 : -1; }); long sl = al.get(0).left, sr = al.get(0).right, totLen = sr - sl; for(Line ll : al) { if(sl &amp;lt;= ll.left &amp;amp;&amp;amp; ll.right &amp;lt;= sr) continue; else if(sl == ll.left) { totLen += ll.right - sr; } else { if(sr &amp;lt;= ll.left) { totLen += ll.right - ll.left; } else totLen += ll.right - sr; } sl = ll.left; sr = ll.right; } print(totLen); } static class Line { long left, right; Line(long left, long right) { this.left = left; this.right = right; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. ATM (4013)", "url": "/posts/BOJ-4013/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, SCC, Graph, Strongly Connected Component, ATM, Review, import, difficult", "date": "2022-02-15 19:35:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/4013Step 1. get SCCStep 2.Method 1Tarjan is DFSSCC =&amp;gt; update dp from biggest idx to lowerfor(int i = groupIdx - 1; i &amp;gt;= 0; i--) { for(int ge : sccEdges[i]) { dp[ge] = Math.max(dp[ge], dp[i] + money[ge]); }}Method 2SCC =&amp;gt; DAG(Directed Acyclic Graph) =&amp;gt; update dp in order of Topological sortMethod 3Similar to Method 2, use Dijkstraimport java.util.*;import java.io.*;public class Main { static BufferedReader br; // static StringBuilder sb = new StringBuilder(); static ArrayList&amp;lt;Integer&amp;gt;[] edges; static int[] parent, group; static boolean[] finish; static int sccIdx = 1, groupIdx = 0; static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); int n = arr[0], m = arr[1]; edges = new ArrayList[n]; parent = new int[n]; finish = new boolean[n]; group = new int[n]; Arrays.fill(group, -1); for(int i = 0; i &amp;lt; n; i++) edges[i] = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; edges[a].add(b); } int[] moneyTmp = new int[n]; for(int i = 0; i &amp;lt; n; i++) moneyTmp[i] = toi(br.readLine()); arr = getArr(); int s = arr[0] - 1, p = arr[1]; scc(s); ArrayList&amp;lt;Integer&amp;gt;[] sccEdges = new ArrayList[sccIdx]; for(int i = 0; i &amp;lt; groupIdx; i++) sccEdges[i] = new ArrayList&amp;lt;&amp;gt;(); boolean[] restaurant = new boolean[groupIdx]; long[] dp = new long[groupIdx]; long[] money = new long[groupIdx]; arr = getArr(); for(int e: arr) { if(group[e - 1] == -1) continue; restaurant[group[e - 1]] = true; } for(int i = 0; i &amp;lt; n; i++) { if(group[i] == -1) continue; money[group[i]] += moneyTmp[i]; for(int e: edges[i]) { if(group[e] == group[i]) continue; sccEdges[group[i]].add(group[e]); } } for(int i = 0; i &amp;lt; groupIdx; i++) dp[i] = money[i]; long max = 0; for(int i = groupIdx - 1; i &amp;gt;= 0; i--) { for(int ge : sccEdges[i]) { dp[ge] = Math.max(dp[ge], dp[i] + money[ge]); } } for(int i = 0; i &amp;lt; groupIdx; i++) if(restaurant[i]) max = Math.max(max, dp[i]); print(max); } static int scc(int idx) { int origVal = parent[idx] = sccIdx++; stack.push(idx); for(int e : edges[idx]) { if(parent[e] == 0) parent[idx] = Math.min(parent[idx], scc(e)); else if(!finish[e]) parent[idx] = Math.min(parent[idx], parent[e]); } if(origVal == parent[idx]) { long totalMoney = 0; while(true) { int pop = stack.pop(); finish[pop] = true; group[pop] = groupIdx; if(pop == idx) break; } groupIdx++; } return parent[idx]; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Round 771 (Div. 2) D. Big Brush", "url": "/posts/Codeforces-Codeforces-Round-771-(Div.-2)-D.-Big-Brush/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Div 2, Codeforces Round. Codeforces, Big Brush", "date": "2022-02-14 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1638/problem/Dimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int n, m; static int[][] graph; static int[] di = new int[]{0, 1, 0, 1}; static int[] dj = new int[]{0, 0, 1, 1}; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); sb = new StringBuilder(); int[] arr = getArr(); n = arr[0]; m = arr[1]; graph = new int[n][m]; for(int i = 0; i &amp;lt; n; i++) graph[i] = getArr(); Queue&amp;lt;Point&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); Stack&amp;lt;History&amp;gt; history = new Stack&amp;lt;&amp;gt;(); int[] dy = new int[]{-1, -1, -1, 0, 0, 1, 1, 1}; int[] dx = new int[]{-1, 0, 1, -1, 1, -1, 0, 1}; boolean[][] visit = new boolean[n][m]; int cnt = 0; findSquare(q); while(!q.isEmpty()) { Point point = q.poll(); int ci = point.i, cj = point.j; if(visit[ci][cj]) continue; visit[ci][cj] = true; history.add(new History(point, point.color)); fillSquare(point); cnt++; for(int i = 0; i &amp;lt; 8; i++) { int ai = ci + dy[i], aj = cj + dx[i]; int color = checkSquare(ai, aj); if(color == -1) continue; Point tmp = new Point(ai, aj, color); if(!visit[ai][aj]) q.add(tmp); } } if(checkIfClear()) { sb.append(cnt).append(&quot;\\n&quot;); while(!history.isEmpty()) { History h = history.pop(); sb.append(h.point.i + 1).append(&quot; &quot;).append(h.point.j + 1).append(&quot; &quot;).append(h.color).append(&quot;\\n&quot;); } } else { sb.append(-1); } print(sb); } static boolean checkIfClear() { for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; m; j++) { if(graph[i][j] != 0 &amp;amp;&amp;amp; graph[i][j] != -1) return false; } } return true; } static void fillSquare(Point p) { for(int i = 0; i &amp;lt; 4; i++) { int ii = p.i + di[i], jj = p.j + dj[i]; graph[ii][jj] = -1; } } static int checkSquare(int ii, int jj) { if(!isValid(ii, jj)) return -1; int color = -1; int cnt = 0; int[] val = new int[4]; for(int i = 0; i &amp;lt; 4; i++) val[i] = graph[ii + di[i]][jj + dj[i]]; for(int i = 0; i &amp;lt; 4; i++) { if(color == -1) { if(color != val[i]) { color = val[i]; cnt++; } } else { if(val[i] != -1 &amp;amp;&amp;amp; color != val[i]) return -1; else cnt++; } } return color; } static void findSquare(Queue&amp;lt;Point&amp;gt; q) { for(int i = 0; i &amp;lt; n - 1; i++) { for(int j = 0; j &amp;lt; m - 1; j++) { if( graph[i][j] == graph[i + 1][j] &amp;amp;&amp;amp; graph[i][j] == graph[i][j + 1] &amp;amp;&amp;amp; graph[i][j] == graph[i + 1][j + 1] ) { q.add(new Point(i, j, graph[i][j])); } } } } static boolean isValid(int ii, int jj) { if(ii &amp;lt; 0 || jj &amp;lt; 0) return false; if(ii + 1 &amp;gt;= n || jj + 1 &amp;gt;= m) return false; return true; } static class Point { int i, j, color; public Point(int i, int j, int color) { this.i = i; this.j = j; this.color = color; } } static class History { Point point; int color; public History(Point point, int color) { this.point = point; this.color = color; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Round 771 (Div. 2) C. Inversion Graph", "url": "/posts/Codeforces-Codeforces-Round-771-(Div.-2)-C.-Inversion-Graph/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Div 2, Codeforces Round, Codeforces, Inversion Graph", "date": "2022-02-14 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1638/problem/Cimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int test = toi(br.readLine()); int[] arr; int[] parent; for(int iter = 0; iter &amp;lt; test; iter++) { int n = toi(br.readLine()), max = -1, groupCnt = 0; arr = getArr(); int[] idx = new int[n + 1]; for(int i = 0; i &amp;lt; n; i++) idx[arr[i]] = i + 1; for(int i = 0; i &amp;lt; n; i++) { max = Math.max(max, idx[i]); if(max == i) groupCnt++; } sb.append(groupCnt).append(&quot;\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Round 771 (Div. 2) B. Odd Swap Sort", "url": "/posts/Codeforces-Codeforces-Round-771-(Div.-2)-B.-Odd-Swap-Sort/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Div 2, Codeforces, Odd Swap Sort", "date": "2022-02-14 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1638/problem/Bimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int test = toi(br.readLine()); int[] arr; loop: for(int iter = 0; iter &amp;lt; test; iter++) { int n = toi(br.readLine()); arr = getArr(); // ArrayList&amp;lt;Integer&amp;gt; sorted = new ArrayList&amp;lt;&amp;gt;(); int oddMax = 0, evenMax = 0; for(int i = 0; i &amp;lt; n; i++) { int num = arr[i]; if((num &amp;amp; 1) == 0) { if(evenMax &amp;gt; num) { sb.append(&quot;No\\n&quot;); continue loop; } evenMax = Math.max(evenMax, num); } else { if(oddMax &amp;gt; num) { sb.append(&quot;No\\n&quot;); continue loop; } oddMax = Math.max(oddMax, num); } } sb.append(&quot;Yes\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Round 771 (Div. 2) A. Reverse", "url": "/posts/Codeforces-Codeforces-Round-771-(Div.-2)-A.-Reverse/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Codeforces Round, Div 2, Codeforces, Reverse", "date": "2022-02-14 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1638/problem/Aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int test = toi(br.readLine()); int[] arr; for(int iter = 0; iter &amp;lt; test; iter++) { int n = toi(br.readLine()); arr = getArr(); int l = 0, r = 0, cnt = 1; int[] idx = new int[n + 1]; for(int i = 0; i &amp;lt; n; i++) idx[arr[i]] = i + 1; for(int i = 1; i &amp;lt;= n; i++) if(idx[i] != i) { r = i; break; } else { l++; } while(l &amp;lt; r) { int tmp = arr[l]; arr[l] = arr[r]; arr[r] = tmp; l++; r--; } for(int e: arr) sb.append(e).append(&quot; &quot;); sb.append(&quot;\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. 2-SAT - 4 (11281)", "url": "/posts/BOJ-11281/", "categories": "Record, Code", "tags": "Java, Algorithm, BOJ, SCC, Graph, Strongly Connected Component, 2-SAT - 4", "date": "2022-02-14 17:35:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11281Tarjan is DFSimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static Node[] nodes; static int[] parent; static int[] group; static boolean[] finish; static int sccIdx = 1, n, groupIdx = 1; static boolean canSolve = true; static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); n = arr[0]; int m = arr[1]; nodes = new Node[2 * n]; for(int i = 0; i &amp;lt; 2 * n ; i++) nodes[i] = new Node(rev(i)); parent = new int[2 * n]; group = new int[2 * n]; finish = new boolean[2 * n]; for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0], b = arr[1]; nodes[convert(-1 * a)].list.add(b); nodes[convert(-1 * b)].list.add(a); } for(int i = 0; i &amp;lt; 2 * n; i++) { if(parent[i] == 0) scc(i); } if(!canSolve) print(0); else { boolean[] groupSelected = new boolean[sccIdx]; sb.append(&quot;1\\n&quot;); for(int i = 1; i &amp;lt;= n; i++) { int g1 = group[convert(i)], g2 = group[convert(i * -1)]; sb.append(g1 &amp;lt; g2 ? &quot;1 &quot; : &quot;0 &quot;); } print(sb); } } static int scc(int idx) { int origVal = parent[idx] = sccIdx++; stack.push(idx); for(int e : nodes[idx].list) { if(parent[convert(e)] == 0) parent[idx] = Math.min(parent[idx], scc(convert(e))); else if(!finish[convert(e)]) parent[idx] = Math.min(parent[idx], parent[convert(e)]); } if(origVal == parent[idx]) { HashSet&amp;lt;Integer&amp;gt; hs = new HashSet&amp;lt;&amp;gt;(); while(true) { int pop = stack.peek(); stack.pop(); int rev = rev(pop); finish[pop] = true; group[pop] = groupIdx; if(hs.contains(rev * -1)) canSolve = false; hs.add(rev); if(pop == idx) break; } groupIdx++; } return parent[idx]; } static int convert(int val) { return val &amp;gt; 0 ? val - 1 : n - 1 - val; } static int rev(int idx) { return idx &amp;lt; n ? idx + 1 : n - 1 - idx; } static int abs(int nn) { return nn &amp;gt; 0 ? nn : -1 * nn; } static class Node { int idx; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. Regular Contest 135 C XOR to All", "url": "/posts/Atcoder-C-XOR-to-All/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, XOR, Regular Contest", "date": "2022-02-14 02:32:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/arc135/tasks/arc135_cIDEAimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); var n = toi(br.readLine()); var arr = getArr(); var bitCnt = new int[30]; var sum = 0l; for(int e: arr) { int digit = 0; while(e &amp;gt; 0) { if((e &amp;amp; 1) == 1) bitCnt[digit]++; digit++; e &amp;gt;&amp;gt;= 1; } } for(var e: arr) sum += e; for(var i = 0; i &amp;lt; n; i++) { long tmp = 0; for(var j = 0; j &amp;lt; 30; j++) { if((arr[i] &amp;amp; 1 &amp;lt;&amp;lt; j) == 0) tmp += (1 &amp;lt;&amp;lt; j) * bitCnt[j]; else tmp += (1 &amp;lt;&amp;lt; j) * (n - bitCnt[j]); } sum = Math.max(sum, tmp); } println(sum); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. Regular Contest 135 B Sum of Three Terms", "url": "/posts/Atcoder-B-Sum-of-Three-Terms/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, XOR, Regular Contest", "date": "2022-02-14 02:32:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/arc135/tasks/arc135_bIDEA) First three elementimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static HashMap&amp;lt;Long, Long&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); static long mod = 998244353l; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr = getArr(); int iterThree = 0; long[] min = new long[3]; long[] store = new long[3]; for(int i = 0, len = arr.length; i &amp;lt; len - 1; i++) { int diff = arr[i + 1] - arr[i]; store[iterThree] += diff; min[iterThree] = Math.min(min[iterThree], store[iterThree]); if(++iterThree == 3) iterThree = 0; } long initThreeSum = 0; for(long e: min) initThreeSum += -1 * e; if(initThreeSum &amp;gt; arr[0]) sb.append(&quot;No&quot;); else { long[] ans = new long[n + 2]; ans[0] = -1 * min[0]; ans[1] = -1 * min[1]; ans[2] = arr[0] - ans[0] - ans[1]; for(int i = 3; i &amp;lt; n + 2; i++) { ans[i] = ans[i - 3] + arr[i - 2] - arr[i - 3]; } sb.append(&quot;Yes\\n&quot;); for(long l : ans) sb.append(l).append(&quot; &quot;); } println(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. Regular Contest 135 A Floor, Ceil Decomposition", "url": "/posts/Atcoder-A-Floor,-Ceil-Decomposition/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, Regular Contest", "date": "2022-02-14 02:32:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/arc135/tasks/arc135_aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static HashMap&amp;lt;Long, Long&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); static long mod = 998244353l; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); long x = tol(br.readLine()); println(getMax(x)); } static long getMax(long x) { if(hm.containsKey(x)) return hm.get(x); long lower = x / 2, upper = (x + 1) / 2; if((x &amp;amp; 1) == 1) { if(x &amp;gt;= 5) { long val = (getMax(lower) * getMax(upper)) % mod; hm.put(x, val); return val % mod; } else return x; } else { if(x &amp;gt;= 6) { long val = getMax(lower); val = (val * val) % mod; hm.put(x, val); return (val) % mod; } else return x; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Global Round 19 B. MEX and Array", "url": "/posts/Codeforces-Global-Round-19-B.-MEX-and-Array/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Codeforces, Codeforces Global Round, Review, Greedy, Math, MEX and Array", "date": "2022-02-13 11:30:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1637/problem/Bimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String line; int[] arr; int test = toi(br.readLine()); for(int iter = 0; iter &amp;lt; test; iter++) { int n = toi(br.readLine()); arr = getArr(); ArrayList&amp;lt;Integer&amp;gt; zeroIdxList = new ArrayList&amp;lt;&amp;gt;(); int ans = n * (n + 1) * (n + 2) / 6; for(int i = 0; i &amp;lt; n; i++) if(arr[i] == 0) zeroIdxList.add(i); ans += calc(zeroIdxList, n); sb.append(ans).append(&quot;\\n&quot;); } print(sb); } static int calc(ArrayList&amp;lt;Integer&amp;gt; al, int n) { int sum = 0; for(int idx: al) sum += (1 + idx) * (n - idx); return sum; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Idol (3648)", "url": "/posts/BOJ-3648/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, SCC, Strongly Connected Component, Idol, 아이돌, Review, Important", "date": "2022-02-13 10:10:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3648In order for Karl to go to the next roundMethod 1Tarjan is DFSSCC =&amp;gt; { x, -x } included in same scc || if(parent[1] &amp;gt; parent[-1]) =&amp;gt; can’t be solvedMethod 2add edge before getting sccNode[-1].add(1); =&amp;gt; if 1 =&amp;gt; 1 =&amp;gt; loop =&amp;gt; can’t be solvedimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int n; static Node[] nodes; static int sccIdx = 1; static int[] parent; static boolean[] finished; static boolean cantSolve = false; static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String line; int[] arr; while(true) { if((line = br.readLine()) == null) break; arr = Arrays.stream(line.split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); n = arr[0]; int m = arr[1]; nodes = new Node[2 * n]; parent = new int[2 * n]; finished = new boolean[2 * n]; cantSolve = false; sccIdx = 1; for(int i = 0; i &amp;lt; 2 * n; i++) nodes[i] = new Node(rev(i)); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0], b = arr[1]; nodes[convert(a * -1)].list.add(b); nodes[convert(b * -1)].list.add(a); } nodes[convert(-1)].list.add(1); for(int i = 0; i &amp;lt; 2 * n; i++) { if(parent[i] == 0) scc(i); } sb.append(cantSolve ? &quot;no&quot; : &quot;yes&quot;).append(&quot;\\n&quot;); } print(sb); } static int scc(int idx) { int origVal = parent[idx] = sccIdx++; stack.push(idx); for(int v : nodes[idx].list) { if(parent[convert(v)] == 0) parent[idx] = Math.min(parent[idx], scc(convert(v))); else if(!finished[convert(v)]) parent[idx] = Math.min(parent[idx], parent[convert(v)]); } if(origVal == parent[idx]) { HashSet&amp;lt;Integer&amp;gt; hm = new HashSet&amp;lt;&amp;gt;(); while(true) { int pop = stack.pop(); int revVal = rev(pop); finished[pop] = true; if(hm.contains(revVal * (-1))) cantSolve = true; hm.add(revVal); if(idx == pop) break; } } return parent[idx]; } static int convert(int val) { return val &amp;gt; 0 ? val - 1 : n - 1 - val; } static int rev(int idx) { return idx &amp;lt; n ? idx + 1 : n - 1 - idx; } static class Node { int idx; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Global Round 19 C. Andrew and Stones", "url": "/posts/Codeforces-Global-Round-19-C.-Andrew-and-Stones/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Codeforces Global Round, Codeforces, Andrew and Stones", "date": "2022-02-12 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1637/problem/Cimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int test = toi(br.readLine()); int[] arr; for(int iter = 0; iter &amp;lt; test; iter++) { int n = toi(br.readLine()); arr = getArr(); if(n == 3) { // l (odd) r sb.append((arr[1] &amp;amp; 1) == 1 ? -1 : arr[1]/2).append(&quot;\\n&quot;);; } else { // l 1...1 r boolean allOne = true; int oddCnt = 0; long sum = 0; for(int i = 1; i &amp;lt; n-1; i++) { if(arr[i] != 1) allOne = false; if((arr[i] &amp;amp; 1) == 1) oddCnt++; sum += arr[i]; } if(allOne) sb.append(-1); else sb.append((oddCnt + sum) / 2); sb.append(&quot;\\n&quot;); } } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Global Round 19 A. Sorting Parts", "url": "/posts/Codeforces-Global-Round-19-A.-Sorting-Parts/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Codeforces Global Round, Codeforces, Sorting Parts", "date": "2022-02-12 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1637/problem/Aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int test = toi(br.readLine()); int[] arr; for(int iter = 0; iter &amp;lt; test; iter++) { int n = toi(br.readLine()); arr = getArr(); boolean sorted = true; for(int i = 0; i &amp;lt; n - 1; i++) { if(arr[i] &amp;gt; arr[i + 1]) sorted = false; } sb.append(sorted ? &quot;NO\\n&quot; : &quot;YES\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "LeetCode. 100. Same Tree", "url": "/posts/Leetcode-100.-Same-Tree/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Same Tree", "date": "2022-02-12 19:33:00 +0900", "snippet": "[Link] https://leetcode.com/problems/same-tree//** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { return dfs(p, q); } boolean dfs(TreeNode p, TreeNode q) { if(p == null &amp;amp;&amp;amp; q == null) return true; if(p == null || q == null) return false; if(p.val != q.val) return false; if(!dfs(p.left, q.left)) return false; if(!dfs(p.right, q.right)) return false; return true; }}" }, { "title": "BOJ. 2-SAT - 3 (11280)", "url": "/posts/BOJ-11280/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Strongly Connected Component, Tarjan's algorithm, SCC, 2-SAT - 3, Review, Important, difficult", "date": "2022-02-12 11:13:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11280IDEA(N U M) = true &amp;lt;=&amp;gt; (!N =&amp;gt; M) || (M =&amp;gt; !N)[ 1~n, -1 ~ -n ] =&amp;gt; SCC =&amp;gt; (a =&amp;gt; b =&amp;gt; c … =&amp;gt; (-a)) =&amp;gt; can’t be solved(When SCC includes x and -x)import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int sccIdx = 1; static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); static int[] parent; static boolean[] finished; static boolean cantSolve = false; static Node[] nodes; static int n; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); n = arr[0]; int m = arr[1]; nodes = new Node[2 * n]; finished = new boolean[2 * n]; parent = new int[2 * n]; for(int i = 1; i &amp;lt;=n; i++) nodes[convert(i)] = new Node(i); for(int i = -n; i &amp;lt;= -1; i++) nodes[convert(i)] = new Node(i); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0], b = arr[1], bit1 = a &amp;gt; 0 ? 1 : -1, bit2 = b &amp;gt; 0 ? 1 : -1; nodes[convert((-1) * a)].list.add(b); nodes[convert((-1) * b)].list.add(a); } for(int j = 0; j &amp;lt; 2 * n ; j++) { if(parent[j] == 0) scc(j); if(cantSolve) { print(0); return; } } print(1); } //0 ~ (n-1) : 1 ~(n) || n ~ (2n - 1): -1 ~ -n static int convert(int idx) { return idx &amp;gt; 0 ? idx - 1 : n - 1 - idx; } static int rev(int idx) { return idx &amp;lt; n ? idx + 1 : n - 1 - idx; } static int scc(int idx) { int origVal = parent[idx] = sccIdx++; stack.push(idx); for(int e: nodes[idx].list) { if(parent[convert(e)] == 0) parent[idx] = Math.min(parent[idx], scc(convert(e))); else if(finished[convert(e)] == false) parent[idx] = Math.min(parent[idx], parent[convert(e)]); } if(origVal == parent[idx]) { HashSet&amp;lt;Integer&amp;gt; hs = new HashSet&amp;lt;&amp;gt;(); while(true) { int pop = stack.pop(); int rev = rev(pop); if(hs.contains((-1) * rev)) cantSolve = true; hs.add(rev); finished[pop] = true; if(pop == idx) break; } } return parent[idx]; } static class Node { int idx; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Domino (4196)", "url": "/posts/BOJ-4196/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Strongly Connected Component, Tarjan's algorithm, SCC, Domino, 도미노, Review, Important", "date": "2022-02-11 04:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/4196import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int sccIdx = 1; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int test = toi(br.readLine()); int[] arr; Domino[] dominoes; ArrayList&amp;lt;Edge&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); for(int iter = 0; iter &amp;lt; test; iter++) { arr = getArr(); int n = arr[0], m = arr[1]; dominoes = new Domino[n]; edges.clear(); for(int i = 0; i &amp;lt; n; i++) dominoes[i] = new Domino(i); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int x = arr[0] - 1, y = arr[1] - 1; edges.add(new Edge(x, y)); dominoes[x].list.add(dominoes[y]); } int[] parent = solve(dominoes); HashMap&amp;lt;Integer, Integer&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); for(int e: parent) if(!hm.containsKey(e)) hm.put(e, 0); for(Edge edge: edges) { int x = edge.from, y = edge.to; if(parent[x] == parent[y]) continue; hm.put(parent[y], hm.get(parent[y]) + 1); } int cnt = 0; for(HashMap.Entry&amp;lt;Integer, Integer&amp;gt; entry: hm.entrySet()) if(entry.getValue() == 0) cnt++; sb.append(cnt).append(&quot;\\n&quot;); } print(sb); } static class Edge { int from, to; public Edge(int from, int to) { this.from = from; this.to = to; } } static int[] solve(Domino[] dominoes) { int len = dominoes.length; boolean[] finish = new boolean[len]; int[] parent = new int[len]; Arrays.fill(parent, -1); sccIdx = 1; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(Domino domino : dominoes) { int v = domino.idx; if(parent[v] == -1) scc(domino, stack, finish, parent); } return parent; } static int scc(Domino domino, Stack&amp;lt;Integer&amp;gt; stack, boolean[] finish, int[] parent) { int idx = domino.idx; int origVal = parent[idx] = sccIdx++;; stack.push(idx); for(Domino adj: domino.list) { if(parent[adj.idx] == -1) parent[idx] = Math.min(parent[idx], scc(adj, stack, finish, parent)); else if(finish[adj.idx] == false) parent[idx] = Math.min(parent[idx], parent[adj.idx]); } if(origVal == parent[idx]) { while(true) { int popped = stack.pop(); finish[popped] = true; if(popped == idx) break; } } return parent[idx]; } static class Domino { int idx; ArrayList&amp;lt;Domino&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Domino(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Soccer Tactics (3977)", "url": "/posts/BOJ-3977/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Strongly Connected Component, Tarjan's algorithm, SCC, Soccer Tactics, 축구 전술", "date": "2022-02-11 04:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3977import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int sccIdx = 1, groupIdx = 0; static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); static int[] parent; static int[] group; static boolean[] finished; static Node[] nodes; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); ArrayList&amp;lt;Edge&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); int test = toi(br.readLine()); int[] arr; for(int iter = 0; iter &amp;lt; test; iter++) { arr = getArr(); int n = arr[0], m = arr[1]; parent = new int[n]; group = new int[n]; Arrays.fill(parent, -1); edges.clear(); finished = new boolean[n]; nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0], b = arr[1]; nodes[a].list.add(b); edges.add(new Edge(a, b)); } sccIdx = 1; groupIdx = 0; for(int i = 0; i &amp;lt; n; i++) { if(parent[i] == -1) scc(i); } int[] deg = new int[groupIdx]; for(Edge edge: edges) { int a = edge.from, b = edge.to; if(group[a] == group[b]) continue; deg[group[b]]++; } int degZeroCnt = 0, degZeroIdx = 0; for(int i = 0; i &amp;lt; groupIdx; i++) { if(deg[i] == 0) { degZeroCnt++; degZeroIdx = i; } } if(degZeroCnt != 1) sb.append(&quot;Confused\\n&quot;); else { ArrayList&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) if(group[i] == degZeroIdx) tmp.add(i); Collections.sort(tmp); for(int e: tmp) sb.append(e).append(&quot;\\n&quot;); } sb.append(&quot;\\n&quot;); if(iter != test - 1) br.readLine(); } print(sb); } static int scc(int idx) { int origVal = parent[idx] = sccIdx++; stack.push(idx); for(int v: nodes[idx].list) { if(parent[v] == -1) parent[idx] = Math.min(parent[idx], scc(v)); else if(finished[v] == false) parent[idx] = Math.min(parent[idx], parent[v]); } if(parent[idx] == origVal) { while(true) { int pop = stack.pop(); finished[pop] = true; group[pop] = groupIdx; if(pop == idx) break; } groupIdx++; } return parent[idx]; } static class Node { int idx; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static class Edge { int from, to; public Edge(int from, int to) { this.from = from; this.to = to; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Tree and Query 2 (13511)", "url": "/posts/BOJ-13511/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Sparse table, Lowest Common Ancestor, LCA, Tree and Query 2, 트리와 쿼리 2, Review, Important", "date": "2022-02-11 04:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/13511import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int log, n; static long[][] costArr; static int[][] parent; static Node[] nodes; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); n = toi(br.readLine()); log = (int)(Math.log(n) / Math.log(2)) + 1; nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); int[] arr; for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1, cost = arr[2]; nodes[a].list.add(new Edge(nodes[b], cost)); nodes[b].list.add(new Edge(nodes[a], cost)); } costArr = new long[n][log + 1]; parent = new int[n][log + 1]; for(long[] ar: costArr)Arrays.fill(ar, -1); for(int[] ar: parent)Arrays.fill(ar, -1); initSparseDFS(nodes[0]); fillSparseParent(); fillSparseCost(); int m = toi(br.readLine()); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[1] - 1, b = arr[2] - 1; if(arr[0] == 1) { // costArr from a to b sb.append(getCost(a, b)).append(&quot;\\n&quot;); } else { // in path a~b : k th point sb.append(getKthVertext(a, b, arr[3]) + 1).append(&quot;\\n&quot;); } } print(sb); } static long getCost(int a, int b) { long cost = 0l; if(nodes[a].depth &amp;lt; nodes[b].depth) { int tmp = a; a = b; b = tmp; } for(int i = log; i &amp;gt;= 0; i--) if(nodes[a].depth - nodes[b].depth &amp;gt;= 1 &amp;lt;&amp;lt; i) { cost += costArr[a][i]; a = parent[a][i]; } if(a == b) return cost; for(int i = log; i &amp;gt;= 0; i--) { if(parent[a][i] != parent[b][i]) { cost += (costArr[a][i] + costArr[b][i]); a = parent[a][i]; b = parent[b][i]; } } return cost + costArr[a][0] + costArr[b][0]; } static int getKthVertext(int a, int b, int targetIdx) { int nth = 1; boolean swapped = false; if(nodes[a].depth &amp;lt; nodes[b].depth) { int tmp = a; a = b; b = tmp; swapped = true; } int origB = b, origA = a; for(int i = log; i &amp;gt;= 0; i--) if(nodes[a].depth - nodes[b].depth &amp;gt;= 1 &amp;lt;&amp;lt; i) { nth += (1 &amp;lt;&amp;lt; i); a = parent[a][i]; } int elavateCnt = 0; if(a != b) { for(int i = log; i &amp;gt;= 0; i--) { if(parent[a][i] != parent[b][i]) { a = parent[a][i]; b = parent[b][i]; elavateCnt += (1 &amp;lt;&amp;lt; i); } } elavateCnt++; } int totalLen = nth + 2 * elavateCnt; if(swapped) targetIdx = totalLen + 1 - targetIdx; if(nth + elavateCnt &amp;gt;= targetIdx) { nth = 1; for(int i = log; i &amp;gt;= 0; i--) { if(targetIdx - nth &amp;gt;= 1 &amp;lt;&amp;lt; i) { nth += (1 &amp;lt;&amp;lt; i); origA = parent[origA][i]; } } return nodes[origA].idx; } // From nth + elavateCnt =&amp;gt; 2 * elavateCnt + nth, targetIdx =&amp;gt; targetIdx = totalLen + 1 - targetIdx; nth = 1; for(int i = log; i &amp;gt;= 0; i--) { if(targetIdx - nth &amp;gt;= 1 &amp;lt;&amp;lt; i) { nth += (1 &amp;lt;&amp;lt; i); origB = parent[origB][i]; } } return nodes[origB].idx; } static void initSparseDFS(Node node) { for(Edge edge: node.list) { if(node.parent == edge.to.idx) continue; edge.to.parent = node.idx; parent[edge.to.idx][0] = node.idx; costArr[edge.to.idx][0] = (long)edge.cost; edge.to.depth = node.depth + 1; initSparseDFS(edge.to); } } static void fillSparseParent() { for(int j = 1; j &amp;lt;= log; j++) { for(int i = 0; i &amp;lt; n; i++) { if(parent[i][j - 1] != -1) parent[i][j] = parent[parent[i][j - 1]][j - 1]; } } } static void fillSparseCost() { for(int j = 1; j &amp;lt;= log; j++) { for(int i = 0; i &amp;lt; n; i++) { if(parent[i][j] != - 1) costArr[i][j] = costArr[i][j - 1] + costArr[parent[i][j - 1]][j - 1]; } } } static class Node { int idx; int parent = -1; int depth = 0; ArrayList&amp;lt;Edge&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static class Edge { Node to; int cost; public Edge(Node to, int cost) { this.to = to; this.cost = cost; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Palindrome Devision (1509)", "url": "/posts/BOJ-1509/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Sparse table, Lowest Common Ancestor, Palindrome Devision, 팰린드롬 분할, Review, Important, difficult", "date": "2022-02-10 01:42:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1509import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int INF = 987654321; static int pal[][]; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); int len = str.length(); int[][] dp = new int[len][len]; pal = new int[len][len]; for(int[] ar: dp) Arrays.fill(ar, INF); for(int[] ar: pal) Arrays.fill(ar, -1); int ans = solve(dp, str, 0, len - 1); print(ans); } static int solve(int[][] dp, String str, int l, int r) { if(dp[l][r] != INF) return dp[l][r]; if(isPalindrome(str, l, r)) return dp[l][r] = 1; int min = INF; for(int idx = l + 1; idx &amp;lt;= r; idx++) { if(isPalindrome(str, idx, r)) { min = Math.min(min, solve(dp, str, l, idx - 1)); } } return dp[l][r] = min + 1; } static boolean isPalindrome(String s, int l , int r) { if(pal[l][r] != -1) return pal[l][r] == 1 ? true : false; int origL = l, origR = r; while(l &amp;lt; r) { if(s.charAt(l++) != s.charAt(r--)) { pal[origL][origR] = 0; return false; } } pal[origL][origR] = 1; return true; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Find Minimum (11003)", "url": "/posts/BOJ-11003/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Find Minimum, Deque", "date": "2022-02-09 17:40:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11003import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); StringBuilder sb = new StringBuilder(); int n = atoi(split[0]), l = atoi(split[1]), minIdx = 0; Deque&amp;lt;Nidx&amp;gt; q = new ArrayDeque&amp;lt;&amp;gt;(); split = br.readLine().split(&quot; &quot;); for(int i = 0; i &amp;lt; n; i++) { if(!q.isEmpty() &amp;amp;&amp;amp; q.peek().idx &amp;lt;= i - l) q.poll(); while(!q.isEmpty() &amp;amp;&amp;amp; q.peekLast().val &amp;gt;= atoi(split[i])) q.pollLast(); q.add(new Nidx(atoi(split[i]), i)); sb.append(q.peek().val + &quot; &quot;); } System.out.println(sb); } static class Nidx{ int val; int idx; public Nidx(int val, int idx) { this.val = val; this.idx = idx; } } static int atoi(String s) { return Integer.parseInt(s); }}" }, { "title": "BOJ. Road Network (3176)", "url": "/posts/BOJ-3176/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Sparse table, Lowest Common Ancestor, LCA, Road Network, 도로 네트워크, Review, Important, difficult", "date": "2022-02-09 08:03:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3176import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int log = (int)(Math.log(100000) / Math.log(2)); static Node[] nodes; static ArrayList&amp;lt;HashMap&amp;lt;Integer, Integer&amp;gt;&amp;gt; edges; static int[][] parent; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr; nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); edges = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) edges.add(new HashMap&amp;lt;Integer, Integer&amp;gt;()); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1, c = arr[2]; edges.get(a).put(b, c); edges.get(b).put(a, c); nodes[a].list.add(nodes[b]); nodes[b].list.add(nodes[a]); } int[][] minArr = new int[n][log + 1]; int[][] maxArr = new int[n][log + 1]; parent = new int[n][log + 1]; for(int[] ar: minArr) Arrays.fill(ar, -1); for(int[] ar: maxArr) Arrays.fill(ar, -1); for(int[] ar: parent) Arrays.fill(ar, -1); dfs(nodes[0], minArr, maxArr); fillSperseTable(parent); fillMax(maxArr, parent); fillMin(minArr, parent); int k = toi(br.readLine()); for(int i = 0; i &amp;lt; k; i++) { arr = getArr(); int d = arr[0] - 1, e = arr[1] - 1; int lca = lca(parent, d, e); int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; int df1 = nodes[lca].depth - nodes[d].depth; int df2 = nodes[lca].depth - nodes[e].depth; for(int j = log; j &amp;gt;= 0; j--) { if(nodes[d].depth - nodes[lca].depth &amp;gt;= 1 &amp;lt;&amp;lt; j) { min = Math.min(min, minArr[d][j]); max = Math.max(max, maxArr[d][j]); d = parent[d][j]; } if(nodes[e].depth - nodes[lca].depth &amp;gt;= 1 &amp;lt;&amp;lt; j) { min = Math.min(min, minArr[e][j]); max = Math.max(max, maxArr[e][j]); e = parent[e][j]; } } sb.append(min).append(&quot; &quot;).append(max).append(&quot;\\n&quot;); } print(sb); } static int lca(int[][] parent, int a, int b) { if(nodes[a].depth &amp;lt; nodes[b].depth) { int tmp = a; a = b; b = tmp; } for(int i = log; i &amp;gt;= 0; i--) { if(nodes[a].depth - nodes[b].depth &amp;gt;= 1 &amp;lt;&amp;lt; i) a = parent[a][i]; } if(a == b) return a; for(int i = log; i &amp;gt;= 0; i--) { if(parent[a][i] != parent[b][i]) { a = parent[a][i]; b = parent[b][i]; } } return parent[a][0]; } static void fillMax(int[][] maxArr, int[][] parent) { for(int j = 1; j &amp;lt;= log; j++) { for(int i = 0; i &amp;lt; maxArr.length; i++) { if(parent[i][j - 1] == -1 || parent[i][j] == -1) maxArr[i][j] = -1; else maxArr[i][j] = Math.max(maxArr[i][j - 1], maxArr[parent[i][j - 1]][j - 1]); } } } static void fillMin(int[][] minArr, int[][] parent) { for(int j = 1; j &amp;lt;= log; j++) { for(int i = 0; i &amp;lt; minArr.length; i++) { if(parent[i][j - 1] == -1 || parent[i][j] == -1) minArr[i][j] = Integer.MAX_VALUE; else minArr[i][j] = Math.min(minArr[i][j - 1], minArr[parent[i][j - 1]][j - 1]); } } } static void fillSperseTable(int[][] sperse) { for(int j = 1; j &amp;lt;= log; j++) { for(int i = 0; i &amp;lt; sperse.length; i++) { if(sperse[i][j - 1] == -1) continue; sperse[i][j] = sperse[sperse[i][j - 1]][j - 1]; } } } static void dfs(Node node, int[][] minArr, int[][] maxArr) { for(Node child : node.list) { if(node.parent == child.idx) continue; minArr[child.idx][0] = maxArr[child.idx][0] = edges.get(node.idx).get(child.idx); parent[child.idx][0] = node.idx; child.depth = node.depth + 1; child.parent = node.idx; dfs(child, minArr, maxArr); } } static class Node { int idx; int parent = -1; int depth = 0; ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. LCA 2 (11438)", "url": "/posts/BOJ-11438/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Sparse table, Lowest Common Ancestor, LCA, LCA 2, Review, Important", "date": "2022-02-09 05:28:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11438import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int log; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr; Node[] nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); log = (int)(Math.log(100000) / Math.log(2)); int[][] disperse_parent = new int[n][log + 1]; for(int[] ar: disperse_parent) Arrays.fill(ar, -1); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; nodes[a].list.add(nodes[b]); nodes[b].list.add(nodes[a]); } dfs(nodes[0], disperse_parent); getDT(disperse_parent); int m = toi(br.readLine()); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; sb.append(lca(disperse_parent, nodes, a, b) + 1).append(&quot;\\n&quot;); } print(sb); } static int lca(int[][] disperse_parent, Node[] nodes, int a, int b) { if(nodes[a].depth &amp;lt; nodes[b].depth) { int tmp = a; a = b; b = tmp; } for(int i = log; i &amp;gt;= 0; i--) { if(nodes[a].depth - nodes[b].depth &amp;gt;= (1 &amp;lt;&amp;lt; i)) a = disperse_parent[a][i]; } if(a == b) return a; for(int i = log; i &amp;gt;= 0; i--) { if(disperse_parent[a][i] != disperse_parent[b][i]) { a = disperse_parent[a][i]; b = disperse_parent[b][i]; } } return disperse_parent[a][0]; } static void getDT(int[][] disperse_parent) { for(int j = 1; j &amp;lt;= log; j++) { for(int i = 0; i &amp;lt; disperse_parent.length; i++) { if(disperse_parent[i][j - 1] == -1) continue; disperse_parent[i][j] = disperse_parent[disperse_parent[i][j - 1]][j - 1]; } } } static void dfs(Node node, int[][] disperse_parent) { for(Node child : node.list) { if(node.parent == child.idx) continue; disperse_parent[child.idx][0] = node.idx; child.parent = node.idx; child.depth = node.depth + 1; dfs(child, disperse_parent); } } static class Node { int idx; int parent = -1; int depth = 0; ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Composite Function And Query (17435)", "url": "/posts/BOJ-17435/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Sparse table, Composite Function And Query, 합성함수와 쿼리, Review, Important", "date": "2022-02-08 17:13:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17435import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int[] arr; int m = toi(br.readLine()); int[] y = new int[m + 1]; int n = (int)(Math.log(m) / Math.log(2)); // int[][] sparse = new int[m + 1][11]; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; sparse = new ArrayList&amp;lt;&amp;gt;(); sparse.add(new ArrayList&amp;lt;&amp;gt;()); arr = getArr(); for(int i = 0; i &amp;lt; m; i++) { ArrayList&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); tmp.add(arr[i]); sparse.add(tmp); } int query = toi(br.readLine()); for(int i = 0; i &amp;lt; query; i++) { arr = getArr(); int num = arr[0], x = arr[1]; int digit = 0, ans = x; while(num &amp;gt; 0) { if((num &amp;amp; 1) == 1) { if(sparse.get(1).size() &amp;lt;= digit) { for(int j = sparse.get(1).size() ; j &amp;lt;= digit ; j++) { for(int idx = 1; idx &amp;lt;= m; idx++) { sparse.get(idx).add(sparse.get(sparse.get(idx).get(j - 1)).get(j - 1)); } } } ans = sparse.get(ans).get(digit); } num &amp;gt;&amp;gt;= 1; digit++; } sb.append(ans).append(&quot;\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Lowest Common Ancestor (3584)", "url": "/posts/BOJ-3584/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Bitmask, Lowest Common Ancestor, LCA, 가장 가까운 공통 조상", "date": "2022-02-08 14:35:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3584Common Dynamic Progrmming SolutionCommon Dynamic Progrmming Solutionimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] containsV1; static int[] containsV2; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int t = toi(br.readLine()); Node[] nodes; int[] arr; for(int iter = 0; iter &amp;lt; t; iter++) { int n = toi(br.readLine()); nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); containsV1 = new int[n]; containsV2 = new int[n]; Arrays.fill(containsV1, -1); Arrays.fill(containsV2, -1); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; nodes[a].list.add(nodes[b]); nodes[b].parent = a; } int rootIdx = 0; for(int i = 0; i &amp;lt; n; i++) { if(nodes[i].parent == -1) { rootIdx = i; break; } } arr = getArr(); sb.append(getCommonParent(nodes[rootIdx], arr[0] - 1, arr[1] - 1) + 1).append(&quot;\\n&quot;); } print(sb); } static int getCommonParent(Node node, int a, int b) { int store = 0; while(true) { boolean next = false; for(Node child: node.list) { if(contains1(child, a) == 1 &amp;amp;&amp;amp; contains2(child, b) == 1) { node = child; next = true; } } if(!next) break; } return node.idx; } static int contains1(Node node, int idx) { if(containsV1[idx] != -1) return containsV1[node.idx]; if(node.idx == idx) return containsV1[node.idx] = 1; for(Node e : node.list) { if(contains1(e, idx) == 1) return containsV1[node.idx] = 1; } return containsV1[node.idx] = 0; } static int contains2(Node node, int idx) { if(containsV2[idx] != -1) return containsV2[node.idx]; if(node.idx == idx) return containsV2[node.idx] = 1; for(Node e : node.list) { if(contains2(e, idx) == 1) return containsV2[node.idx] = 1; } return containsV2[node.idx] = 0; } static class Node { int idx; int parent = -1; ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. SeongYeon Park (1086)", "url": "/posts/BOJ-1086/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Bitmask, SeongYeon Park, 박성원, Review, Important, difficult", "date": "2022-02-08 04:32:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1086import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static ArrayList&amp;lt;Integer&amp;gt; expdp; static int n; static int k; static String[] line; static int[] convert; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); n = toi(br.readLine()); line = new String[n]; convert = new int[n]; Arrays.fill(convert, -1); int l = 0; for(int i = 0; i &amp;lt; n; i++) { line[i] = br.readLine(); l += line[i].length(); } k = toi(br.readLine()); long[][] dp = new long[k][1 &amp;lt;&amp;lt; n]; for(long[] ar: dp) Arrays.fill(ar, -1); expdp = new ArrayList&amp;lt;&amp;gt;(); expdp.add(1); long num = dfs(dp, 0, (1 &amp;lt;&amp;lt; n) - 1, l); printProb(num); } static int convert(int idx) { if(convert[idx] != -1) return convert[idx]; int sum = 0; String s = line[idx]; for(int i = 0; i &amp;lt; s.length(); i++) sum = (sum * 10 + s.charAt(i) - &#39;0&#39;) % k; return convert[idx] = sum; } static long dfs(long[][] dp, int remain, int bitmask, int len) { if(dp[remain][bitmask] != -1) return dp[remain][bitmask]; if(bitmask == 0) return dp[remain][bitmask] = (remain == 0 ? 1 : 0); int bit = 1; long sum = 0; for(int i = 1; i &amp;lt;= n; i++) { if((bitmask &amp;amp; bit) == 0) { bit &amp;lt;&amp;lt;= 1; continue; } int ll = len - line[i - 1].length(); int pair = remain - (convert(i - 1) * tenExp(ll) % k); if(pair == k) pair = 0; if(pair &amp;lt; 0) pair += k; if(dfs(dp, pair, bitmask ^ bit, ll) != -1) sum += dfs(dp, pair, bitmask ^ bit, ll); bit &amp;lt;&amp;lt;= 1; } return dp[remain][bitmask] = sum; } static void printProb(long num) { if(num == 0) { print(&quot;0/1&quot;); return; } long denominator = 1; for(int i = 2; i &amp;lt;= n; i++) denominator *= i; long gcd = gcd(num, denominator); denominator /= gcd; num /= gcd; print(num + &quot;/&quot; + denominator); } static long gcd(long a, long b) { long max = Math.max(a, b), min = Math.min(a, b); while(true) { long re = max % min; if(re == 0) break; max = min; min = re; } return min; } static int tenExp(int n) { if(expdp.size() &amp;gt;= n + 1) return expdp.get(n); int idx = expdp.size(); int tmp = expdp.get(idx - 1); while(idx &amp;lt;= n) { tmp = (tmp * 10) % k; expdp.add(tmp); idx++; } return tmp; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Round 770 (Div. 2) B. Fortune Telling", "url": "/posts/Codeforces-Round-770-(Div.-2)-B.-Fortune-Telling/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Div 2, Codeforces, Fortune Telling", "date": "2022-02-07 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1634/problem/Bimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int t = toi(br.readLine()); long[] arr; for(int iter = 0; iter &amp;lt; t; iter++) { arr = getArr2(); long n = arr[0], x = arr[1], y = arr[2]; //n =&amp;gt; y int[] a = getArr(); boolean yIsOdd = (y &amp;amp; 1) == 1; boolean xIsOdd = (x &amp;amp; 1) == 1; boolean parityChange = false; for(int e : a) { if((e &amp;amp; 1) == 1) parityChange = !parityChange; } if(yIsOdd == xIsOdd) { sb.append(parityChange ? &quot;Bob&quot; : &quot;Alice&quot;).append(&quot;\\n&quot;); } else sb.append(parityChange ? &quot;Alice&quot; : &quot;Bob&quot;).append(&quot;\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static long[] getArr2() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToLong(Long::parseLong).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Codeforces Round 770 (Div. 2) A. Reverse and Concatenate", "url": "/posts/Codeforces-Round-770-(Div.-2)-A.-Reverse-and-Concatenate/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, Codeforces, Div 2, Reverse and Concatenate", "date": "2022-02-07 23:35:00 +0900", "snippet": "[Link] https://codeforces.com/contest/1634/problem/Aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int t = toi(br.readLine()); int[] arr; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int iter = 0; iter &amp;lt; t; iter++) { arr = getArr(); int n = arr[0], k = arr[1]; String s = br.readLine(); if(isPalindrome(s) || k == 0) { sb.append(&quot;1\\n&quot;); } else { sb.append(&quot;2\\n&quot;); } } print(sb); } static boolean isPalindrome(String s) { int l = 0, r = s.length() - 1; while(l &amp;lt; r) { if(s.charAt(l) != s.charAt(r)) return false; l++; r--; } return true; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Traveling Salesman problem (2098)", "url": "/posts/BOJ-2098/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Bitmask, Traveling Salesman problem, TSP, 외판원 순회", "date": "2022-02-07 17:53:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2098import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[][] dis; static int n; static int INF = 987654321; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); n = toi(br.readLine()); int[] arr; dis = new int[n + 1][n + 1]; for(int i = 1; i &amp;lt;= n; i++) { arr = getArr(); for(int j = 1; j &amp;lt;= n; j++) dis[i][j] = arr[j - 1]; } int[][] dp = new int[n + 1][1 &amp;lt;&amp;lt; n]; for(int[] ar: dp) Arrays.fill(ar, INF); print(dfs(dp, 1, 1)); } static int dfs(int[][] dp, int idx, int bitmask) { if(dp[idx][bitmask] != INF) return dp[idx][bitmask]; if(bitmask == (1 &amp;lt;&amp;lt; n) - 1) { return dis[idx][1] == 0 ? INF : dis[idx][1]; } int bit = 2; //b10 int townIdx = 2; for(int i = 2; i &amp;lt;= n; i++) { if((bit &amp;amp; bitmask) == 0 &amp;amp;&amp;amp; dis[idx][townIdx] != 0) dp[idx][bitmask] = Math.min(dp[idx][bitmask], dfs(dp, townIdx, bitmask | bit) + dis[idx][townIdx]); bit &amp;lt;&amp;lt;= 1; townIdx++; } return dp[idx][bitmask]; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. RGB Distance 2 (17404)", "url": "/posts/BOJ-17404/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, RGB Distance 2, RGB거리 2", "date": "2022-02-07 02:30:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17404import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr; int[][] dp0 = new int[n + 1][3]; int[][] dp1 = new int[n + 1][3]; int[][] dp2 = new int[n + 1][3]; for(int[] ar: dp0) Arrays.fill(ar, 55555555); for(int[] ar: dp1) Arrays.fill(ar, 55555555); for(int[] ar: dp2) Arrays.fill(ar, 55555555); arr = getArr(); dp0[1][0] = arr[0]; dp1[1][1] = arr[1]; dp2[1][2] = arr[2]; for(int i = 2; i &amp;lt; n; i++) { arr = getArr(); dp0[i][0] = Math.min(dp0[i-1][1], dp0[i-1][2]) + arr[0]; dp0[i][1] = Math.min(dp0[i-1][0], dp0[i-1][2]) + arr[1]; dp0[i][2] = Math.min(dp0[i-1][0], dp0[i-1][1]) + arr[2]; dp1[i][0] = Math.min(dp1[i-1][1], dp1[i-1][2]) + arr[0]; dp1[i][1] = Math.min(dp1[i-1][0], dp1[i-1][2]) + arr[1]; dp1[i][2] = Math.min(dp1[i-1][0], dp1[i-1][1]) + arr[2]; dp2[i][0] = Math.min(dp2[i-1][1], dp2[i-1][2]) + arr[0]; dp2[i][1] = Math.min(dp2[i-1][0], dp2[i-1][2]) + arr[1]; dp2[i][2] = Math.min(dp2[i-1][0], dp2[i-1][1]) + arr[2]; } arr = getArr(); ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); al.add(dp0[n - 1][0] + arr[1]); al.add(dp0[n - 1][2] + arr[1]); al.add(dp0[n - 1][0] + arr[2]); al.add(dp0[n - 1][1] + arr[2]); al.add(dp1[n - 1][1] + arr[0]); al.add(dp1[n - 1][2] + arr[0]); al.add(dp1[n - 1][0] + arr[2]); al.add(dp1[n - 1][1] + arr[2]); al.add(dp2[n - 1][1] + arr[0]); al.add(dp2[n - 1][2] + arr[0]); al.add(dp2[n - 1][0] + arr[1]); al.add(dp2[n - 1][2] + arr[1]); println(Collections.min(al)); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Final Ranking (3665)", "url": "/posts/BOJ-3665/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Topological Sort, Final Ranking, 최종 순위", "date": "2022-02-06 22:48:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3665import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int div = 998244353; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int test = toi(br.readLine()); int[] arr; for(int iter = 0; iter &amp;lt; test; iter++) { arr = getArr(); int a = (arr[0] % 10), b = arr[1]; if(a == 0) { sb.append(&quot;10\\n&quot;); continue; } int t = getT(a, 10); b = b % t; int ans = a; if(b == 0) b = t; for(int i = 1; i &amp;lt; b; i++) ans = (ans * a) % 10; sb.append(ans == 0 ? 10 : ans).append(&quot;\\n&quot;); } print(sb); } static int getT(int a, int mod) { int val = (a * a) % mod, t = 1; while(val != a) { val = (val * a) % mod; t++; } return t; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Workbook (1766)", "url": "/posts/BOJ-1766/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Topological Sort, Workbook, 문제집", "date": "2022-02-06 18:10:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1766import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int[] arr = getArr(); int n = arr[0], m = arr[1]; int[] deg = new int[n]; boolean[] visit = new boolean[n]; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) edges.add(new ArrayList&amp;lt;Integer&amp;gt;()); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; edges.get(a).add(b); deg[b]++; } PriorityQueue&amp;lt;Integer&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { if(visit[i]) continue; q.add(i); while(!q.isEmpty()) { int cur = q.poll(); if(visit[cur] || deg[cur] != 0) continue; visit[cur] = true; sb.append(cur + 1).append(&quot; &quot;); for(int v: edges.get(cur)) { if(--deg[v] == 0) { q.add(v); } } } } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Distributed Processing (1009)", "url": "/posts/BOJ-1009/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Distributed Processing, 분산처리", "date": "2022-02-06 00:39:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1009import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int div = 998244353; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int test = toi(br.readLine()); int[] arr; for(int iter = 0; iter &amp;lt; test; iter++) { arr = getArr(); int a = (arr[0] % 10), b = arr[1]; if(a == 0) { sb.append(&quot;10\\n&quot;); continue; } int t = getT(a, 10); b = b % t; int ans = a; if(b == 0) b = t; for(int i = 1; i &amp;lt; b; i++) ans = (ans * a) % 10; sb.append(ans == 0 ? 10 : ans).append(&quot;\\n&quot;); } print(sb); } static int getT(int a, int mod) { int val = (a * a) % mod, t = 1; while(val != a) { val = (val * a) % mod; t++; } return t; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 238 C digitnum", "url": "/posts/Atcoder-C-digitnum/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-02-05 09:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc238/tasks/abc238_cimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int div = 998244353; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); long n = tol(br.readLine()), ndiv = n % div; long sum = (ndiv * (ndiv + 1) / 2) % div; long ans = sum - getDigit(n) + ndiv; if(ans &amp;lt; 0) ans += div; println(ans % div); } static long getDigit(long n) { int len = String.valueOf(n).length(); long tenExp = 1l, remainder = 0l, tenExpDiv = 0l; for(int i = 1; i &amp;lt; len; i++) { tenExpDiv = tenExp % div; remainder += (((tenExpDiv * tenExpDiv) % div) * 9) % div; remainder %= div; tenExp = tenExp * 10; } tenExpDiv = tenExp % div; remainder += (tenExpDiv * ((n - tenExp + 1) % div)) % div; remainder %= div; return remainder; } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 238 B Pizza", "url": "/posts/Atcoder-B-Pizza/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-02-05 09:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc238/tasks/abc238_bimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int div = 1000000003; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] a = getArr(); int[] deg = new int[n + 1]; for(int i = 1; i &amp;lt;= n; i++) { deg[i] = deg[i-1] + a[i - 1]; if(deg[i] &amp;gt;= 360) deg[i] -= 360; } Arrays.sort(deg); int max = -1; for(int i = 0; i &amp;lt; n; i++) { max = Math.max(max, deg[i + 1] - deg[i]); } max = Math.max(max, 360 - deg[n]); println(max); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 238 A Exponential or Quadratic", "url": "/posts/Atcoder-A-Exponential-or-Quadratic/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-02-05 09:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc238/tasks/abc238_aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int div = 1000000003; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); if(n &amp;gt; 4 || n == 1) println(&quot;Yes&quot;); else println(&quot;No&quot;); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Hue Circle (2482)", "url": "/posts/BOJ-2482/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Hue Circle, 색상환", "date": "2022-02-04 00:17:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2482import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int div = 1000000003; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()), k = toi(br.readLine()); int[][] dp = new int[n + 1][n + 1]; for(int[] ar: dp) Arrays.fill(ar, -1); int ans = (dfs(dp, n - 3, k - 1) + dfs(dp, n - 1, k)) % div; print(ans); } static int dfs(int[][] dp, int len, int num) { if(num &amp;gt; (len + 1) / 2) return 0; if(num == 0) return 1; if(num == 1) return len; if(dp[len][num] != -1) return dp[len][num]; return dp[len][num] = (dfs(dp, len - 2, num - 1) + dfs(dp, len - 1, num)) % div; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. ACM Craft (1005)", "url": "/posts/BOJ-1005/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Topological Sort, Graph, ACM Craft", "date": "2022-02-03 22:17:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1005import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int test = toi(br.readLine()); int[] cost; int[] line; Node[] nodes; for(int iter = 0; iter &amp;lt; test; iter++) { line = getArr(); int n = line[0], k = line[1]; cost = getArr(); nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i, cost[i]); for(int i = 0; i &amp;lt; k; i++) { line = getArr(); int a = line[0] - 1, b = line[1] - 1; nodes[b].deg++; nodes[a].list.add(nodes[b]); } int haveToBuild = toi(br.readLine()) - 1; Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); int min = Integer.MAX_VALUE; for(int i = 0; i &amp;lt; n; i++) { if(nodes[i].init || nodes[i].deg != 0) continue; q.add(nodes[i]); while(!q.isEmpty()) { Node node = q.poll(); for(Node next: node.list) { if(next.init) { next.min = Math.max(next.min, node.min + cost[next.idx]); if(--next.deg == 0) q.add(next); } else { next.min = node.min + cost[next.idx]; if(--next.deg == 0) q.add(next); next.init = true; } } } } sb.append(nodes[haveToBuild].min).append(&quot;\\n&quot;); } print(sb); } static class Node { ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); int deg; int min; int idx; boolean init; Node(int idx, int min) { this.idx = idx; this.min = min; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Advertisement (1305)", "url": "/posts/BOJ-1305/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, KMP, String, Advertisement, 광고", "date": "2022-02-03 07:33:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1305import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] fdp; static int[] edp; static int[] w; static boolean[] visit; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); String line = br.readLine(); int[] pi = getPi(line); print(line.length() - pi[line.length() - 1]); } static int[] getPi(String s) { int l = 0, len = s.length(); int[] pi = new int[len]; for(int r = 1; r &amp;lt; len; r++) { while(s.charAt(l) != s.charAt(r) &amp;amp;&amp;amp; l &amp;gt; 0) l = pi[l - 1]; if(s.charAt(l) == s.charAt(r)) { pi[r] = ++l; } } return pi; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Independent Set of Tree. (2213)", "url": "/posts/BOJ-2213/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Graph, Dynamic Programming, Independent Set of Tree., 트리의 독립집합", "date": "2022-02-02 13:02:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2213import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] fdp; static int[] edp; static int[] w; static boolean[] visit; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr; Node[] nodes = new Node[n]; w = getArr(); edp = new int[n]; fdp = new int[n]; for(int i = 0; i &amp;lt; n; i++) fdp[i] = w[i]; visit = new boolean[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; nodes[a].list.add(nodes[b]); nodes[b].list.add(nodes[a]); } nodes[0].parent = -1; bfs(nodes[0]); int ans = Math.max(edp[0], fdp[0]); Node node = nodes[0]; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); println(ans); getVertext(ans, node, al); Collections.sort(al); for(int e: al) sb.append(e).append(&quot; &quot;); print(sb); } static void getVertext(int val, Node node, ArrayList&amp;lt;Integer&amp;gt; al) { int sum = w[node.idx]; if(val == sum) { al.add(node.idx + 1); return; } if(val == 0) return; for(Node nn: node.list) { if(nn.idx == node.parent) continue; sum += edp[nn.idx]; } if(sum == val) { al.add(node.idx + 1); for(Node nn: node.list) { if(nn.idx == node.parent) continue; getVertext(edp[nn.idx], nn, al); } } else { for(Node nn: node.list) { if(nn.idx == node.parent) continue; getVertext(Math.max(edp[nn.idx], fdp[nn.idx]), nn, al); } } } static void bfs(Node node) { if(node.list.size() == 1 &amp;amp;&amp;amp; node.parent != -1) { return; } for(Node child: node.list) { if(child.idx == node.parent) continue; child.parent = node.idx; if(!visit[child.idx]) bfs(child); fdp[node.idx] += edp[child.idx]; edp[node.idx] += Math.max(edp[child.idx], fdp[child.idx]); } visit[node.idx] = true; } static class Node { int idx; int parent; ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. excellence town (1949)", "url": "/posts/BOJ-1949/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Graph, Dynamic Programming, excellence town, 우수 마을", "date": "2022-02-02 02:50:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1949import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] fdp; static int[] edp; static boolean[] visit; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr; Node[] nodes = new Node[n]; fdp = new int[n]; edp = new int[n]; Arrays.fill(fdp, 1); visit = new boolean[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; nodes[a].list.add(nodes[b]); nodes[b].list.add(nodes[a]); } nodes[0].parent = -1; bfs(nodes[0]); int ans = 0; println(edp[0] == 0 ? fdp[0] : Math.min(edp[0], fdp[0])); } static void bfs(Node node) { if(node.list.size() == 1 &amp;amp;&amp;amp; node.parent != -1) { return; } for(Node child: node.list) { if(child.idx == node.parent) continue; child.parent = node.idx; if(!visit[child.idx]) bfs(child); fdp[node.idx] += Math.min(fdp[child.idx], edp[child.idx]); edp[node.idx] += fdp[child.idx]; } visit[node.idx] = true; } static class Node { int idx; int parent; boolean evenIdx = false; ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Phone Keyboard (5670)", "url": "/posts/BOJ-5670/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Trie, Data Structure, Phone Keyboard, 휴대폰 자판", "date": "2022-02-01 13:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/5670import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); Trie trie; ArrayList&amp;lt;String&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); while(true) { String ss = br.readLine(); if(ss == null || ss.length() == 0) break; int n = toi(ss); if(n == 0) break; trie = new Trie(); al.clear(); for(int i = 0; i &amp;lt; n; i++) { String s = br.readLine(); trie.add(s); al.add(s); } int count = 0; for(String s: al) { count += trie.solve(s); } sb.append(String.format(&quot;%.2f&quot;, (double)count / n)).append(&quot;\\n&quot;); } print(sb); } static class Trie { Trie[] arr = new Trie[26]; int num = 0; boolean tail; void add(String s) { int l = s.length(); Trie t = this; for(int i = 0; i &amp;lt; l; i++) { int ch = s.charAt(i) - &#39;a&#39;; if(t.arr[ch] == null) { t.arr[ch] = new Trie(); t.num++; } t = t.arr[ch]; } t.tail = true; } int solve(String s) { Trie t = arr[s.charAt(0) - &#39;a&#39;]; int cnt = 1; for(int i = 1; i &amp;lt; s.length(); i++) { if(t.num + (t.tail ? 1 : 0) &amp;gt; 1) cnt++; t = t.arr[s.charAt(i) - &#39;a&#39;]; } return cnt; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Society Service(SNS) (2533)", "url": "/posts/BOJ-2533/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Graph, Dynamic Programming, Society Service(SNS), 사회망 서비스(SNS)", "date": "2022-02-01 13:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2533import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] fdp; static int[] edp; static boolean[] visit; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); int[] arr; Node[] nodes = new Node[n]; fdp = new int[n]; edp = new int[n]; Arrays.fill(fdp, 1); visit = new boolean[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; nodes[a].list.add(nodes[b]); nodes[b].list.add(nodes[a]); } nodes[0].parent = -1; bfs(nodes[0]); int ans = 0; println(edp[0] == 0 ? fdp[0] : Math.min(edp[0], fdp[0])); } static void bfs(Node node) { if(node.list.size() == 1 &amp;amp;&amp;amp; node.parent != -1) { return; } for(Node child: node.list) { if(child.idx == node.parent) continue; child.parent = node.idx; if(!visit[child.idx]) bfs(child); fdp[node.idx] += Math.min(fdp[child.idx], edp[child.idx]); edp[node.idx] += fdp[child.idx]; } visit[node.idx] = true; } static class Node { int idx; int parent; boolean evenIdx = false; ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Clock pictures (10266)", "url": "/posts/BOJ-10266/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Clock pictures, KMP, String, 시계 사진들, Review", "date": "2022-01-31 13:16:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/10266import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int timeNum = 360000; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); boolean[] clock1 = new boolean[2 * timeNum]; boolean[] clock2 = new boolean[timeNum]; int[] arr = getArr(); for(int e: arr) clock1[e] = clock1[e + timeNum] = true; arr = getArr(); for(int e: arr) clock2[e] = true; print(kmp(clock1, clock2) ? &quot;possible&quot; : &quot;impossible&quot;); } static int[] pi(boolean[] s) { int[] pi = new int[s.length]; int l = 0; for(int r = 1; r &amp;lt; s.length; r++) { while(l &amp;gt; 0 &amp;amp;&amp;amp; s[l] != s[r]) l = pi[l - 1]; if(s[l] == s[r]) { pi[r] = l + 1; l++; } } return pi; } static boolean kmp(boolean[] t, boolean[] s) { int[] pi = pi(s); int r = 0; for(int l = 0; l &amp;lt; t.length; l++) { while(r &amp;gt; 0 &amp;amp;&amp;amp; t[l] != s[r]) r = pi[r - 1]; if(t[l] == s[r]) { if(r == s.length - 1) return true; r++; } } return false; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 237 E Skiing", "url": "/posts/Atcoder-E-Skiing/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, Graph, Dijkstra, Review, ABC contest", "date": "2022-01-31 08:48:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc237/tasks/abc237_eConsider the following apth: Space 0 =&amp;gt; Space xPath: upper, lower distance: U, D=&amp;gt; happiness: D - 2 * U=&amp;gt; To maximize happiness : minimize U=&amp;gt; PriorityQue: sort with upper distanceimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); static int[] h; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int[] arr = getArr(); int n = arr[0], m = arr[1]; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) al.add(new ArrayList&amp;lt;Integer&amp;gt;()); h = getArr(); for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; al.get(a).add(b); al.get(b).add(a); } PriorityQueue&amp;lt;Edge&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; Long.compare(l.elevate, r.elevate)); long max = 0; boolean[] visit = new boolean[n]; long[] dijk = new long[n]; Arrays.fill(dijk, Long.MIN_VALUE); dijk[0] = 0; pq.add(new Edge(0, 0, 0)); while(!pq.isEmpty()) { Edge edge = pq.poll(); if(visit[edge.to]) continue; visit[edge.to] = true; for(int e: al.get(edge.to)) { if(visit[e]) continue; if(h[e] &amp;gt;= h[edge.to]) { if(dijk[e] &amp;gt; dijk[edge.to] + getVal(edge.to, e)) continue; dijk[e] = dijk[edge.to] + getVal(edge.to, e); pq.add(new Edge(edge.to, e, edge.elevate + h[e] - h[edge.to])); if(dijk[e] &amp;gt; max) max = dijk[edge.to]; } else { if(dijk[e] &amp;gt; dijk[edge.to] + getVal(edge.to, e)) continue; dijk[e] = dijk[edge.to] + getVal(edge.to, e); pq.add(new Edge(e, e, edge.elevate)); if(dijk[e] &amp;gt; max) max = dijk[e]; } } } print(max); } static int getVal(int from, int to) { if(h[from] == h[to]) return 0; if(h[from] &amp;gt; h[to]) return h[from] - h[to]; return 2 * (h[from] - h[to]); } static class Edge{ int from; int to; long elevate; Edge(int from, int to, long elevate) { this.from = from; this.to =to; this.elevate = elevate; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 237 D LR insertion", "url": "/posts/Atcoder-D-LR-insertion/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-30 21:50:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc237/tasks/abc237_dimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); String s = br.readLine(); Node[] nodes = new Node[n + 1]; for(int i = 0; i &amp;lt;= n; i++) nodes[i] = new Node(i); for(int i = 0; i &amp;lt; s.length(); i++) { char ch = s.charAt(i); if(ch == &#39;L&#39;) { nodes[i].left = nodes[i + 1]; } else nodes[i].right = nodes[i + 1]; } solve(nodes[0]); println(sb); } static void solve(Node node) { if(node.left != null) solve(node.left); sb.append(node.idx).append(&quot; &quot;); if(node.right != null) solve(node.right); } static class Node{ Node left; Node right; int idx; Node(int idx) { this. idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 237 C kasaka", "url": "/posts/Atcoder-C-kasaka/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-30 21:20:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc237/tasks/abc237_cimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String s = br.readLine(); int l = -1, r = s.length(); int rlen = 0, llen = 0; for(int i = 0; i &amp;lt; s.length(); i++) { if(s.charAt(i) != &#39;a&#39;) { break; } else l = i; } for(int i = s.length() - 1; i &amp;gt;= 0; i--) { if(s.charAt(i) != &#39;a&#39;) { break; } else r = i; } if(r &amp;lt;= l) { println(&quot;Yes&quot;); return; } if(l &amp;gt; s.length() - 1 - r) { println(&quot;No&quot;); return; } l++; r--; while(l &amp;lt; r) { if(s.charAt(l) != s.charAt(r)) { println(&quot;No&quot;); return; } l++; r--; } println(&quot;Yes&quot;); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 237 B Matrix Transposition", "url": "/posts/Atcoder-B-Matrix-Transposition/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-30 21:10:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc237/tasks/abc237_bimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); long l = Long.parseLong(br.readLine()); if(l &amp;lt;= Integer.MAX_VALUE &amp;amp;&amp;amp; Integer.MIN_VALUE &amp;lt;= l) println(&quot;Yes&quot;); else println(&quot;No&quot;); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 237 A Not Overflow", "url": "/posts/Atcoder-A-Not-Overflow/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-30 21:05:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc237/tasks/abc237_aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); long l = Long.parseLong(br.readLine()); if(l &amp;lt;= Integer.MAX_VALUE &amp;amp;&amp;amp; Integer.MIN_VALUE &amp;lt;= l) println(&quot;Yes&quot;); else println(&quot;No&quot;); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Find (1786)", "url": "/posts/BOJ-1786/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Find, String, KMP, KMP Algorithm, 찾기, Review", "date": "2022-01-29 23:10:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1786import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String t = br.readLine(), p = br.readLine(); int[] pi = new int[p.length()]; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); getPi(pi, p); int l = 0, r = 0, cnt = 0; while(l &amp;lt; t.length()) { while(r &amp;gt; 0 &amp;amp;&amp;amp; t.charAt(l) != p.charAt(r)) r = pi[r - 1]; if(t.charAt(l) == p.charAt(r)) { if(r == p.length() - 1) { cnt++; al.add(l + 2 - p.length()); r = pi[r]; } else r++; } l++; } println(cnt); for(int e: al) sb.append(e).append(&quot; &quot;); print(sb); } static public void getPi(int[] pi, String p) { int l = 0; for(int r = 1; r &amp;lt; p.length(); r++) { while(l &amp;gt; 0 &amp;amp;&amp;amp; p.charAt(l) != p.charAt(r)) l = pi[l - 1]; if(p.charAt(l) == p.charAt(r)) pi[r] = ++l; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. String square (4354)", "url": "/posts/BOJ-4354/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, String square, KMP, 문자열 제곱, Review, difficult, Important", "date": "2022-01-29 07:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/4354import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String s = br.readLine(); while(!s.equals(&quot;.&quot;)) { sb.append(kmp(s)).append(&quot;\\n&quot;); s = br.readLine(); } print(sb); } static int kmp(String p) { int l = 0, len = p.length(); int[] kmp = new int[p.length()]; for(int r = 1; r &amp;lt; len; r++) { while(l &amp;gt; 0 &amp;amp;&amp;amp; p.charAt(l) != p.charAt(r)) l = kmp[l - 1]; if(p.charAt(l) == p.charAt(r)) kmp[r] = ++l; } int chunkLen = len - kmp[len - 1], max = len / chunkLen; return len - max * chunkLen == 0 ? max : 1; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Ant tunnel (14725)", "url": "/posts/BOJ-14725/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Ant tunnel, 개미굴, Review", "date": "2022-01-29 07:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14725import java.util.*;import java.io.*;public class Main { static BufferedReader br; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); // StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()); String[] line; Trie trie = new Trie(); for(int i = 0; i &amp;lt; n; i++) { trie.insert(getLine()); } trie.dfs(0); print(sb); } static public class Trie { HashMap&amp;lt;String, Trie&amp;gt; list = new HashMap&amp;lt;&amp;gt;(); boolean sorted = false; public void insert(String[] words) { Trie t = this; for(int i = 1; i &amp;lt; words.length; i++) { if(!t.list.containsKey(words[i])) t.list.put(words[i], new Trie()); t = t.list.get(words[i]); } } public void dfs(int depth) { ArrayList&amp;lt;HashMap.Entry&amp;lt;String, Trie&amp;gt;&amp;gt; entries = new ArrayList&amp;lt;HashMap.Entry&amp;lt;String, Trie&amp;gt;&amp;gt;(this.list.entrySet()); Collections.sort(entries, (l, r) -&amp;gt; l.getKey().compareTo(r.getKey())); for(HashMap.Entry&amp;lt;String, Trie&amp;gt; entry : entries) { sb.append(new String(&quot;--&quot;).repeat(depth)).append(entry.getKey()).append(&quot;\\n&quot;); entry.getValue().dfs(depth + 1); } } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. String set (14425)", "url": "/posts/BOJ-14425/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, String set, 문자열 집합, Review", "date": "2022-01-29 07:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14425import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); int n = arr[0], m = arr[1]; Trie trie = new Trie(); int cnt = 0; for(int i = 0; i &amp;lt; n; i++) trie.add(br.readLine()); for(int i = 0; i &amp;lt; m; i++) if(trie.contains(br.readLine())) cnt++; print(cnt); } static class Trie { Trie[] arr = new Trie[26]; boolean end = false; public void add(String s) { Trie trie = this; for(int i = 0; i &amp;lt; s.length(); i++) { char ch = s.charAt(i); if(trie.arr[ch - &#39;a&#39;] == null) trie.arr[ch - &#39;a&#39;] = new Trie(); trie = trie.arr[ch - &#39;a&#39;]; } trie.end = true; } public boolean contains(String s) { Trie trie = this; for(int i = 0; i &amp;lt; s.length(); i++) { char ch = s.charAt(i); if(trie.arr[ch - &#39;a&#39;] == null) return false; trie = trie.arr[ch - &#39;a&#39;]; } return trie.end; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Two Liquid (2470)", "url": "/posts/BOJ-2470/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Two Liquid, 두 용액, Review", "date": "2022-01-27 22:56:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2470import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()); int[] arr = getArr(); Arrays.sort(arr); int left = 0, right = n - 1, total, lLiq, rLiq, min = Integer.MAX_VALUE; lLiq = 0; rLiq = n - 1; total = arr[left] + arr[right]; while(left &amp;lt; right) { if(Math.abs(total) &amp;lt; Math.abs(min)) { min = total; lLiq = left; rLiq = right; if(total == 0) break; } if(total &amp;gt; 0) total = total - arr[right] + arr[--right]; else total = total - arr[left] + arr[++left]; } print(arr[lLiq] + &quot; &quot; + arr[rLiq]); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Knapsack problem (1450)", "url": "/posts/BOJ-1450/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Knapsack problem, Two Pointer, Meet in middle, Binary Search, 냅색문제, Review, Important", "date": "2022-01-27 22:17:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1450When N = 30 Time complexity is O(2^30) &amp;gt; O(10^9)In order to reduce time complexity, cut the baggage to halfwhich reduces time complexity to O(2^15 * O(log2(2^15)))import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] bag; static int c; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); int n = arr[0]; c = arr[1]; ArrayList&amp;lt;Integer&amp;gt; leftList = new ArrayList&amp;lt;&amp;gt;(); ArrayList&amp;lt;Integer&amp;gt; rightList = new ArrayList&amp;lt;&amp;gt;(); bag = getArr(); int ans = 0; dfs(leftList, 0, 0, (n - 1)/2); dfs(rightList, 0, (n - 1)/2 + 1, n - 1); ans = leftList.size() + rightList.size(); Collections.sort(leftList); Collections.sort(rightList); for(int i = 0; i &amp;lt; leftList.size(); i++) { int index = binarySearch(rightList, c - leftList.get(i)); if(index != - 1) ans += index; else break; } print(ans + 1); } static int binarySearch(ArrayList&amp;lt;Integer&amp;gt; al , int val) { if(al.size() == 0) return -1; int left = 0, right = al.size() - 1, mid, ans = -1; if(val &amp;lt; al.get(0)) return -1; while(left &amp;lt;= right) { mid = (left + right) / 2; if(al.get(mid) &amp;lt;= val) left = mid + 1; else if(al.get(mid) &amp;gt; val) right = mid - 1; } return left; } static void dfs(ArrayList&amp;lt;Integer&amp;gt; al, int sum, int left, int right) { if(sum &amp;gt; c) return; if(left &amp;gt; right) { if(sum != 0) al.add((int)sum); return; } dfs(al, sum, left + 1, right); dfs(al, sum + bag[left], left + 1, right); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Sum of two number (3273)", "url": "/posts/BOJ-3273/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Sum of two number, 두 수의 합, Review", "date": "2022-01-27 07:08:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/3273import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); boolean[] ex = new boolean[1000001]; String[] line = br.readLine().split(&quot; &quot;); for(int i = 0; i &amp;lt; n; i++) if(toi(line[i]) != 0) ex[toi(line[i])] = true; int x = toi(br.readLine()), cnt = 0; for(int i = Math.max(1, x - 1000000); i &amp;lt;= (x - 1) / 2; i++) if(ex[i] &amp;amp;&amp;amp; ex[x - i]) cnt++; System.out.print(cnt); } static int toi(String s) { return Integer.parseInt(s); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); }}" }, { "title": "BOJ. Subsequence sum (1806)", "url": "/posts/BOJ-1806/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Two Pointer, BOJ, Subsequence sum, 부분합, Review", "date": "2022-01-27 03:45:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1806import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int n = 0; static int[][] cost; static int[][] dp; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int[] arr = getArr(); int n = arr[0], s = arr[1], min = 987654321; arr = getArr(); int sum = 0; int left = 0, right = 0; while(left &amp;lt; n &amp;amp;&amp;amp; right &amp;lt;= n) { if(sum &amp;lt; s) { if(right == n) break; sum += arr[right++]; } else { while(sum &amp;gt;= s) { sum -= arr[left++]; } min = Math.min(min, right - left + 1); } } print(min == 987654321 ? 0 : min); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Stick (1094)", "url": "/posts/BOJ-1094/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Stick, 막대기", "date": "2022-01-27 01:49:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1094import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int n = 0; static int[][] cost; static int[][] dp; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); // StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()), cnt = 0; for(int i = 0; i &amp;lt;= 6; i++) if((n &amp;amp; 1 &amp;lt;&amp;lt; i) != 0) cnt++; print(cnt); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Line up (2252)", "url": "/posts/BOJ-2252/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Topological Sort, Graph, BOJ, Line up, 줄 세우기, Review", "date": "2022-01-26 22:09:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2252import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); int n = arr[0], m = arr[1]; ArrayList&amp;lt;HashSet&amp;lt;Integer&amp;gt;&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) al.add(new HashSet&amp;lt;Integer&amp;gt;()); int[] deg = new int[n]; boolean[] visit = new boolean[n]; for(int i = 0; i &amp;lt; m; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1; deg[b]++; al.get(a).add(b); } Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { if(!visit[i] &amp;amp;&amp;amp; deg[i] != 0) continue; q.add(i); while(!q.isEmpty()) { int cur = q.poll(); if(visit[cur]) continue; visit[cur] = true; sb.append(cur + 1).append(&quot; &quot;); for(int v : al.get(cur)) { if(--deg[v] == 0) q.offer(v); } } } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Determine task (1311)", "url": "/posts/BOJ-1311/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Bitmask, BOJ, Determine task, 할 일 정하기 1, Review", "date": "2022-01-26 22:09:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1311import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int n = 0; static int[][] cost; static int[][] dp; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr; n = toi(br.readLine()); cost = new int[n][n]; dp = new int[n][(1 &amp;lt;&amp;lt; n) - 1]; for(int i = 0; i &amp;lt; n; i++) cost[i] = getArr(); print(dfs(0, 0)); } static int dfs(int personIdx, int bits) { if(personIdx == n) return 0; if(dp[personIdx][bits] != 0) return dp[personIdx][bits]; int min = 300000; for(int taskIdx = 0; taskIdx &amp;lt; n; taskIdx++) { if((bits &amp;amp; 1 &amp;lt;&amp;lt; taskIdx) != 0) continue; else min = Math.min(min, cost[personIdx][taskIdx] + dfs(personIdx + 1, bits | 1 &amp;lt;&amp;lt; taskIdx)); } return dp[personIdx][bits] = min; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Matrix multiplication order (11049)", "url": "/posts/BOJ-11049/", "categories": "Record, Code", "tags": "JavaScript, Algorithm, Coding Interview, Dynamic Programming, BOJ, Matrix multiplication order, 행렬 곱셈 순서", "date": "2022-01-26 18:44:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11049const stream = require(&#39;fs&#39;).readFileSync(0, &#39;utf-8&#39;).trim().split(/\\n/);const n = +stream[0], max = 987654321, arr = [];const dp = Array.from(Array(n), () =&amp;gt; new Array(n).fill(max));for (let i = 0; i &amp;lt; n; i++) { arr[i] = stream[i + 1].split(&#39; &#39;).map((e) =&amp;gt; +e); dp[i][i] = 0;}for (let diff = 1; diff &amp;lt; n; diff++) for (let i = 0; i &amp;lt; n - diff; i++) for (let j = i; j &amp;lt; i + diff; j++) dp[i][i + diff] = Math.min( dp[i][i + diff], dp[i][j] + dp[j + 1][i + diff] + arr[i][0] * arr[j][1] * arr[i + diff][1], );console.log(dp[0][n - 1]);" }, { "title": "BOJ. Continuative sum of prime (1644)", "url": "/posts/BOJ-1644/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Continuative sum of prime, 소수의 연속합, Review", "date": "2022-01-26 07:51:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1644import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()); ArrayList&amp;lt;Integer&amp;gt; al = getPrime(n); int left = 0, right = 0, size = al.size(), sum = 0, cnt = 0; while(left &amp;lt; size &amp;amp;&amp;amp; right &amp;lt;= size) { if(sum &amp;lt; n) { if(right == size) break; sum += al.get(right++); } else if(sum == n) { cnt++; sum -= al.get(left++); } else { sum -= al.get(left++); } } print(cnt); } static ArrayList&amp;lt;Integer&amp;gt; getPrime(int n) { ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 2; i &amp;lt;= n; i++) { boolean prime = true; for(int e: al) { if(e &amp;gt; Math.sqrt(i)) break; if(i % e == 0) { prime = false; break; }; } if(prime) al.add(i); } return al; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Set (11723)", "url": "/posts/BOJ-11723/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Bitmask, BOJ, Set, 집합", "date": "2022-01-26 04:59:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11723import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int m = toi(br.readLine()); String[] line; int bits = 0; for(int i = 0; i &amp;lt; m; i++) { line = getLine(); if(line[0].equals(&quot;add&quot;)) { int x = toi(line[1]) - 1; bits = bits | 1 &amp;lt;&amp;lt; x; } else if(line[0].equals(&quot;remove&quot;)) { int x = toi(line[1]) - 1; bits &amp;amp;= ~(1 &amp;lt;&amp;lt; x); } else if(line[0].equals(&quot;check&quot;)) { int x = toi(line[1]) - 1; sb.append((bits &amp;amp; 1 &amp;lt;&amp;lt; x) == 0 ? 0 : 1).append(&quot;\\n&quot;); } else if(line[0].equals(&quot;toggle&quot;)) { int x = toi(line[1]) - 1; bits = bits ^ 1 &amp;lt;&amp;lt; x; } else if(line[0].equals(&quot;all&quot;)) { bits = (1 &amp;lt;&amp;lt; 20) - 1; } else bits = 0; } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Strongly Connected Component (2150)", "url": "/posts/BOJ-2150/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, SCC, Graph, BOJ, Strongly Connected Component, 트리와 쿼리", "date": "2022-01-26 00:17:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2150import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] parent; static boolean[] handled; static int idx; static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; al; static Stack&amp;lt;Integer&amp;gt; stack; static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; scc; public static void main(String[] args) throws IOException { al = new ArrayList&amp;lt;&amp;gt;(); stack = new Stack&amp;lt;&amp;gt;(); scc = new ArrayList&amp;lt;&amp;gt;(); idx = 1; br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); int v = arr[0], e = arr[1]; parent = new int[v+1]; handled = new boolean[v+1]; for(int i = 0; i &amp;lt;= v; i++) al.add(new ArrayList&amp;lt;Integer&amp;gt;()); for(int i = 0; i &amp;lt; e; i++) { arr = getArr(); al.get(arr[0]).add(arr[1]); } for(int i = 1; i &amp;lt;= v; i++) { if(parent[i] == 0) dfs(i); } if(scc.size() &amp;gt; 1) scc.sort((l, r) -&amp;gt; l.get(0) - r.get(0)); sb.append(scc.size()).append(&quot;\\n&quot;); for(ArrayList&amp;lt;Integer&amp;gt; tmp: scc) { for(int ele: tmp) sb.append(ele + &quot; &quot;); sb.append(-1).append(&quot;\\n&quot;); } print(sb); } static int dfs(int i) { int origVal; origVal = parent[i] = idx++; stack.push(i); for(int vertex : al.get(i)) { if(parent[vertex] == 0) parent[i] = Math.min(parent[i], dfs(vertex)); else if(!handled[vertex]) parent[i] = Math.min(parent[i], parent[vertex]); } if(parent[i] == origVal) { ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); while(true) { int idx = stack.pop(); handled[idx] = true; al.add(idx); if(idx == i) break; } if(al.size() &amp;gt; 1) al.sort((l, r) -&amp;gt; l - r); scc.add(al); } return parent[i]; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Tree And Query (15681)", "url": "/posts/BOJ-15681/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Binary Tree, Dynamic Programming, BOJ, Tree And Query, 트리와 쿼리", "date": "2022-01-24 21:30:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/15681import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); int n = arr[0], r = arr[1], query = arr[2]; int[] dp = new int[n + 1]; ArrayList&amp;lt;Node&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); al.add(null); for(int i = 1; i &amp;lt;= n; i++) al.add(new Node(i)); for(int i = 0; i &amp;lt; n - 1; i++) { arr = getArr(); int u = arr[0], v = arr[1]; al.get(u).child.add(v); al.get(v).child.add(u); } getSubTreeNode(al, r, dp); for(int i = 0; i &amp;lt; query; i++) { int u = toi(br.readLine()); sb.append(dp[u]).append(&quot;\\n&quot;); } print(sb); } static int getSubTreeNode(ArrayList&amp;lt;Node&amp;gt; al, int idx, int[] dp) { if(dp[idx] != 0) return dp[idx]; int sum = 1; for(int childIdx : al.get(idx).child) { if(childIdx == al.get(idx).parent) continue; Node childNode = al.get(childIdx); childNode.parent = idx; sum += getSubTreeNode(al, childIdx, dp); } return dp[idx] = sum; } static class Node { int idx; int parent; ArrayList&amp;lt;Integer&amp;gt; child = new ArrayList&amp;lt;&amp;gt;(); public Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Make Bridge(2) (17472)", "url": "/posts/BOJ-17472/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Graph, Union Find, BOJ, Make Bridge(2), 다리 만들기 2", "date": "2022-01-23 04:39:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/17472In function getParent, copying only value and returning parent[idx] can be confusing.parent[idx].i = getParent(arr, parent[idx]).iparent[idx].y = getParent(arr, parent[idx]).i else return arr[idx] = getParent(arr, arr[idx]); }import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] seg; static int[] orig; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); ArrayList&amp;lt;Edge&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); PriorityQueue&amp;lt;Edge&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l.val - r.val); int v = arr[0], e = arr[1]; for(int i = 0; i &amp;lt; e; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1, c = arr[2]; if(a &amp;gt; b) { int tmp = a; a = b; b = a; } pq.add(new Edge(a, b, c)); } int ans = 0; int[] parents = new int[v]; for(int i = 0; i &amp;lt; v; i++) parents[i] = i; while(!pq.isEmpty()) { Edge cur = pq.poll(); int p1 = getParent(parents, cur.v1); int p2 = getParent(parents, cur.v2); if(p1 == p2) continue; if(p1 &amp;lt; p2) parents[p2] = p1; else parents[p1] = p2; ans += cur.val; } print(ans); } static int getParent(int[] arr, int idx) { if(idx == arr[idx]) return idx; else return arr[idx] = getParent(arr, arr[idx]); } static class Edge { int v1; int v2; int val; public Edge(int v1, int v2, int val) { this.v1 = v1; this.v2 = v2; this.val = val; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Planet Tunnel (2887)", "url": "/posts/BOJ-2887/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Graph, Kruskal, BOJ, Planet Tunnel, explanation, 행성 터널", "date": "2022-01-22 17:09:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2887Let’s assume Graph T is sub-graph of MST and contains edge that connects two vertex which is not next to each other.Without Loss of Generaility let two vertext A and B andA.x - B.x is the cost.Let’s pick a vertex between A and B and call it C.Case 1) When T contians C alreadyDisconnect A and B and connect C and A or C and B(Connect C with not connected one)Then this new graph connects all the vertex included in T and the cost is lower(|C.x - A.x| or |C.x - B.x| &amp;lt; |A.x - B.x|)So T cannot be the sub-graph of MST and by that assumption is contradiction.Case 2) When T does not contains CLet’s expaned T to include C.the cost will be T.cost + |A.x - C.x| (WLG).If we Disconnect A and B and connect A and C or B and Cthe new graph’s cost will be T.cost - |A.x - B.x| + (|B.x - C.x| or |A.x - C.x|) which is lower.So T cannot be the sub-graph of MST and by that assumption is contradiction.So to do Krustal’s algorithm all we have to add to Edges is justEdges which connects two vertext which is next to each other.import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] seg; static int[] orig; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr; int n = toi(br.readLine()); int[] parent = new int[n]; PriorityQueue&amp;lt;Edge&amp;gt; edges = new PriorityQueue&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) parent[i] = i; Coor[] xx = new Coor[n]; Coor[] yy = new Coor[n]; Coor[] zz = new Coor[n]; long ans = 0; for(int i = 0; i &amp;lt; n; i++) { arr = getArr(); xx[i] = new Coor(arr[0], i); yy[i] = new Coor(arr[1], i); zz[i] = new Coor(arr[2], i); } Arrays.sort(xx); Arrays.sort(yy); Arrays.sort(zz); for(int i = 0; i &amp;lt; n - 1; i++) { edges.add(new Edge(xx[i].idx, xx[i+1].idx, Math.abs(xx[i].coor - xx[i+1].coor))); edges.add(new Edge(yy[i].idx, yy[i+1].idx, Math.abs(yy[i].coor - yy[i+1].coor))); edges.add(new Edge(zz[i].idx, zz[i+1].idx, Math.abs(zz[i].coor - zz[i+1].coor))); } while(!edges.isEmpty()) { Edge edge = edges.poll(); int p1 = getParent(parent, edge.v1), p2 = getParent(parent, edge.v2); if(p1 == p2) continue; if(p1 &amp;lt; p2) parent[p2] = p1; else parent[p1] = p2; ans += edge.val; } print(ans); } static class Coor implements Comparable&amp;lt;Coor&amp;gt; { int coor; int idx; public Coor(int coor, int idx) { this.coor = coor; this.idx = idx; } public int compareTo(Coor coor) { if(this.coor &amp;gt; coor.coor) return 1; if(this.coor == coor.coor) return 0; return -1; } } static int getParent(int[] parent, int idx) { if(parent[idx] == idx) return idx; return parent[idx] = getParent(parent, parent[idx]); } static class Edge implements Comparable&amp;lt;Edge&amp;gt; { int v1; int v2; int val; public Edge(int v1, int v2, int val) { this.v1 = v1; this.v2 = v2; this.val = val; } public int compareTo(Edge edge) { return Integer.compare(this.val, edge.val); } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. MST (Minimum Spanning Tree) (1197)", "url": "/posts/BOJ-1197/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Graph, BOJ, MST (Minimum Spanning Tree), 최소 스패닝 트리", "date": "2022-01-22 01:28:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1197import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] seg; static int[] orig; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] arr = getArr(); ArrayList&amp;lt;Edge&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); PriorityQueue&amp;lt;Edge&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l.val - r.val); int v = arr[0], e = arr[1]; for(int i = 0; i &amp;lt; e; i++) { arr = getArr(); int a = arr[0] - 1, b = arr[1] - 1, c = arr[2]; if(a &amp;gt; b) { int tmp = a; a = b; b = a; } pq.add(new Edge(a, b, c)); } int ans = 0; int[] parents = new int[v]; for(int i = 0; i &amp;lt; v; i++) parents[i] = i; while(!pq.isEmpty()) { Edge cur = pq.poll(); int p1 = getParent(parents, cur.v1); int p2 = getParent(parents, cur.v2); if(p1 == p2) continue; if(p1 &amp;lt; p2) parents[p2] = p1; else parents[p1] = p2; ans += cur.val; } print(ans); } static int getParent(int[] arr, int idx) { if(idx == arr[idx]) return idx; else return arr[idx] = getParent(arr, arr[idx]); } static class Edge { int v1; int v2; int val; public Edge(int v1, int v2, int val) { this.v1 = v1; this.v2 = v2; this.val = val; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Digital Video Disk (9345)", "url": "/posts/BOJ-9345/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Segment Tree, Data Structure, Digital Video Disk, 디지털 비디오 디스크(DVDs), Review", "date": "2022-01-20 00:38:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/9345import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; MM[] seg; int[] orig; int t = toi(br.readLine()); for(int iter = 0; iter &amp;lt; t; iter++) { line = getLine(); int n = toi(line[0]), k = toi(line[1]); orig = new int[n]; seg = new MM[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n)/Math.log(2)) + 1]; for(int i = 0; i &amp;lt; n; i++) orig[i] = i; for(int i = 0; i &amp;lt; seg.length; i++) seg[i] = new MM(); init(seg, orig, 0, n-1, 1); for(int i = 0; i &amp;lt; k; i++) { line = getLine(); int q = toi(line[0]), a = toi(line[1]), b = toi(line[2]); if(q == 0) { int valA = orig[a]; update(seg, orig, 0, n-1, 1, a, orig[b]); update(seg, orig, 0, n-1, 1, b, orig[a]); orig[a] = orig[b]; orig[b] = valA; } else { MM mm = get(seg, orig, 0, n-1, 1, a, b); if(mm.min == a &amp;amp;&amp;amp; mm.max == b) sb.append(&quot;YES&quot;); else sb.append(&quot;NO&quot;); sb.append(&quot;\\n&quot;); } } } print(sb); } static MM init(MM[] seg, int[] orig, int l, int r, int idx) { if(l == r) { seg[idx].max = seg[idx].min = orig[l]; return seg[idx]; } int mid = (l + r) / 2; MM leftM = init(seg, orig, l, mid, 2 * idx), rightM = init(seg, orig, mid + 1, r, 2 * idx + 1); seg[idx].max = Math.max(leftM.max, rightM.max); seg[idx].min = Math.min(leftM.min, rightM.min); return seg[idx]; } static MM update(MM[] seg, int[] orig, int l, int r, int idx, int targetIdx, int val) { if(targetIdx &amp;lt; l || r &amp;lt; targetIdx) return seg[idx]; if(l == r) { seg[idx].max = seg[idx].min = val; return seg[idx]; } int mid = (l + r) / 2; MM leftM = update(seg, orig, l, mid, 2 * idx, targetIdx, val), rightM = update(seg, orig, mid + 1, r, 2 * idx + 1, targetIdx, val); seg[idx].max = Math.max(leftM.max, rightM.max); seg[idx].min = Math.min(leftM.min, rightM.min); return seg[idx]; } static MM get(MM[] seg, int[] orig, int l, int r, int idx, int start, int end) { if(end &amp;lt; l || r &amp;lt; start) return new MM(Integer.MIN_VALUE, Integer.MAX_VALUE); if(start &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= end) return seg[idx]; int mid = (l + r) / 2; MM leftM = get(seg, orig, l, mid, 2 * idx, start, end), rightM = get(seg, orig, mid + 1, r, 2 * idx + 1, start, end); int max = Math.max(leftM.max, rightM.max); int min = Math.min(leftM.min, rightM.min); return new MM(max, min); } static class MM { int max; int min; MM() {} MM(int max, int min) { this.max = max; this.min = min; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Josephus problem(2) (1168)", "url": "/posts/BOJ-1168/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Segment Tree, BOJ, Josephus problem(2), 요세푸스 문제 2, Important", "date": "2022-01-20 00:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1168import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] seg; static int[] orig; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] line = getArr(); int n = line[0], k = line[1]; int curLen = n, order = 1; sb.append(&quot;&amp;lt;&quot;); seg = new int[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n) / Math.log(2)) + 1]; init(seg, 1, n, 1); for(int i = 0; i &amp;lt; n; i++) { order = (order + k - 1) % curLen; if(order == 0) order = curLen; int val = get(seg, 1, n, 1, order); delete(seg, 1, n, 1, val); sb.append(val).append(&quot;, &quot;); curLen--; } sb.setLength(sb.length() - 2); sb.append(&quot;&amp;gt;&quot;); print(sb); } static int init(int[] seg, int start, int end, int idx) { if(start == end) return seg[idx] = 1; int mid = (start+end)&amp;gt;&amp;gt;1; return seg[idx] = init(seg, start, mid, idx&amp;lt;&amp;lt;1) + init(seg, mid+1, end, idx&amp;lt;&amp;lt;1|1); } static int get(int[] seg, int left, int right, int idx, int nth) { if(left == right) return left; int mid = (left+right)&amp;gt;&amp;gt;1; if(seg[idx&amp;lt;&amp;lt;1] &amp;gt;= nth) return get(seg, left, mid, idx&amp;lt;&amp;lt;1, nth); else return get(seg, mid + 1, right, idx&amp;lt;&amp;lt;1|1, nth - seg[idx&amp;lt;&amp;lt;1]); } static void delete(int[] seg, int left, int right, int idx, int target) { if(right &amp;lt; target || target &amp;lt; left) return; seg[idx]--; if(left == right) return; int mid = (left + right)&amp;gt;&amp;gt;1; delete(seg, left, mid, idx&amp;lt;&amp;lt;1, target); delete(seg, mid+1, right, idx&amp;lt;&amp;lt;1|1, target); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Data Structure (12899)", "url": "/posts/BOJ-12899/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Segment Tree, BOJ, Data Structure, 데이터 구조", "date": "2022-01-19 20:42:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/12899import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int[] seg; static int[] orig; static final int N = 2000000; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int[] line; int n = toi(br.readLine()); seg = new int[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(N) / Math.log(2)) + 1]; for(int i = 0; i &amp;lt; n; i++) { line = getArr(); if(line[0] == 1) { update(1, N, 1, line[1]); } else { int[] result = get(1, N, 1, line[1]); int targetIdx = result[0], val = result[1]; sb.append(val).append(&quot;\\n&quot;); delete(1, N, 1, val); } } print(sb); } static void update(int left, int right, int idx, int target) { if(target &amp;lt; left || right &amp;lt; target) return; seg[idx]++; if(left == right) return; int mid = (left + right) / 2; update(left, mid, 2 * idx, target); update(mid + 1, right, 2 * idx + 1, target); } static void delete(int left, int right, int idx, int target) { if(target &amp;lt; left || right &amp;lt; target) return; seg[idx]--; if(left == right) return; int mid = (left + right) &amp;gt;&amp;gt; 1; delete(left, mid, idx &amp;lt;&amp;lt; 1, target); delete(mid + 1, right, idx &amp;lt;&amp;lt; 1 | 1, target); } static int[] get(int left, int right, int idx, int leftNum) { if(left == right) return new int[] { idx, left }; //leftNum might not be 0 if there&#39;s duplicated value. int mid = (left + right)&amp;gt;&amp;gt;1; if(seg[idx &amp;lt;&amp;lt; 1] &amp;gt;= leftNum) { return get(left, mid, idx &amp;lt;&amp;lt; 1, leftNum); } else { return get(mid + 1, right, idx &amp;lt;&amp;lt; 1 | 1, leftNum - seg[idx &amp;lt;&amp;lt; 1]); } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getArr() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Police Car (2618)", "url": "/posts/BOJ-2618/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Dynamic Programming, BOJ, Police Car, 경찰차, Review", "date": "2022-01-18 19:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2618import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()), m = toi(br.readLine()); int[][] cost = new int[n][n]; for(int[] ar: cost) Arrays.fill(ar, Integer.MAX_VALUE); for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); cost[a][b] = Math.min(cost[a][b], c); } line = getLine(); int from = toi(line[0]) - 1, to = toi(line[1]) - 1; int[] dijk = new int[n]; int[] parent = new int[n]; Arrays.fill(dijk, Integer.MAX_VALUE); PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l[1] - r[1]); boolean[] visit = new boolean[n]; pq.add(new int[] { from, 0 }); while(!pq.isEmpty()) { int[] cur = pq.poll(); int idx = cur[0], curcost = cur[1]; if(visit[idx]) continue; visit[idx] = true; for(int i = 0; i &amp;lt; n; i++) { if(visit[i] || cost[idx][i] == Integer.MAX_VALUE) continue; if(curcost + cost[idx][i] &amp;lt; dijk[i]) { dijk[i] = curcost + cost[idx][i]; parent[i] = idx; pq.add(new int[] { i, dijk[i] }); } } } ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int idx = to; while(idx != from) { al.add(idx); idx = parent[idx]; } al.add(from); sb.append(dijk[to]).append(&quot;\\n&quot;).append(al.size()).append(&quot;\\n&quot;); for(int i = al.size() - 1; i &amp;gt;= 0; i--) sb.append(al.get(i) + 1).append(&quot; &quot;); print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Array and Query (16975)", "url": "/posts/BOJ-16975/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Segment Tree, BOJ, Array and Query, 수열과 쿼리 21", "date": "2022-01-18 11:51:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/16975import java.util.*;import java.io.*;public class Main { static BufferedReader br; static long[] seg; static int[] orig; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); orig = getLine(); seg = new long[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n) / Math.log(2)) + 1]; initSegTree(0, n - 1, 1); int qnum = toi(br.readLine()); for(int i = 0 ; i &amp;lt; qnum; i++) { orig = getLine(); if(orig[0] == 1) { update(0, n - 1, 1, orig[1] - 1, orig[2] - 1, orig[3]); } else { sb.append(get(0, n - 1, 1, orig[1] - 1)).append(&quot;\\n&quot;); } } print(sb); } static void update(int left, int right, int idx, int from, int to, int add) { if(right &amp;lt; from || to &amp;lt; left) return; if(from &amp;lt;= left &amp;amp;&amp;amp; right &amp;lt;= to) { seg[idx] += add; return; } int mid = (left + right) / 2; update(left, mid, 2*idx, from , to, add); update(mid + 1, right, 2*idx+1, from, to, add); } static long get(int left, int right, int idx, int target) { if(target &amp;lt; left || right &amp;lt; target) return 0l; if(left == right) return seg[idx]; int mid = (left + right) / 2; return seg[idx] + get(left, mid, 2*idx, target) + get(mid + 1, right, 2*idx + 1, target); } static void initSegTree(int from, int to, int idx) { if(from == to) { seg[idx] = (long)orig[from]; return; } int mid = (from + to) / 2; initSegTree(from, mid, 2*idx); initSegTree(mid + 1, to, 2*idx + 1); } static int toi(String s) { return Integer.parseInt(s); } // static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static int[] getLine() throws IOException { return Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 235 E MST + 1", "url": "/posts/Atcoder-D-Multiply-and-Rotate/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-16 02:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc235/tasks/abc235_eimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = getLine(); int n = toi(line[0]), m = toi(line[1]), q = toi(line[2]); ArrayList&amp;lt;int[]&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); edges.add(new int[] { a, b , c, -1 }); } for(int i = 0; i &amp;lt; q; i++) { line = getLine(); int u = toi(line[0]) - 1, v = toi(line[1]) - 1, w = toi(line[2]); edges.add(new int[] { u, v, w, i }); } edges.sort((l, r) -&amp;gt; l[2] - r[2]); boolean[] isTrue = new boolean[q]; // to store answers int[] parent = new int[n]; for(int i = 0; i &amp;lt; n; i++) parent[i] = i; for(int[] cur: edges) { int from = cur[0], to = cur[1], cost = cur[2], queryIdx = cur[3]; boolean isQuery = queryIdx == -1 ? false : true; int pfrom = getParent(parent, from), pto = getParent(parent, to); if(pfrom == pto) continue; if(isQuery) { isTrue[queryIdx] = true; continue; } if(pfrom &amp;gt; pto) parent[pto] = pfrom; else parent[pfrom] = pto; } for(boolean b : isTrue) sb.append(b ? &quot;Yes&quot; : &quot;No&quot;).append(&quot;\\n&quot;); print(sb); } static int getParent(int[] arr, int idx) { if(arr[idx] == idx) return idx; return arr[idx] = getParent(arr, arr[idx]); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 235 C The Kth Time Query", "url": "/posts/Atcoder-C-The-Kth-Time-Query/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-15 21:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc235/tasks/abc235_cimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String[] line = getLine(); StringBuilder sb = new StringBuilder(); int n = toi(line[0]), q = toi(line[1]); HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); line = getLine(); for(int i = 0; i &amp;lt; n; i++) { if(!hm.containsKey(toi(line[i]))) hm.put(toi(line[i]), new ArrayList&amp;lt;Integer&amp;gt;()); hm.get(toi(line[i])).add(i + 1); } for(int i = 0; i &amp;lt; q; i++) { line = getLine(); int x = toi(line[0]), k = toi(line[1]); if(!hm.containsKey(x) || hm.get(x).size() &amp;lt;= k - 1) sb.append(&quot;-1\\n&quot;); else sb.append(hm.get(x).get(k - 1)).append(&quot;\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 235 B Climbing Takahashi", "url": "/posts/Atcoder-B-Climbing-Takahashi/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-15 21:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc235/tasks/abc235_bimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); int n = toi(br.readLine()); String[] line = getLine(); int val = 0; for(int i = 0; i &amp;lt; n; i++) { if(val &amp;lt; toi(line[i])) val = toi(line[i]); else break; } println(val); } static int sum(int a, int b, int c) { return 100 * a + 10 * b + c; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "AtCoder. ABC 235 A - Rotate", "url": "/posts/Atcoder-A-Rotate/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, AtCoder, ABC contest", "date": "2022-01-15 21:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/abc235/tasks/abc235_aimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String input = br.readLine(); int[] digit = new int[3]; for(int i = 0; i &amp;lt; 3; i++) digit[i] = input.charAt(i) - &#39;0&#39;; int ans = sum(digit[0], digit[1], digit[2]) + sum(digit[1], digit[2], digit[0]) + sum(digit[2], digit[0], digit[1]); println(ans); } static int sum(int a, int b, int c) { return 100 * a + 10 * b + c; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Floyd(2) (11780)", "url": "/posts/BOJ-11780/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Graph, Floyd-Warshall, 플로이드 워셜, BOJ, Floyd(2), 플로이드 2", "date": "2022-01-15 15:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11780/*Can do more optimization with -- instead of storing middle idx(pass), store next idx -- instead of checking with visit[], init val of cost[][] with INF and just update when cost[from][to] &amp;gt; cost[from][mid] + cost[mid][to]*/import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()), m = toi(br.readLine()); long[][] cost = new long[n][n]; boolean[][] visit = new boolean[n][n]; int[][] pass = new int[n][n]; for(long[] ar: cost) Arrays.fill(ar, Long.MAX_VALUE); for(int[] ar: pass) Arrays.fill(ar, -1); for(int i = 0; i &amp;lt; n; i++) { visit[i][i] = true; cost[i][i] = 0; } for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); cost[a][b] = Math.min(cost[a][b], c); visit[a][b] = true; } for(int mid = 0; mid &amp;lt; n; mid++) { for(int from = 0; from &amp;lt; n; from++) { for(int to = 0; to &amp;lt; n; to++) { if(visit[from][mid] &amp;amp;&amp;amp; visit[mid][to]) { if(visit[from][to]) { if(cost[from][to] &amp;gt; cost[from][mid] + cost[mid][to]) { cost[from][to] = cost[from][mid] + cost[mid][to]; pass[from][to] = mid; } } else { cost[from][to] = cost[from][mid] + cost[mid][to]; visit[from][to] = true; pass[from][to] = mid; } } } } } for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; n; j++) { sb.append(visit[i][j] ? cost[i][j] : 0).append(&quot; &quot;); } sb.append(&quot;\\n&quot;); } ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; n; j++) { if(!visit[i][j] || i == j) { sb.append(&quot;0\\n&quot;); continue; } al.clear(); al.add(i + 1); getMiddlePath(pass, al, i, j); al.add(j + 1); sb.append(al.size()).append(&quot; &quot;); for(int e: al) sb.append(e).append(&quot; &quot;); sb.append(&quot;\\n&quot;); } } print(sb); } static void getMiddlePath(int[][] arr, ArrayList&amp;lt;Integer&amp;gt; al, int start, int end) { if(arr[start][end] == -1) return; int middle = arr[start][end]; getMiddlePath(arr, al, start, middle); al.add(middle + 1); getMiddlePath(arr, al, middle, end); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Get Miminum Cost(2) (11779)", "url": "/posts/BOJ-11779/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Dynamic Programming, BOJ, Get Miminum Cost(2), 최소비용 구하기 2", "date": "2022-01-15 02:30:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11779import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()), m = toi(br.readLine()); int[][] cost = new int[n][n]; for(int[] ar: cost) Arrays.fill(ar, Integer.MAX_VALUE); for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); cost[a][b] = Math.min(cost[a][b], c); } line = getLine(); int from = toi(line[0]) - 1, to = toi(line[1]) - 1; int[] dijk = new int[n]; int[] parent = new int[n]; Arrays.fill(dijk, Integer.MAX_VALUE); PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l[1] - r[1]); boolean[] visit = new boolean[n]; pq.add(new int[] { from, 0 }); while(!pq.isEmpty()) { int[] cur = pq.poll(); int idx = cur[0], curcost = cur[1]; if(visit[idx]) continue; visit[idx] = true; for(int i = 0; i &amp;lt; n; i++) { if(visit[i] || cost[idx][i] == Integer.MAX_VALUE) continue; if(curcost + cost[idx][i] &amp;lt; dijk[i]) { dijk[i] = curcost + cost[idx][i]; parent[i] = idx; pq.add(new int[] { i, dijk[i] }); } } } ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int idx = to; while(idx != from) { al.add(idx); idx = parent[idx]; } al.add(from); sb.append(dijk[to]).append(&quot;\\n&quot;).append(al.size()).append(&quot;\\n&quot;); for(int i = al.size() - 1; i &amp;gt;= 0; i--) sb.append(al.get(i) + 1).append(&quot; &quot;); print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. DSLR (9019)", "url": "/posts/BOJ-9019/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Dynamic Programming, BOJ, DSLR", "date": "2022-01-14 17:58:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/9019/* took too long for debugging this error StringBuilder sb1 = new StringBuilder(); StringBuilder sb2 = new StringBuilder(); sb1.append(&#39;c&#39;); sb2.append(&#39;c&#39;); sb1.toString().equals(sb2.toString()) =&amp;gt; true char[] ch = new char[3]; sb2.append(ch[0]); sb1.toString().equals(sb2.toString()) =&amp;gt; false*/import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { StringBuilder sb1 = new StringBuilder(); StringBuilder sb2 = new StringBuilder(); br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line ; int t = toi(br.readLine()); for(int iter = 0; iter &amp;lt; t; iter++) { line = getLine(); int a = toi(line[0]), b = toi(line[1]); int[] parent = new int[10000]; Arrays.fill(parent, -1); char[] oper = new char[10000]; Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.add(a); parent[a] = -2; while(!q.isEmpty()) { int cur = q.poll(); if(cur == b) break; int db = doublef(cur), leftV = left(cur), rightV = right(cur), deV = decrement(cur); if(parent[db] == -1) { parent[db] = cur; oper[db] = &#39;D&#39;; q.add(db); } if(parent[deV] == -1) { parent[deV] = cur; oper[deV] = &#39;S&#39;; q.add(deV); } if(parent[leftV] == -1) { parent[leftV] = cur; oper[leftV] = &#39;L&#39;; q.add(leftV); } if(parent[rightV] == -1) { parent[rightV] = cur; oper[rightV] = &#39;R&#39;; q.add(rightV); } } ArrayList&amp;lt;Character&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int idx = b; while(parent[idx] != -2) { al.add(oper[idx]); idx = parent[idx]; } for(int i = al.size() - 1; i &amp;gt;=0; i--) sb.append(al.get(i)); sb.append(&quot;\\n&quot;); } print(sb); } static int doublef(int n) { n *= 2; if(n &amp;gt;= 10000) n-= 10000; return n; } static int decrement(int n) { return n == 0 ? 9999 : n - 1; } static int[] getDigits(int n) { int d1 = n / 1000; n-= 1000*d1; int d2 = n / 100; n-= 100 * d2; int d3 = n / 10; int d4 = n - 10 * d3; return new int[] { d1, d2, d3, d4 }; } static int right(int n) { int[] digits = getDigits(n); return 1000 * digits[3] + 100 * digits[0] + 10 * digits[1] + digits[2]; } static int left(int n) { int[] digits = getDigits(n); return 1000 * digits[1] + 100 * digits[2] + 10 * digits[3] + digits[0]; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Hide And Sick(4) (13913)", "url": "/posts/BOJ-13913/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Dynamic Programming, BOJ, Hide And Sick(4), 숨바꼭질 4", "date": "2022-01-14 13:57:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/13913import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = getLine(); int n = toi(line[0]), k = toi(line[1]), range = 100001; if(n == k) { println(&quot;0&quot;); print(n); return; } int[] dp = new int[range]; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int time = 0; dp[n] = -1; al.add(n); loop: for(int i = 0; i &amp;lt; range; i++) { ArrayList&amp;lt;Integer&amp;gt;temp = new ArrayList&amp;lt;&amp;gt;(); for(int e: al) { if(e == k) { time = i; break loop; } if(e &amp;gt; 0 &amp;amp;&amp;amp; dp[e - 1] == 0) { temp.add(e-1); dp[e-1] = i + 1; } if(e &amp;gt; k) continue; if(e &amp;lt; range - 2 &amp;amp;&amp;amp; dp[e + 1] == 0) { temp.add(e+1); dp[e+1] = i + 1; } if(2 * e &amp;lt;= range - 1 &amp;amp;&amp;amp; dp[2 * e] == 0) { temp.add(2*e); dp[2*e] = i + 1; } } al = temp; } println(time); Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.push(k); int idx = k, val = time; while(val != 1) { if(idx + 1 &amp;lt; range &amp;amp;&amp;amp; dp[idx + 1] == val - 1) { idx++; val--; stack.add(idx); continue; } if(idx &amp;gt; 0 &amp;amp;&amp;amp; dp[idx - 1] == val - 1) { idx--; val--; stack.add(idx); continue; } if((idx&amp;amp;1) == 0 &amp;amp;&amp;amp; dp[idx/2] == val - 1) { idx/=2; val--; stack.add(idx); } } stack.add(n); while(!stack.isEmpty()) sb.append(stack.pop()).append(&quot; &quot;); sb.append(&quot;\\n&quot;); // for(int e: stack) sb.append(dp[e]).append(&quot; &quot;); print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. LCS 2 (9252)", "url": "/posts/BOJ-9252/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Dynamic Programming, BOJ, LCS 2", "date": "2022-01-13 02:30:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/9252DP solutionimport java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String line1 = br.readLine(), line2 = br.readLine(); int l1 = line1.length(), l2 = line2.length(); int[][] dp = new int[l1][l2]; // dp[i][j]: line1 0 ~ i line 0 ~ j for(int i = 0; i &amp;lt; l1; i++) { for(int j = 0; j &amp;lt; l2; j++) { if(line1.charAt(i) == line2.charAt(j)) { if(i &amp;gt;= 1 &amp;amp;&amp;amp; j &amp;gt;= 1) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = 1; } else { int v1 = i &amp;gt; 0 ? dp[i - 1][j] : 0; int v2 = j &amp;gt; 0 ? dp[i][j - 1] : 0; dp[i][j] = Math.max(v1, v2); } } } println(dp[l1-1][l2-1]); Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); int store = dp[l1-1][l2-1]; int ii = l1-1, jj = l2-1; while(ii &amp;gt;= 0 &amp;amp;&amp;amp; jj &amp;gt;=0) { if(dp[ii][jj] == 0) break; if(line1.charAt(ii) == line2.charAt(jj)) { sb.insert(0, line1.charAt(ii)); ii--; jj--; continue; } int upVal = ii &amp;gt; 0 ? dp[ii-1][jj] : 0; int preVal = jj &amp;gt; 0 ? dp[ii][jj-1] : 0; int max = 0; boolean goUp = true; if(upVal &amp;gt; preVal) max = upVal; else { max = preVal; goUp = false; } if(goUp) ii--; else jj--; } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}Time Limit Exceed(Recursive)import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); // String[] line = getLine(); String line1 = br.readLine(), line2 = br.readLine(); String[][] dp = new String[line1.length()][line2.length()]; for(String[] tmp : dp) Arrays.fill(tmp, &quot;&quot;); String result = lcs(line1, line2, 0, 0, dp); if(result.length() == 0) sb.append(&quot;0&quot;); else sb.append(result.length()).append(&quot;\\n&quot;).append(result); print(sb); } static String lcs(String line1, String line2, int idx1, int idx2, String[][] dp) { if(idx1 &amp;gt;= line1.length() || idx2 &amp;gt;= line2.length()) return &quot;&quot;; if(dp[idx1][idx2].length() != 0) return dp[idx1][idx2]; if(line1.charAt(idx1) == line2.charAt(idx2)) return dp[idx1][idx2] = line1.charAt(idx1) + lcs(line1, line2, idx1 + 1, idx2 + 1, dp); String s1 = lcs(line1, line2, idx1 + 1, idx2, dp), s2 = lcs(line1, line2, idx1, idx2 + 1, dp); return dp[idx1][idx2] = s1.length() &amp;gt; s2.length() ? s1 : s2; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Longest Increasing Subsequence(5) (14003)", "url": "/posts/BOJ-14003/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Binary Search, Longest Increasing Subsequence(5), 가장 긴 증가하는 부분 수열 5", "date": "2022-01-12 03:31:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14003import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); line = getLine(); int[] dp = new int[n]; int max = 0, maxIdx = 0; int arr[] = new int[n]; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); Arrays.fill(dp, -1); al.add(toi(line[0])); arr[0] = toi(line[0]); dp[0] = 0; for(int i = 1; i &amp;lt; n; i++) { int v = toi(line[i]), left = 0, right = al.size() - 1, mid; arr[i] = v; if(al.get(al.size() - 1) &amp;lt; v) { al.add(v); maxIdx = i; dp[i] = al.size() - 1; continue; } while(left &amp;lt;= right) { mid = (left + right) / 2; if(al.get(mid) &amp;gt;= v) right = mid - 1; else left = mid + 1; } al.set(right + 1, v); dp[i] = right + 1; } sb.append(dp[maxIdx] + 1).append(&quot;\\n&quot;); Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.push(arr[maxIdx]); int val = dp[maxIdx] - 1; for(int i = maxIdx - 1; i &amp;gt;= 0; i--) { if(dp[i] == val) { stack.push(arr[i]); val--; } if(val == -1) break; } while(!stack.isEmpty()) { sb.append(stack.pop()).append(&quot; &quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Longest Increasing Subsequence(4) (14002)", "url": "/posts/BOJ-14002/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, LIS Longest Increasing Subsequence(4), 가장 긴 증가하는 부분 수열 4", "date": "2022-01-11 18:36:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/14002import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); line = getLine(); Info[] dp = new Info[n]; int max = 0, maxIdx = 0; for(int i = 0; i &amp;lt; n; i++) { int v = toi(line[i]); dp[i] = new Info(v); for(int j = 0; j &amp;lt; i; j++) { if(v &amp;lt;= dp[j].val) continue; if(dp[i].step &amp;lt; dp[j].step + 1) { dp[i].step = dp[j].step + 1; dp[i].from = j; } } if(max &amp;lt; dp[i].step) { max = dp[i].step; maxIdx = i; } } Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); while(true) { stack.push(dp[maxIdx].val); if(dp[maxIdx].from == -1) break; maxIdx = dp[maxIdx].from; } sb.append(max).append(&quot;\\n&quot;); while(!stack.isEmpty()) sb.append(stack.pop()).append(&quot; &quot;); print(sb); } static class Info { int from = -1; int val; int step = 1; Info(int val) { this.val = val; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Make into 1(2) (12852)", "url": "/posts/BOJ-12852/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Make into 1(2), 1로 만들기 2", "date": "2022-01-11 18:07:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/12852import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); int[][] dp = new int[1000001][2]; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); dp[1][0] = 0; al.add(1); loop: while(true) { ArrayList&amp;lt;Integer&amp;gt; temp = new ArrayList&amp;lt;&amp;gt;(); for(int e : al) { int v = dp[e][0]; if(e == n) { sb.append(v).append(&quot;\\n&quot;); while(true) { sb.append(e).append(&quot; &quot;); if(dp[e][1] == 0) break loop; e = dp[e][1]; } } if(3*e &amp;lt;= n &amp;amp;&amp;amp; dp[3*e][0] == 0) { dp[3*e][0] = v + 1; dp[3*e][1] = e; temp.add(3 * e); } if(2*e &amp;lt;= n &amp;amp;&amp;amp; dp[2*e][0] == 0) { dp[2*e][0] = v + 1; temp.add(2 * e); dp[2*e][1] = e; } if(e+1 &amp;lt;= n &amp;amp;&amp;amp; dp[e+1][0] == 0) { dp[e+1][0] = v + 1; temp.add(e+1); dp[e+1][1] = e; } } al = temp; } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Iterate Tree (2263)", "url": "/posts/BOJ-2263/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Segment Tree, Data Structure, Iterate Tree, 트리의 순회, Review", "date": "2022-01-09 05:37:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2263import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); int[] in = new int[n]; int[] post = new int[n]; Node root; Node[] nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); line = getLine(); for(int i = 0; i &amp;lt; n; i++) in[i] = toi(line[i]) - 1; line = getLine(); for(int i = 0; i &amp;lt; n; i++) post[i] = toi(line[i]) - 1; root = nodes[post[n-1]]; spec(in, post, nodes, 0, n - 1, n - 1); pre(root, sb); print(sb); } static Node spec(int[] in, int[] post, Node[] nodes, int left, int right, int midIdx) { if(left &amp;gt; right) return null; if(left == right) return nodes[in[left]]; int midV = post[midIdx]; int midIdxIn = 0; for(int i = left; i &amp;lt;= right; i++) if(in[i] == midV) { nodes[midV].right = spec(in, post, nodes, i + 1, right, midIdx - 1); nodes[midV].left = spec(in, post, nodes, left, i - 1, midIdx + i - right - 1); } return nodes[midV]; } static class Node { int idx; Node left; Node right; public Node(int idx) { this.idx = idx; } } static void pre(Node node, StringBuilder sb) { sb.append(node.idx + 1).append(&quot; &quot;); if(node.left != null) pre(node.left, sb); if(node.right != null) pre(node.right, sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Bubble Sort (1517)", "url": "/posts/BOJ-1517/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Segment Tree, Data Structure, Bubble Sort, 버블 소트, Review, difficult", "date": "2022-01-08 08:20:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1517import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); int[] arr = new int[n]; int[] seg = new int[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n) / Math.log(2)) + 1]; ArrayList&amp;lt;int[]&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); line = getLine(); for(int i = 0; i &amp;lt; n; i++) al.add(new int[] { toi(line[i]), i }); al.sort((l, r) -&amp;gt; { if(l[0] == r[0]) return r[1] - l[1]; return r[0] - l[0]; }); long sum = 0; for(int i = 0; i &amp;lt; n; i++) { int[] pair = al.get(i); sum += get(seg, 0, n - 1, 0, pair[1], 1); update(seg, 0, n - 1, pair[1], 1); } print(sum); } static int get(int[] seg, int left, int right, int start, int end, int idx) { if(right &amp;lt; start || end &amp;lt; left) return 0; if(start &amp;lt;= left &amp;amp;&amp;amp; right &amp;lt;= end) return seg[idx]; int mid = (left + right) / 2; return get(seg, left, mid, start, end, 2 * idx) + get(seg, mid + 1, right, start, end, 2 * idx + 1); } static void update(int[] seg, int left, int right, int targetIdx, int idx) { seg[idx]++; if(left == right) return; int mid = (left + right) / 2; if(left &amp;lt;= targetIdx &amp;amp;&amp;amp; targetIdx &amp;lt;= mid) update(seg, left, mid, targetIdx, 2 * idx); else update(seg, mid + 1, right, targetIdx, 2 * idx + 1); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Tree Iteration (1991)", "url": "/posts/BOJ-1991/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Tree, Data Structure, Tree Iteration, 트리 순회", "date": "2022-01-07 00:50:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1991import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); boolean[] visit = new boolean[n]; Node[] nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(); for(int i = 0; i &amp;lt; n-1; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); nodes[a].adj.add(new int[] { b, c }); nodes[b].adj.add(new int[] { a, c }); } visit[0] = true; dfs(nodes, visit, 0, 0); Arrays.fill(visit, false); visit[maxIdx] = true; dfs(nodes, visit, 0, maxIdx); print(max); } static void dfs(Node[] nodes, boolean[] visit, int len, int cur) { if(len &amp;gt; max) { max = len; maxIdx = cur; } for(int[] arr: nodes[cur].adj) { if(visit[arr[0]]) continue; visit[arr[0]] = true; dfs(nodes, visit, len + arr[1], arr[0]); } } public static class Node { ArrayList&amp;lt;int[]&amp;gt; adj = new ArrayList&amp;lt;int[]&amp;gt;(); int dis = 0; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Diameter of Tree (1967)", "url": "/posts/BOJ-1967/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Tree, Data Structure, Diameter of Tree, 트리의 지름", "date": "2022-01-07 00:23:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1967import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()); boolean[] visit = new boolean[n]; Node[] nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(); for(int i = 0; i &amp;lt; n-1; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); nodes[a].adj.add(new int[] { b, c }); nodes[b].adj.add(new int[] { a, c }); } visit[0] = true; dfs(nodes, visit, 0, 0); Arrays.fill(visit, false); visit[maxIdx] = true; dfs(nodes, visit, 0, maxIdx); print(max); } static void dfs(Node[] nodes, boolean[] visit, int len, int cur) { if(len &amp;gt; max) { max = len; maxIdx = cur; } for(int[] arr: nodes[cur].adj) { if(visit[arr[0]]) continue; visit[arr[0]] = true; dfs(nodes, visit, len + arr[1], arr[0]); } } public static class Node { ArrayList&amp;lt;int[]&amp;gt; adj = new ArrayList&amp;lt;int[]&amp;gt;(); int dis = 0; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Diameter of Tree (1167)", "url": "/posts/BOJ-1167/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Tree, Data Structure, Diameter of Tree, 트리의 지름", "date": "2022-01-06 11:06:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1167import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int v = toi(br.readLine()); Node[] nodes = new Node[v]; boolean[] visit = new boolean[v]; for(int i = 0; i &amp;lt; v; i++) nodes[i] = new Node(i); for(int i = 0; i &amp;lt; v; i++) { line = getLine(); int cur = 1, v1 = toi(line[0]) - 1; while(true) { int v2 = toi(line[cur++]) - 1; if(v2 == -2) break; int dis = toi(line[cur++]); nodes[v1].adj.add(new int[] { v2, dis }); nodes[v2].adj.add(new int[] { v1, dis }); } } visit[0] = true; dfs(nodes, visit, 0, 0); Arrays.fill(visit, false); visit[maxIdx] = true; dfs(nodes, visit, 0, maxIdx); print(max); } static void dfs(Node[] nodes, boolean[] visit, int len, int cur) { if(len &amp;gt; max) { max = len; maxIdx = cur; } for(int[] arr: nodes[cur].adj) { if(visit[arr[0]]) continue; visit[arr[0]] = true; dfs(nodes, visit, len + arr[1], arr[0]); } } public static class Node { int idx; ArrayList&amp;lt;int[]&amp;gt; adj; Node(int idx) { this.idx = idx; this.adj = new ArrayList&amp;lt;int[]&amp;gt;(); } } static int sum(int[] arr, int s, int e) { int sum = 0; for(int i = s; i &amp;lt;= e; i++) sum+=arr[i]; return sum; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Binary Search Tree (5639)", "url": "/posts/BOJ-5639/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Tree, Data Structure, Binary Search Tree, 이진 검색 트리", "date": "2022-01-06 05:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/5639import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; Node root = new Node(toi(br.readLine())); Stack&amp;lt;Node&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.push(new Node(Integer.MAX_VALUE)); stack.push(root); String s; while((s = br.readLine()) != null) { int idx = Integer.parseInt(s); if(stack.peek().idx &amp;gt; idx) { stack.peek().left = new Node(idx); stack.push(stack.peek().left); } else { Node node; while(true) { node = stack.pop(); if(stack.peek().idx &amp;gt; idx) break; } node.right = new Node(idx); stack.push(node.right); } if(s.length() == 0) return; } post(root, sb); print(sb); } static void post(Node node, StringBuilder sb) { if(node.left != null) post(node.left, sb); if(node.right != null) post(node.right, sb); sb.append(node.idx).append(&quot;\\n&quot;); } public static class Node { Node right; Node left; int idx; Node(int idx) { this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Maximum and Minimum Values (2357)", "url": "/posts/BOJ-2357/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Segment Tree, Data Structure, Maximum and Minimum Values, 최솟값과 최댓값", "date": "2022-01-06 05:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2357import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = getLine(); int n = toi(line[0]), m = toi(line[1]); int[] orig = new int[n]; int[][] seg = new int[1 &amp;lt;&amp;lt; (int)(Math.ceil(Math.log(n)/Math.log(2)) + 1)][2]; for(int iter = 0; iter &amp;lt; n; iter++) { int num = toi(br.readLine()); orig[iter] = num; } init(seg, orig, 0, n - 1, 1); for(int iter = 0; iter &amp;lt; m; iter++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1; int[] result = get(seg, orig, 0, n - 1, a, b, 1); sb.append(result[0]).append(&quot; &quot;).append(result[1]).append(&quot;\\n&quot;); } print(sb); } static int[] init(int[][] seg, int[] arr, int l, int r, int idx) { if(l == r) return seg[idx] = new int[] { arr[l], arr[l] }; int mid = (l + r) / 2; int[] lh = init(seg, arr, l, mid, 2 * idx), rh = init(seg, arr, mid + 1, r, 2 * idx + 1); return seg[idx] = new int[] { Math.min(lh[0], rh[0]), Math.max(lh[1], rh[1]) }; } static int[] get(int[][] seg, int[] arr, int l, int r, int start, int end, int idx) { if(r &amp;lt; start || end &amp;lt; l) return new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE }; if(start &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= end) return seg[idx]; int mid = (l + r) / 2; int[] lh = get(seg, arr, l, mid, start, end, 2 * idx), rh = get(seg, arr, mid + 1, r, start, end, 2 * idx + 1); return new int[] { Math.min(lh[0], rh[0]), Math.max(lh[1], rh[1]) }; } static int sum(int[] arr, int s, int e) { int sum = 0; for(int i = s; i &amp;lt;= e; i++) sum+=arr[i]; return sum; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Find Parent In Tree (11725)", "url": "/posts/BOJ-11725/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Tree, Data Structure, Find Parent In Tree, 트리의 부모 찾기", "date": "2022-01-06 05:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11725import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String[] line; StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()); int[] parent = new int[n]; boolean[] visit = new boolean[n]; ArrayList&amp;lt;Node&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) al.add(new Node(i)); for(int i = 1; i &amp;lt; n; i++) { line = getLine(); int v1 = toi(line[0]) - 1, v2 = toi(line[1]) - 1; al.get(v1).list.add(v2); al.get(v2).list.add(v1); } Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.add(0); while(!q.isEmpty()) { int cur = q.poll(); if(visit[cur]) continue; visit[cur] = true; for(int nodeIdx : al.get(cur).list) { if(visit[nodeIdx]) continue; parent[nodeIdx] = cur; q.add(nodeIdx); } } for(int i = 1; i &amp;lt; n; i++) sb.append(parent[i] + 1).append(&quot;\\n&quot;); print(sb); } static class Node { int idx; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Node(int idx) { this.idx = idx; } } static int sum(int[] arr, int s, int e) { int sum = 0; for(int i = s; i &amp;lt;= e; i++) sum+=arr[i]; return sum; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Cycle game (20040)", "url": "/posts/BOJ-20040/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Union Find, Cycle game, 사이클 게임", "date": "2022-01-06 03:45:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/20040import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String[] line = getLine(); // StringBuilder sb = new StringBuilder(); int n = toi(line[0]), m = toi(line[1]); int[] union = new int[n]; for(int i = 0; i &amp;lt; n; i++) union[i] = i; for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int v1 = toi(line[0]), v2 = toi(line[1]); int p1 = getParent(union, v1), p2 = getParent(union, v2); if(p1 == p2) { print(i + 1); return; } if(p1 &amp;lt; p2) union[p2] = p1; else union[p1] = p2; } print(0); } static int getParent(int[] union, int idx) { if(union[idx] == idx) return idx; return union[idx] = getParent(union, union[idx]); } static int sum(int[] arr, int s, int e) { int sum = 0; for(int i = s; i &amp;lt;= e; i++) sum+=arr[i]; return sum; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); }}" }, { "title": "LeetCode. 131. Palindrome Partitioning", "url": "/posts/Leetcode-131.-Palindrome-Partitioning/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Palindrome Partitioning", "date": "2022-01-06 01:57:00 +0900", "snippet": "[Link] https://leetcode.com/problems/palindrome-partitioning///optimized with dp(less substring function called)class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) { List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); boolean[][] notP = new boolean[s.length()][s.length()]; String[][] dp = new String[s.length()][s.length()]; dfs(ans, new ArrayList&amp;lt;String&amp;gt;(), s,-1, notP, dp); return ans; } public void dfs(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; ans, ArrayList&amp;lt;String&amp;gt; ll, String s,int k, boolean[][] notP, String[][] dp){ if(k == s.length() - 1){ ans.add(new ArrayList&amp;lt;String&amp;gt;(ll)); return; } for(int i= k+1 ; i &amp;lt; s.length(); i++){ if(notP[k+1][i]) continue; else if(dp[k+1][i] != null) { ll.add(dp[k+1][i]); dfs(ans, ll, s, i, notP, dp); ll.remove(ll.size() -1); } else { String str=s.substring(k+1,i+1); if(isPal(s, k + 1, i, notP)){ ll.add(str); dp[k+1][i] = str; dfs(ans, ll,s,i, notP, dp); ll.remove(ll.size() -1); } else notP[k+1][i] = true; } } } public boolean isPal(String s, int start, int end, boolean[][] notP){ for(int l = start, r = end; l &amp;lt; r; l++, r--) if(s.charAt(l) != s.charAt(r)) { while(l &amp;gt;= start &amp;amp;&amp;amp; r &amp;lt;= end &amp;amp;&amp;amp; !notP[l][r]) { notP[l--][r--] = true; } return false; } return true; }} First attempt(Full dp + dfs) &amp;lt;/br&amp;gt;class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) { int len = s.length(); char[] ch = s.toCharArray(); boolean[][] pal = new boolean[len][len]; for(int i = 0; i &amp;lt; len - 1; i++) { pal[i][i] = true; if(ch[i] == ch[i+1]) pal[i][i+1] = true; } pal[len-1][len-1] = true; for(int di = 2; di &amp;lt; len; di++) for(int i = 0; i &amp;lt; len - di; i++) if(ch[i] == ch[i+di] &amp;amp;&amp;amp; pal[i+1][i+di-1]) pal[i][i+di] = true; LinkedList&amp;lt;Integer&amp;gt; ll = new LinkedList&amp;lt;&amp;gt;(); List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); dfs(pal, ch, -1, ll, list, len); return list; } void dfs(boolean[][] pal, char[] ch, int cur, LinkedList&amp;lt;Integer&amp;gt; ll, List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; list, int len) { if(cur == len - 1) { LinkedList&amp;lt;String&amp;gt; temp = new LinkedList&amp;lt;&amp;gt;(); int startIdx = 0; for(int idx: ll) { temp.add(String.copyValueOf(ch, startIdx, idx - startIdx + 1)); startIdx = idx + 1; } list.add(temp); return; } for(int i = cur + 1; i &amp;lt; len; i++) { if(pal[cur+1][i]) { ll.add(i); dfs(pal, ch, i, ll, list, len); ll.removeLast(); } } } &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); }}" }, { "title": "BOJ. Friend Network (4195)", "url": "/posts/BOJ-4195/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Union Find, Friend Network, 친구 네트워크, Review", "date": "2022-01-05 16:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/4195import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int t = toi(br.readLine()); HashMap&amp;lt;String, Node&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); for(int iter = 0; iter &amp;lt; t; iter++) { hm.clear(); int f = toi(br.readLine()); for(int i = 0; i &amp;lt; f; i++) { line = getLine(); if(!hm.containsKey(line[0])) hm.put(line[0], new Node(line[0], 1)); if(!hm.containsKey(line[1])) hm.put(line[1], new Node(line[1], 1)); Node parentNode0 = getParent(hm, line[0]); Node parentNode1 = getParent(hm, line[1]); if(parentNode0.parent.compareTo(parentNode1.parent) &amp;lt; 0) { parentNode0.num += parentNode1.num; parentNode1.parent = parentNode0.parent; sb.append(parentNode0.num).append(&quot;\\n&quot;); } else if(parentNode0.parent.equals(parentNode1.parent)){ sb.append(parentNode0.num).append(&quot;\\n&quot;); } else { parentNode1.num += parentNode0.num; parentNode0.parent = parentNode1.parent; sb.append(parentNode1.num).append(&quot;\\n&quot;); } } } print(sb); } static Node getParent(HashMap&amp;lt;String, Node&amp;gt; hm, String s) { if(hm.get(s).parent.equals(s)) return hm.get(s); Node node = getParent(hm, hm.get(s).parent); hm.get(s).parent = node.parent; return node; } static class Node { String parent; int num; Node(String parent, int num) { this.parent = parent; this.num = num; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Let&#39;s go on a trip (1976)", "url": "/posts/BOJ-1976/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Union Find, Let's go on a trip, 여행 가자, Review", "date": "2022-01-05 13:30:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1976import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String[] line; int n = toi(br.readLine()), m = toi(br.readLine()); int[][] link = new int[n][n]; int[] union = new int[n]; for(int i = 0; i &amp;lt; n; i++) union[i] = i; for(int i = 0; i &amp;lt; n; i++) { line = getLine(); for(int j = 0; j &amp;lt; n; j++) { if(line[j].equals(&quot;1&quot;)) { link[i][j] = 1; int parentI = getTop(i, union), parentJ = getTop(j, union); if(parentI &amp;lt; parentJ) union[parentJ] = parentI; else if(parentI != parentJ) union[parentI] = parentJ; } } } line = getLine(); int topNode = getTop((toi(line[0]) - 1) , union); for(int i = 1; i &amp;lt; line.length; i++) { if(topNode != getTop((toi(line[i]) - 1), union)) { print(&quot;NO&quot;); return; } } print(&quot;YES&quot;); } static int getTop(int idx, int[] union) { if(union[idx] == idx) return union[idx]; return union[idx] = getTop(union[idx], union); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Merge Files (11066)", "url": "/posts/BOJ-11066/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dynamic Programming, Merge Files, 파일 합치기", "date": "2022-01-05 12:20:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11066import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String[] line; StringBuilder sb = new StringBuilder(); int t = toi(br.readLine()); for(int iter = 0; iter &amp;lt; t; iter++) { int k = toi(br.readLine()); int[][] dp = new int[k][k]; int[] arr = Arrays.stream(getLine()).mapToInt(Integer::parseInt).toArray(); int[][] sum = new int[k][k]; for(int i = 0; i &amp;lt; k; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); dp[i][i] = sum[i][i] = arr[i]; } for(int di = 1; di &amp;lt; k; di++) for(int i = 0; i &amp;lt; k - di; i++) sum[i][i + di] = sum[i][i + di - 1] + arr[i + di]; for(int i = 1; i &amp;lt; k; i++) { // 1 ~ k - 1- i (y - x) for(int l = 0; l &amp;lt; k - i; l++) { for(int mid = l; mid &amp;lt; l + i; mid++) { if(i == k -1) dp[l][l + i] = Math.min(dp[l][l + i], dp[l][mid] + dp[mid + 1][l + i]); else dp[l][l + i] = Math.min(dp[l][l + i], dp[l][mid] + dp[mid + 1][l + i] + sum[l][l + i]); } } } sb.append(dp[0][k-1] + &quot;\\n&quot;); } print(sb); } static int sum(int[] arr, int s, int e) { int sum = 0; for(int i = s; i &amp;lt;= e; i++) sum+=arr[i]; return sum; } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); }}" }, { "title": "BOJ. Exercise (1956)", "url": "/posts/BOJ-1956/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dijkstra, Floyd Warshall Graph, Exercise, 운동", "date": "2022-01-05 03:02:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1956import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); String[] line = getLine(); int max = Integer.MAX_VALUE; int v = toi(line[0]), e = toi(line[1]); int[][] dis = new int[v][v]; int[][] floyd = new int[v][v]; for(int i = 0; i &amp;lt; v; i++) { Arrays.fill(floyd[i], max); floyd[i][i] = 0; } for(int i = 0; i &amp;lt; e; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); dis[a][b] = c; floyd[a][b] = Math.min(floyd[a][b], c); } for(int mid = 0; mid &amp;lt; v; mid++) { for(int from = 0; from &amp;lt; v; from ++) { for(int to = 0; to &amp;lt; v; to++) { if(floyd[from][mid] != max &amp;amp;&amp;amp; floyd[mid][to] != max &amp;amp;&amp;amp; floyd[from][to] &amp;gt; floyd[from][mid] + floyd[mid][to]) floyd[from][to] = floyd[from][mid] + floyd[mid][to]; } } } int ans = max; for(int i = 0; i &amp;lt; v; i++) { for(int j = 0; j &amp;lt; v; j++) { if(i == j) continue; if(floyd[i][j] != max &amp;amp;&amp;amp; floyd[j][i] != max) ans = Math.min(ans, floyd[i][j] + floyd[j][i]); } } print(ans == max ? -1 : ans); } static class Edge{ int from; int to; int dis; public Edge(int from, int to, int dis) { this.from = from; this.to = to; this.dis = dis; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); }}dijkstra solution(TLE time out)import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = getLine(); int v = toi(line[0]), e = toi(line[1]); ArrayList&amp;lt;ArrayList&amp;lt;int[]&amp;gt;&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); // 0 : int[][] dis = new int[v][v]; int[][] dijk = new int[v][v]; for(int i = 0; i &amp;lt; v; i++) { Arrays.fill(dijk[i], Integer.MAX_VALUE); dijk[i][i] = 0; } for(int i = 0; i &amp;lt; v; i++) al.add(new ArrayList&amp;lt;int[]&amp;gt;()); // 0: to 1: dis for(int i = 0; i &amp;lt; e; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); al.get(a).add(new int[]{b, c}); dis[a][b] = c; } PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l[1] - r[1]); for(int start = 0; start &amp;lt; v; start++) { pq.clear(); pq.add(new int[]{start, 0}); while(!pq.isEmpty()) { int[] cur = pq.poll(); int curIdx = cur[0], curDis = cur[1]; for(int[] arr : al.get(curIdx)) { if(dijk[start][arr[0]] &amp;gt; curDis + arr[1]) { dijk[start][arr[0]] = curDis + arr[1]; pq.add(new int[]{arr[0], dijk[start][arr[0]]}); } } } } int ans = Integer.MAX_VALUE; for(int i = 0; i &amp;lt; v; i++) { for(int j = 0; j &amp;lt; v; j++) { if(dis[j][i] != 0 &amp;amp;&amp;amp; dijk[i][j] != Integer.MAX_VALUE) ans = Math.min(ans, dis[j][i] + dijk[i][j]); } } print(ans == Integer.MAX_VALUE ? -1 : ans); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); }}" }, { "title": "BOJ. KCM Travel (10217)", "url": "/posts/BOJ-10217/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dijkstra, Graph, KCM Travel, Review, difficult", "date": "2022-01-05 01:58:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/10217//optimation line74-77 dp[destination][cost]import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int t = toi(br.readLine()); for(int iter = 0; iter &amp;lt; t; iter++) { line = getLine(); int n = toi(line[0]), m = toi(line[1]), k = toi(line[2]); int[][] dp = new int[n][100001]; for(int[] dpar: dp) Arrays.fill(dpar, Integer.MAX_VALUE); ArrayList&amp;lt;ArrayList&amp;lt;Ticket&amp;gt;&amp;gt; tickets = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { tickets.add(new ArrayList&amp;lt;Ticket&amp;gt;()); Arrays.fill(dp[i], Integer.MAX_VALUE); } PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l[1] - r[1]); for(int i = 0; i &amp;lt; k; i++) { line = getLine(); int u = toi(line[0]) - 1, v = toi(line[1]) - 1, c = toi(line[2]), d = toi(line[3]); tickets.get(u).add(new Ticket(v, c, d)); } dp[0][0] = 0; boolean canGo = false; pq.add(new int[] { 0, 0, 0 }); while(!pq.isEmpty()) { int[] cur = pq.poll(); int curIdx = cur[0], curTime = cur[1], curCost = cur[2]; if(dp[curIdx][curCost] &amp;lt; curTime) continue; if(curIdx == n - 1) { sb.append(curTime+&quot;\\n&quot;); canGo = true; break; } for(Ticket ticket: tickets.get(curIdx)) { int tcost = curCost + ticket.cost, ttime = curTime + ticket.time; if(tcost &amp;gt; m) continue; if(ttime &amp;lt; dp[ticket.dest][tcost]) { dp[ticket.dest][tcost] = ttime; pq.add(new int[]{ ticket.dest, dp[ticket.dest][tcost], tcost }); } for(int cost = tcost + 1; cost &amp;lt;= m; cost++) { if(ttime &amp;lt; dp[ticket.dest][cost]) dp[ticket.dest][cost] = ttime; else break; } } } if(!canGo) sb.append(&quot;Poor KCM\\n&quot;); } print(sb); } static class Ticket { int dest; int cost; int time; public Ticket(int dest, int cost, int time) { this.dest = dest; this.cost = cost; this.time = time; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); }}" }, { "title": "BOJ. Floyd (11404)", "url": "/posts/BOJ-11404/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Floyd-Warshall, 플로이드 워셜, Graph, 플로이드, Review", "date": "2022-01-04 19:12:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11404import java.util.*;import java.io.*;public class Main { static BufferedReader br; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int n = toi(br.readLine()), m = toi(br.readLine()); int[][] dis = new int[n][n]; int[][] floyd = new int[n][n]; boolean[][] visit = new boolean[n][n]; for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); if(!visit[a][b]) { dis[a][b] = floyd[a][b] = c; visit[a][b] = true; } else dis[a][b] = floyd[a][b] = Math.min(dis[a][b], c); } for(int i = 0; i &amp;lt; n; i++) visit[i][i] = true; for(int mid = 0; mid &amp;lt; n; mid++) { for(int from = 0; from &amp;lt; n; from++) { for(int to = 0; to &amp;lt; n; to++) { if(visit[from][mid] &amp;amp;&amp;amp; visit[mid][to]) { if(!visit[from][to]) { floyd[from][to] = floyd[from][mid] + floyd[mid][to]; visit[from][to] = true; } else floyd[from][to] = Math.min(floyd[from][to], floyd[from][mid] + floyd[mid][to]); } } } } for(int[] ar: floyd) { for(int e: ar) sb.append(e + &quot; &quot;); sb.setLength(sb.length() - 1); sb.append(&quot;\\n&quot;); } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "LeetCode. 997. Find the Town Judge", "url": "/posts/Leetcode-997.-Find-the-Town-Judge/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Find the Town Judge", "date": "2022-01-04 01:14:00 +0900", "snippet": "[Link] https://leetcode.com/problems/find-the-town-judge/class Solution { public int findJudge(int n, int[][] trust) { if(n == 1) return trust.length == 0 ? 1 : -1; int[] trustedBy = new int[n + 1]; boolean[] cantBe = new boolean[n + 1]; for(int[] ar: trust) { cantBe[ar[0]] = true; trustedBy[ar[1]]++; } for(int i = n; i &amp;gt; 0; i--) if(!cantBe[i] &amp;amp;&amp;amp; trustedBy[i] == n-1) return i; return -1; }}" }, { "title": "BOJ. Time Machine (11657)", "url": "/posts/BOJ-11657/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Bellman Ford, 벨만 포드, Graph, Time Machine, 타임머신, Review", "date": "2022-01-03 11:45:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11657import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = getLine(br); int n = toi(line[0]), m = toi(line[1]); ArrayList&amp;lt;Edge&amp;gt; edges = new ArrayList&amp;lt;&amp;gt;(); boolean[] visit = new boolean[n]; long[] belfor = new long[n]; Arrays.fill(belfor, Integer.MAX_VALUE); for(int i = 0; i &amp;lt; m; i++) { line = getLine(br); int a = toi(line[0]) - 1, b = toi(line[1]) - 1, c = toi(line[2]); edges.add(new Edge(a, b, (long)c)); } belfor[0] = 0l; visit[0] = true; for(int iter = 0; iter &amp;lt; n; iter++) { for(Edge edge: edges) { if(!visit[edge.from]) continue; if(belfor[edge.from] + edge.dis &amp;lt; belfor[edge.to]) { belfor[edge.to] = belfor[edge.from] + edge.dis; visit[edge.to] = true; } } } for(Edge edge: edges) { if(!visit[edge.from]) continue; if(belfor[edge.from] + edge.dis &amp;lt; belfor[edge.to]) { print(-1); return; } } for(int i = 1; i &amp;lt; n; i++) sb.append(visit[i] ? belfor[i] : -1).append(&quot;\\n&quot;); print(sb); } static class Edge { int from; int to; long dis; public Edge(int from, int to, long dis) { this.from = from; this.to = to; this.dis = dis; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine(BufferedReader br) throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Unidentified destination (9370)", "url": "/posts/BOJ-9370/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dijkstra, Graph, Unidentified destination, 미확인 도착지, Review", "date": "2022-01-02 01:34:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/9370//Edge case s == (g or h) or (g or h) == destinationimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; int T = toi(br.readLine()); for(int i = 0; i &amp;lt; T; i++) { line = getLine(br); int n = toi(line[0]), m = toi(line[1]), t = toi(line[2]); int[][] dis = new int[n][n]; long[] dijkOrig = new long[n]; long[] dijk1 = new long[n]; long[] dijk2 = new long[n]; Arrays.fill(dijkOrig, Long.MAX_VALUE); Arrays.fill(dijk1, Long.MAX_VALUE); Arrays.fill(dijk2, Long.MAX_VALUE); line = getLine(br); int s = toi(line[0]), g = toi(line[1]), h = toi(line[2]); dijkOrig[s - 1] = dijk1[g - 1] = dijk2[h - 1] = 0l; for(int j = 0; j &amp;lt; m; j++) { line = getLine(br); int a = toi(line[0]), b = toi(line[1]), d = toi(line[2]); dis[a - 1][b - 1] = dis[b - 1][a - 1] = d; } dijkstra(dis, dijkOrig, s - 1); dijkstra(dis, dijk1, g - 1); dijkstra(dis, dijk2, h - 1); ArrayList&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for(int j = 0; j &amp;lt; t; j++) { int cand = toi(br.readLine()); if(dijkOrig[cand - 1] == (dijkOrig[g - 1] + dis[g-1][h-1] + dijk2[cand - 1]) || dijkOrig[cand - 1] == (dijkOrig[h - 1] + dis[g-1][h-1] + dijk1[cand - 1])) ans.add(cand); } ans.sort((l, r) -&amp;gt; l - r); for(int e: ans) sb.append(e + &quot; &quot;); sb.append(&quot;\\n&quot;); } print(sb); } static void dijkstra(int[][] dis, long[] dijk, int basis) { boolean[] visit = new boolean[dijk.length]; PriorityQueue&amp;lt;DIJK&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; (int)(l.dis - r.dis)); for(int i = 0; i &amp;lt; dis.length; i++) if(dis[basis][i] !=0 ) pq.add(new DIJK((long)dis[basis][i], i)); visit[basis] = true; while(!pq.isEmpty()) { DIJK bottom = pq.poll(); if(visit[bottom.idx]) continue; dijk[bottom.idx] = bottom.dis; visit[bottom.idx] = true; for(int i = 0; i &amp;lt; dis.length; i++) if(!visit[i] &amp;amp;&amp;amp; dis[bottom.idx][i] != 0 &amp;amp;&amp;amp; (bottom.dis + dis[bottom.idx][i] &amp;lt; dijk[i])) { pq.add(new DIJK((long)bottom.dis + dis[bottom.idx][i], i)); } } } static class DIJK{ long dis; int idx; public DIJK(long dis, int idx) { this.dis = dis; this.idx = idx; } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine(BufferedReader br) throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "LeetCode. 312. Burst Balloons", "url": "/posts/Leetcode-312.-Burst-Balloons/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Dynamic Programming, Burst Balloons, Review", "date": "2022-01-01 22:15:00 +0900", "snippet": "[Link] https://leetcode.com/problems/burst-balloons/Bottom-Up(Fast)class Solution { public int maxCoins(int[] nums) { int n = nums.length; int[] ball = new int[n + 2]; int[][] dp = new int[n][n]; for(int i = 1; i &amp;lt;= n; i++) ball[i] = nums[i - 1]; ball[0] = ball[n + 1] = 1; for(int i = 1; i &amp;lt;= n; i++) dp[i - 1][i - 1] = ball[i - 1] * ball[i] * ball[i + 1]; for(int dl = 1; dl &amp;lt; n; dl++) { // len is dl + 1 for(int l = 1, ul = n - dl; l &amp;lt;= ul; l++) { int max = -1, mul = ball[l - 1] * ball[l + dl + 1]; max = Math.max(max, ball[l] * mul + dp[l][l + dl - 1]); max = Math.max(max, ball[l + dl] * mul + dp[l - 1][l + dl - 2]); for(int k = l + 1; k &amp;lt; l + dl; k++) max = Math.max(max, dp[l - 1][k - 2] + dp[k][l + dl - 1] + ball[k] * mul); dp[l - 1][l + dl - 1] = max; } } return dp[0][n-1]; }} Top-Down(Slow) class Solution { public int maxCoins(int[] nums) { int n = nums.length; int[] ball = new int[n + 2]; int[][] dp = new int[n][n]; ball[0] = 1; for(int i = 1; i &amp;lt;= n; i++) ball[i] = nums[i - 1]; ball[n + 1] = 1; return dfs(dp, ball, 1, n); } int dfs(int[][] dp, int[] ball, int left, int right) { if(left &amp;gt; right) return 0; if(dp[left - 1][right - 1] != 0) return dp[left - 1][right - 1]; if(left == right) return dp[left - 1][left - 1] = ball[left - 1] * ball[left] * ball[left + 1]; for(int i = left; i &amp;lt;= right; i++) { dp[left - 1][right - 1] = Math.max(dp[left - 1][right - 1], ball[left - 1] * ball[i] * ball[right + 1] + dfs(dp, ball, left, i - 1) + dfs(dp, ball, i + 1, right)); } return dp[left - 1][right - 1]; }} Wrong code( O(n^2) ) class Solution { public int maxCoins(int[] nums) { ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); list.add(1); for(int e: nums) list.add(e); list.add(1); int sum = 0, max, maxIdx; while(list.size() &amp;gt; 2) { max = Integer.MIN_VALUE; maxIdx = -1; // println(list); for(int i = 1; i &amp;lt; list.size() - 1; i++) { int dcoin = getDiff(list, i); // print(&quot; [ &quot; + i + &quot; : &quot; + dcoin + &quot; ] &amp;amp;&amp;amp;&quot;); if(dcoin &amp;gt; max) { maxIdx = i; max = dcoin; } } sum += getCoin(list, maxIdx); // println(&quot;\\nidx: &quot; + maxIdx + &quot; , ballon: &quot; + list.get(maxIdx) + &quot; , sum: &quot; + sum); list.remove(maxIdx); } return sum; } int getCoin(ArrayList&amp;lt;Integer&amp;gt; list, int i) { return getOrDefault(list, i - 1) * getOrDefault(list, i) * getOrDefault(list, i + 1); } int getDiff(ArrayList&amp;lt;Integer&amp;gt; list, int i) { return getOrDefault(list, i - 2) * getOrDefault(list, i - 1) * (getOrDefault(list, i + 1) - getOrDefault(list, i)) + getOrDefault(list, i + 1) * getOrDefault(list, i + 2) * (getOrDefault(list, i - 1) - getOrDefault(list, i)); } int getOrDefault(ArrayList&amp;lt;Integer&amp;gt; list, int idx) { if(idx &amp;lt; 0 || idx &amp;gt;= list.size()) return 0; return list.get(idx); } &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Shortest path with specification (1504)", "url": "/posts/BOJ-1504/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Dijkstra, Graph, Shortest path with specification, 특정한 최단 경로", "date": "2022-01-01 03:54:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1504//Edge Case: Vertext that must to be included could be start or end point(line 71)import java.util.*;import java.io.*;public class Main { static int NUM = 1000000007; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), e = toi(line[1]); Result[] tmp; ArrayList&amp;lt;ArrayList&amp;lt;Distance&amp;gt;&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) al.add(new ArrayList&amp;lt;&amp;gt;()); for(int i = 0; i &amp;lt; e; i++) { line = br.readLine().split(&quot; &quot;); int a = toi(line[0]), b = toi(line[1]), c = toi(line[2]); al.get(a - 1).add(new Distance(b - 1, c)); al.get(b - 1).add(new Distance(a - 1, c)); } line = br.readLine().split(&quot; &quot;); int v1 = toi(line[0]) - 1, v2 = toi(line[1]) - 1; Result start_v1, start_v2, v1_v2, v1_end, v2_end; tmp = dijkstra(al, 0, new int[] { v1, v2 }); start_v1 = tmp[0]; start_v2 = tmp[1]; tmp = dijkstra(al, n - 1, new int[] { v1, v2 }); v1_end = tmp[0]; v2_end = tmp[1]; tmp = dijkstra(al, v1, new int[] { v2 }); v1_v2 = tmp[0]; int len1 = 0, len2 = 0; if(!v1_v2.visit) { print(-1); } else if(start_v1.visit &amp;amp;&amp;amp; v2_end.visit) { if(start_v2.visit &amp;amp;&amp;amp; v1_end.visit) print(Math.min(start_v1.dis + v1_v2.dis + v2_end.dis, start_v2.dis + v1_v2.dis + v1_end.dis)); else print(start_v1.dis + v1_v2.dis + v2_end.dis); } else { if(start_v2.visit &amp;amp;&amp;amp; v1_end.visit) print(start_v2.dis + v1_v2.dis + v1_end.dis); else print(-1); } } static Result[] dijkstra(ArrayList&amp;lt;ArrayList&amp;lt;Distance&amp;gt;&amp;gt; al, int vertext, int[] dest) { int[] dis = new int[al.size()]; Arrays.fill(dis, Integer.MAX_VALUE); dis[vertext] = 0; boolean[] visit = new boolean[al.size()]; visit[vertext] = true; PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l[1] - r[1]); for(Distance d: al.get(vertext)) { pq.add(new int[] { d.dest, d.dis }); dis[d.dest] = d.dis; } while(!pq.isEmpty()) { int[] bottom = pq.poll(); if(visit[bottom[0]]) continue; visit[bottom[0]] = true; for(Distance d: al.get(bottom[0])) { if(visit[d.dest]) continue; dis[d.dest] = Math.min(dis[d.dest], dis[bottom[0]] + d.dis); pq.add(new int[] { d.dest, dis[d.dest]}); } } Result[] ans = new Result[dest.length]; for(int i = 0; i &amp;lt; dest.length; i++) { ans[i] = new Result(dis[dest[i]], visit[dest[i]]); } return ans; } static class Distance { int dest; int dis; public Distance(int dest, int dis) { this.dest = dest; this.dis = dis; } } static class Result { int dis; boolean visit; public Result(int dis, boolean visit) { this.dis = dis; this.visit = visit; } } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Prefix Product (11505)", "url": "/posts/BOJ-11505/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Segment Tree, BOJ, Prefix Product, 구간 곱 구하기", "date": "2021-12-31 23:13:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11505import java.util.*;import java.io.*;public class Main { static int NUM = 1000000007; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), m = toi(line[1]), k = toi(line[2]); int[] arr = new int[n]; int[] seg = new int[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n) / Math.log(2) + 1)]; for(int i = 0; i &amp;lt; n; i++) arr[i] = toi(br.readLine()); init(seg, arr, 0, n - 1, 1); for(int i = 0, il = k + m; i &amp;lt; il; i++) { line = br.readLine().split(&quot; &quot;); int b = toi(line[1]), c = toi(line[2]); if(line[0].equals(&quot;1&quot;)) update(seg, 0, n - 1, 1, b - 1, c); else sb.append(get(seg, 0, n - 1, 1, b - 1, c - 1)).append(&quot;\\n&quot;); } print(sb); } static int init(int[] seg, int[] arr, int start, int end, int idx) { if(start == end) return seg[idx] = arr[start]; int mid = (start + end) / 2; return seg[idx] = (int)((long) init(seg, arr, start, mid, 2 * idx) * init(seg, arr, mid + 1, end, 2 * idx + 1) % NUM) ; } static int update(int[] seg, int start, int end, int idx, int targetIdx, int val) { if(targetIdx &amp;lt; start || end &amp;lt; targetIdx) return seg[idx]; if(start == end) { seg[idx] = val; return seg[idx]; } int mid = (start + end) / 2; return seg[idx] = (int)((long)update(seg, start, mid, 2 * idx, targetIdx, val) * update(seg, mid + 1, end, 2 * idx + 1, targetIdx, val) % NUM) ; } static int get(int[] seg, int start, int end, int idx, int targetL, int targetR) { if(end &amp;lt; targetL || targetR &amp;lt; start) return 1; if(targetL &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= targetR) return seg[idx]; int mid = (start + end) / 2; return (int)((long)get(seg, start, mid, 2 * idx, targetL, targetR) * get(seg, mid + 1, end, 2 * idx + 1, targetL, targetR) % NUM); } // static int rev(int n) { // int remainder = 1, store = n, iter = NUM - 2; // while(iter &amp;gt; 0) { // if((iter &amp;amp; 1) == 1) remainder = (int)((long)remainder * store % NUM); // store = (int)((long)store * store % NUM); // iter = iter &amp;gt;&amp;gt; 1; // } // return remainder; // } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }} failed code import java.util.*;import java.io.*;public class Main { static int NUM = 1000000007; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), m = toi(line[1]), k = toi(line[2]); int[] arr = new int[n]; Arrays.fill(arr, 1); int[] seg = new int[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n) / Math.log(2) + 1)]; boolean[] isZero = new boolean[1 &amp;lt;&amp;lt; (int)Math.ceil(Math.log(n) / Math.log(2) + 1)]; for(int i = 0; i &amp;lt; n; i++) { arr[i] = toi(br.readLine()); } init(seg, arr, 0, n - 1, 1); init(isZero, arr, 0, n - 1, 1); for(int i = 0, il = k + m; i &amp;lt; il; i++) { line = br.readLine().split(&quot; &quot;); int b = toi(line[1]), c = toi(line[2]); if(line[0].equals(&quot;1&quot;)) { if(c != 0) { update(seg, 0, n - 1, 1, b - 1, arr[b - 1], c); arr[b - 1] = c; } update(isZero, 0, n - 1, 1, b - 1, c); } else sb.append(get(seg, isZero, 0, n - 1, 1, b - 1, c - 1)).append(&quot;\\n&quot;); } print(sb); } static int init(int[] seg, int[] arr, int start, int end, int idx) { if(start == end) return arr[start] == 0 ? (seg[idx] = 1) : (seg[idx] = arr[start]); int mid = (start + end) / 2; return seg[idx] = (int)((long) init(seg, arr, start, mid, 2 * idx) * init(seg, arr, mid + 1, end, 2 * idx + 1) % NUM); } static boolean init(boolean[] isZero, int[] arr, int start, int end, int idx) { if(start == end) return arr[start] == 0 ? (isZero[idx] = true) : false; int mid = (start + end) / 2; return isZero[idx] = init(isZero, arr, start, mid, 2 * idx) || init(isZero, arr, mid + 1, end, 2 * idx + 1); } static void update(int[] seg, int start, int end, int idx, int targetIdx, int div, int mul) { if(targetIdx &amp;lt; start || end &amp;lt; targetIdx) return; if(start == end) { seg[idx] = mul; return; } int mid = (start + end) / 2; seg[idx] = (int)(((long)seg[idx]) * (div == 0 ? 1 : rev(div)) * mul % NUM); if(targetIdx &amp;lt;= mid) update(seg, start, mid, 2 * idx, targetIdx, div, mul); else update(seg, mid + 1, end, 2 * idx + 1, targetIdx, div, mul); } static boolean update(boolean[] isZero, int start, int end, int idx, int targetIdx, int mul) { if(targetIdx &amp;lt; start || end &amp;lt; targetIdx) return isZero[idx]; if(start == end) return mul == 0 ? (isZero[idx] = true) : (isZero[idx] = false); int mid = (start + end) / 2; return isZero[idx] = update(isZero, start, mid, 2 * idx, targetIdx, mul) || update(isZero, mid + 1, end, 2 * idx + 1, targetIdx, mul); } static int get(int[] seg, boolean[] isZero, int start, int end, int idx, int targetL, int targetR) { if(end &amp;lt; targetL || targetR &amp;lt; start) return 1; if(targetL &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= targetR) return isZero[idx] ? 0 : seg[idx]; int mid = (start + end) / 2; return (int)((long)get(seg, isZero, start, mid, 2 * idx, targetL, targetR) * get(seg, isZero, mid + 1, end, 2 * idx + 1, targetL, targetR) % NUM); } static int rev(int n) { int remainder = 1, store = n, iter = NUM - 2; while(iter &amp;gt; 0) { if((iter &amp;amp; 1) == 1) remainder = (int)((long)remainder * store % NUM); store = (int)((long)store * store % NUM); iter = iter &amp;gt;&amp;gt; 1; } return remainder; } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Shortest Path (1753)", "url": "/posts/BOJ-1753/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, DFS, Shortest Path, 최단경로", "date": "2021-12-31 08:50:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1753import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); ArrayList&amp;lt;HashMap&amp;lt;Integer, Integer&amp;gt;&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int gv = toi(line[0]), e = toi(line[1]), k = toi(br.readLine()); int[] dis = new int[gv]; PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((l, r) -&amp;gt; l[1] - r[1]); Arrays.fill(dis, Integer.MAX_VALUE); boolean[] visit = new boolean[gv]; visit[k - 1] = true; for(int i = 0; i &amp;lt; gv; i++) { al.add(new HashMap&amp;lt;Integer, Integer&amp;gt;()); } for(int i = 0; i &amp;lt; e; i++) { line = br.readLine().split(&quot; &quot;); int u = toi(line[0]), v = toi(line[1]), w = toi(line[2]); Integer v1 = al.get(u - 1).get(v - 1); if(v1 == null || w &amp;lt; v1) al.get(u - 1).put(v - 1, w); } for(Map.Entry&amp;lt;Integer, Integer&amp;gt; entry: al.get(k - 1).entrySet()) { dis[entry.getKey()] = entry.getValue(); pq.add(new int[] { entry.getKey(), entry.getValue()}); } while(!pq.isEmpty()) { int[] bottom = pq.poll(); if(visit[bottom[0]]) continue; for(Map.Entry&amp;lt;Integer, Integer&amp;gt; entry: al.get(bottom[0]).entrySet()) if(dis[bottom[0]] &amp;lt; dis[entry.getKey()] - entry.getValue()) { dis[entry.getKey()] = dis[bottom[0]] + entry.getValue(); pq.add(new int[] {entry.getKey(), dis[entry.getKey()] }); } visit[bottom[0]] = true; } for(int i = 0; i &amp;lt; dis.length; i++) { if(i == k - 1) sb.append(0).append(&quot;\\n&quot;); else { if(dis[i] == Integer.MAX_VALUE) sb.append(&quot;INF\\n&quot;); else sb.append(dis[i]).append(&quot;\\n&quot;); } } System.out.print(sb); } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Programmers. Network", "url": "/posts/Programmers-Network/", "categories": "Record, Code", "tags": "Algorithm, JavaScript, Coding Interview, Programmers, Network, 네트워크, 프로그래머스", "date": "2021-12-31 00:30:00 +0900", "snippet": "[Link] https://programmers.co.kr/learn/courses/30/lessons/43162function solution(n, computers) { let cnt = 0; const visit = new Array(computers.length).fill(false); for (let i = 0; i &amp;lt; n; i++) { if (!visit[i]) { cnt++; dfs(computers, visit, i, n); } } return cnt;}function dfs(computers, visit, idx, len) { visit[idx] = true; for (let i = 0; i &amp;lt; len; i++) { if (computers[idx][i] == 1 &amp;amp;&amp;amp; !visit[i] &amp;amp;&amp;amp; i != idx) dfs(computers, visit, i, len); }}" }, { "title": "BOJ. Bipartite Graph (1707)", "url": "/posts/BOJ-1707/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, DFS, Bipartite Graph, 이분 그래프", "date": "2021-12-30 20:51:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1707import java.util.*;import java.io.*;public class Main { static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); public static void main(String[] args) throws IOException { StringBuilder sb = new StringBuilder(); Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); String[] line; int tot = toi(br.readLine()); loop: for(int i = 0; i &amp;lt; tot; i++) { q.clear(); line = br.readLine().split(&quot; &quot;); int v = toi(line[0]), e = toi(line[1]); int[] group = new int[v]; ArrayList&amp;lt;LinkedList&amp;lt;Integer&amp;gt;&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int j = 0; j &amp;lt; v; j++) al.add(new LinkedList&amp;lt;Integer&amp;gt;()); for(int j = 0; j &amp;lt; e; j++) { line = br.readLine().split(&quot; &quot;); al.get(toi(line[0]) - 1).add(toi(line[1]) - 1); al.get(toi(line[1]) - 1).add(toi(line[0]) - 1); } for(int j = 0; j &amp;lt; v; j++) { if(group[j] == 0) { q.add(j); group[j] = 1; while(!q.isEmpty()) { int bottom = q.poll(); for(int e1: al.get(bottom)) { if(group[e1] != 0) { if((group[bottom] &amp;amp; group[e1]) != 0) { sb.append(&quot;NO\\n&quot;); continue loop; } continue; } group[e1] = (group[bottom] &amp;amp; 1) + 1; // group[bottom] == 1 ? 2 : 1 q.add(e1); } } } } sb.append(&quot;YES\\n&quot;); } System.out.print(sb); } static int toi(String s) { return Integer.parseInt(s); }}" }, { "title": "BOJ. Move the Knight (7562)", "url": "/posts/BOJ-7562/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, DFS, Move the Knight, 나이트의 이동", "date": "2021-12-30 18:49:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/7562import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); Queue&amp;lt;int[]&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); int[][] step; int tot = toi(br.readLine()); int[] di = new int[] {1, 2}, dj = new int[] {2, 1}, sign = new int[] {1, -1}; loop: for(int i = 0; i &amp;lt; tot; i++) { q.clear(); int l = toi(br.readLine()); int[] orig = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); int[] dest = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); if(orig[0] == dest[0] &amp;amp;&amp;amp; orig[1] == dest[1]) { sb.append(&quot;0\\n&quot;); continue; } step = new int[l][l]; q.add(orig); while(!q.isEmpty()) { int[] bottom = q.poll(); for(int j = 0; j &amp;lt; 2; j++) { // sign i for(int k = 0; k &amp;lt; 2; k++) { //sign j for(int m = 0; m &amp;lt; 2; m++) { int ii = bottom[0] + sign[j] * di[m], jj = bottom[1] + sign[k] * dj[m]; if(ii &amp;lt; 0 || ii &amp;gt;= l || jj &amp;lt; 0 || jj &amp;gt;= l || step[ii][jj] != 0) continue; if(ii == dest[0] &amp;amp;&amp;amp; jj == dest[1]) { sb.append(step[bottom[0]][bottom[1]] + 1).append(&quot;\\n&quot;); continue loop; } q.add(new int[]{ ii, jj }); step[ii][jj] = step[bottom[0]][bottom[1]] + 1; } } } } } print(sb); } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "LeetCode. 40. Combination Sum II", "url": "/posts/Leetcode-40.-Combination-Sum-II/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Combination Sum II", "date": "2021-12-30 17:08:00 +0900", "snippet": "[Link] https://leetcode.com/problems/combination-sum-ii/class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] candidates, int target) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); HashMap&amp;lt;Integer, Integer&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); for(int e: candidates){ if(hm.containsKey(e)) hm.put(e, hm.get(e) + 1); else hm.put(e, 1); } List&amp;lt;HashMap.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; entries = new ArrayList&amp;lt;&amp;gt;(hm.entrySet()); dfs(list, new ArrayList&amp;lt;Integer&amp;gt;(), entries, 0, target); return list; } public void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; templist, List&amp;lt;HashMap.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; entries, int idx, int left) { if(left == 0) { list.add(new ArrayList&amp;lt;&amp;gt;(templist)); return; } for(int i = idx; i &amp;lt; entries.size(); i++) { Map.Entry&amp;lt;Integer, Integer&amp;gt; entry = entries.get(i); int val = entry.getKey(); if(val &amp;lt;= left) { int loop = Math.min(left / val, entry.getValue()); for(int j = 0; j &amp;lt; loop; j++) { templist.add(val); left -= val; dfs(list, templist, entries, i + 1, left); } for(int j = 0; j &amp;lt; loop; j++) templist.remove(templist.size() - 1); left += val * loop; } else continue; } } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }} Without HashMap(ArrayList + Array) class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] candidates, int target) { ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); int[] cnt = new int[51]; int tmp = 0; Arrays.sort(candidates); for(int e: candidates){ if(tmp != e) { tmp = e; al.add(tmp); } cnt[tmp]++; } dfs(list, new ArrayList&amp;lt;Integer&amp;gt;(), al, cnt, 0, target); return list; } public void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; templist, ArrayList&amp;lt;Integer&amp;gt; al, int[] cnt, int idx, int left) { if(left == 0) { list.add(new ArrayList&amp;lt;&amp;gt;(templist)); return; } for(int i = idx; i &amp;lt; al.size(); i++) { int val = al.get(i); if(val &amp;lt;= left) { int loop = Math.min(left / val, cnt[val]); for(int j = 0; j &amp;lt; loop; j++) { templist.add(val); left -= val; dfs(list, templist, al, cnt, i + 1, left); } for(int j = 0; j &amp;lt; loop; j++) templist.remove(templist.size() - 1); left += val * loop; } else return; } }}" }, { "title": "AtCoder. 020 Log Inequality(3)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-020-Log-Inequality/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Log Inequality", "date": "2021-12-30 03:03:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_timport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(&quot; &quot;); long a = atol(line[0]), b = atol(line[1]), c = atol(line[2]); System.out.println(a &amp;lt; pow(c, b) ? &quot;Yes&quot; : &quot;No&quot;); } public static long pow(int base, int exp) { long l = 1; for(int i = 0; i &amp;lt; exp; i++) l *= base; return l; } public static long atol(String s) { return Long.parseLong(s); }}" }, { "title": "AtCoder. 018 Statue of Chokudai(3)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-018-Statue-of-Chokudai(3)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Statue of Chokudai", "date": "2021-12-30 03:03:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_rimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int time = atoi(br.readLine()); String[] tmp = br.readLine().split(&quot; &quot;); double r = (double)atoi(tmp[0]) / 2; int x = atoi(tmp[1]), y = atoi(tmp[2]); int q = atoi(br.readLine()); for(int i = 0; i &amp;lt; q; i++) { int elapse = atoi(br.readLine()); double proportion = (double)elapse / time, height = getH(proportion, r), distance = getDistance(proportion, r, x, y); sb.append(Math.atan2(height, distance) / Math.PI * 180).append(&quot;\\n&quot;); } System.out.print(sb); } static double getH(double proportion, double r) { return r * (1 - Math.cos(2 * Math.PI * proportion)); } static double getDistance(double proportion, double r, int x, int y) { double yCord = - r * Math.sin(2 * Math.PI * proportion); return Math.sqrt(Math.pow(Math.abs(yCord - y), 2) + (long)x * x); } static int atoi(String s) { return Integer.parseInt(s); }}" }, { "title": "AtCoder. 016 Minimum Coins(3)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-016-Minimum-Coins/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Minimum Coins", "date": "2021-12-30 03:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_pimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(), ans = Integer.MAX_VALUE; int[] input = new int[] { sc.nextInt(), sc.nextInt(), sc.nextInt() }; Arrays.sort(input); int a = input[2], b = input[1] , c = input[0]; int max = 9999; for(int i = Math.min(max, n/a); i &amp;gt;= 0; i--) { for(int j = Math.min(max - i, (n - i * a) / b); j &amp;gt;= 0 ; j--) { int left = n - a * i - b * j, quotient = left / c; if(left - c * quotient == 0) ans = Math.min(ans, i + j + quotient); } } System.out.println(ans); }}" }, { "title": "AtCoder. 015 Don&#39;t be too close(6)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-015-Don't-be-too-close(6)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Don't be too close", "date": "2021-12-30 03:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_oimport java.util.*;import java.io.*;public class Main { static final int constv = (int)1e9 + 7; static long[] fac; static long[] rev; static long[] revFac; public static void main(String[] args) throws IOException { Scanner sc = new Scanner(System.in); StringBuilder sb = new StringBuilder(); int n = sc.nextInt(); fac = new long[n + 1]; rev = new long[n + 1]; revFac = new long[n + 1]; fac[0] = revFac[0] = 1; rev[1] = fac[1] = revFac[1] = 1; for(int i = 2; i &amp;lt;= n; i++) { fac[i] = (fac[i - 1] * i) % constv; int quotient = constv / i; rev[i] = constv - quotient * rev[constv - i * quotient] % constv; revFac[i] = revFac[i-1] * rev[i] % constv; } for(int i = 1; i &amp;lt;= n; i++) { int cnt = 1; long sum = 0; while(true) { int pn = n - (cnt - 1)*(i - 1); if(pn &amp;lt; cnt) break; sum = (sum + combi(pn, cnt)) % constv; cnt++; } sb.append(sum+&quot;\\n&quot;); } System.out.print(sb); } static long combi(int n, int k) { return (fac[n] * revFac[k] % constv) * revFac[n-k] % constv; }}" }, { "title": "AtCoder. 014 We Used to Sing a Song Together(3)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-014-We-Used-to-Sing-a-Song-Together/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, We Used to Sing a Song Together", "date": "2021-12-30 03:00:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_nimport java.util.*;import java.io.*;public class Main{ static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st; public static void main(String[] args) throws IOException { StringBuilder sb = new StringBuilder(); readLine(); int n = getInt(); int[] a = new int[n], b = new int[n]; readLine(); for(int i = 0; i &amp;lt; n; i++) { a[i] = getInt(); } readLine(); for(int i = 0; i &amp;lt; n; i++) { b[i] = getInt(); } Arrays.sort(a); Arrays.sort(b); long sum = 0; for(int i = 0; i &amp;lt; n; i++) sum += Math.abs(a[i] - b[i]); System.out.println(sum); } static int getInt() { return Integer.parseInt(st.nextToken()); } static void readLine() throws IOException { st = new StringTokenizer(br.readLine()); }}" }, { "title": "AtCoder. 013 Passing(5)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-013-Passing(5)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Graph, Passing, Review, difficult", "date": "2021-12-30 02:58:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_mimport java.util.*;import java.io.*;public class Main{ static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st; static ArrayList&amp;lt;HashMap&amp;lt;Integer, Integer&amp;gt;&amp;gt; al; static int n, m; static PriorityQueue&amp;lt;Node&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { StringBuilder sb = new StringBuilder(); readLine(); n = getInt(); m = getInt(); al = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt;= n; i++) { al.add(new HashMap&amp;lt;&amp;gt;()); } for(int i = 0; i &amp;lt; m; i++) { readLine(); int t1 = getInt(), t2 = getInt(), cost = getInt(); al.get(t1).put(t2, cost); al.get(t2).put(t1, cost); } long[] dp1 = dijkstra(1); long[] dpN = dijkstra(n); for(int i = 1; i &amp;lt;= n; i++) sb.append(dp1[i] + dpN[i] + &quot;\\n&quot;); System.out.print(sb); } static long[] dijkstra(int idx) { boolean[] visited = new boolean[n + 1]; long[] dp = new long[n + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[idx] = 0; q.add(new Node(idx, 0)); while(!q.isEmpty()) { Node node = q.poll(); visited[node.vertex] = true; if(dp[node.vertex] &amp;lt; node.cost) continue; for(Map.Entry&amp;lt;Integer, Integer&amp;gt; entry : al.get(node.vertex).entrySet()) { int desV = entry.getKey(), cost = entry.getValue(); if(visited[desV]) continue; if(dp[desV] &amp;gt; (long)node.cost + cost) { dp[desV] = node.cost + cost; q.add(new Node(desV, dp[desV])); } } } return dp; } static int getInt() { return Integer.parseInt(st.nextToken()); } static void readLine() throws IOException { st = new StringTokenizer(br.readLine()); }}class Node implements Comparable&amp;lt;Node&amp;gt; { int vertex; long cost; public Node(int v, long c) { this.vertex = v; this.cost = c; } public int compareTo(Node node) { return Long.compare(cost, node.cost); }}" }, { "title": "AtCoder. 012 Red Painting(4)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-012-Red-Painting(4)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Red Painting", "date": "2021-12-30 02:50:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_limport java.util.*;import java.io.*;public class Main{ static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st; static int h, w, q; static int[][] link; static int[] dx = {1, 0, -1, 0}; static int[] dy = {0, 1, 0, -1}; public static void main(String[] args) throws IOException { readLine(); h = getInt(); w = getInt(); readLine(); q = getInt(); link = new int[h + 1][w + 1]; StringBuilder sb = new StringBuilder(); int cnt = 0; for(int i = 0; i &amp;lt; q; i++) { readLine(); int t = getInt(); if(t == 1) { int y = getInt(), x = getInt(), count = 0, val = 0; ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); for(int j = 0; j &amp;lt; 4; j++) { int py = y + dy[j], px = x + dx[j]; if(inRange(py, px) &amp;amp;&amp;amp; link[py][px] &amp;gt; 0) { al.add(j); if(val == 0) val = link[py][px]; count++; } } if(count == 0) { link[y][x] = ++cnt; } else if(count == 1) link[y][x] = val; else { link[y][x] = val; for(int idx = 0; idx &amp;lt; al.size(); idx++) { int j = al.get(idx); if(link[y + dy[j]][x + dx[j]] != val) { repaint(y + dy[j], x + dx[j], val); } } } } else { int y1 = getInt(), x1 = getInt(), y2 = getInt(), x2 = getInt(); if(link[y1][x1] &amp;gt; 0 &amp;amp;&amp;amp; link[y1][x1] == link[y2][x2]) sb.append(&quot;Yes\\n&quot;); else sb.append(&quot;No\\n&quot;); } } System.out.print(sb); } static void repaint(int i, int j, int paintVal) { boolean[][] visited = new boolean[h + 1][w + 1]; Queue&amp;lt;int[]&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); int origVal = link[i][j]; q.add(new int[] { i , j }); while(!q.isEmpty()) { int[] bot = q.poll(); if(visited[bot[0]][bot[1]]) continue; visited[bot[0]][bot[1]] = true; link[bot[0]][bot[1]] = paintVal; for(int l = 0; l &amp;lt; 4; l++) { int y = bot[0] + dy[l], x = bot[1] + dx[l]; if(!inRange(y, x)) continue; if(!visited[y][x] &amp;amp;&amp;amp; link[y][x] == origVal) { q.add(new int[] { y, x }); } } } } static boolean inRange(int i, int j) { return i &amp;gt;= 1 &amp;amp;&amp;amp; j &amp;gt;= 1 &amp;amp;&amp;amp; i &amp;lt;= h &amp;amp;&amp;amp; j &amp;lt;= w; } static int getInt() { return Integer.parseInt(st.nextToken()); } static void readLine() throws IOException { st = new StringTokenizer(br.readLine()); }}TLE(BFS) code(below)import java.util.*;import java.io.*;public class Main{ static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st; static boolean[][] colored; static int h, w, q; public static void main(String[] args) throws IOException { readLine(); h = getInt(); w = getInt(); readLine(); q = getInt(); colored = new boolean[h + 1][w + 1]; StringBuilder sb = new StringBuilder(); int qcnt = 1; for(int i = 0; i &amp;lt; q; i++) { readLine(); int t = getInt(); if(t == 1) { int y = getInt(), x = getInt(); colored[y][x] = true; } else { int y1 = getInt(), x1 = getInt(), y2 = getInt(), x2 = getInt(); if(colored[y1][x1] &amp;amp;&amp;amp; colored[y2][x2] &amp;amp;&amp;amp; isConnected(y1, x1, y2, x2)) sb.append(&quot;Yes\\n&quot;); else sb.append(&quot;No\\n&quot;); } } System.out.print(sb); } static boolean isConnected(int i, int j, int di, int dj) { if(i == di &amp;amp;&amp;amp; j == dj) return true; boolean[][] visited = new boolean[h + 1][w + 1]; Queue&amp;lt;int[]&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); int[] dx = {1, 0, -1, 0}; int[] dy = {0, 1, 0, -1}; q.add(new int[] { i , j }); while(!q.isEmpty()) { int[] bot = q.poll(); if(visited[bot[0]][bot[1]]) continue; visited[bot[0]][bot[1]] = true; for(int l = 0; l &amp;lt; 4; l++) { int y = bot[0] + dy[l], x = bot[1] + dx[l]; if(!inRange(y, x)) continue; if(!visited[y][x] &amp;amp;&amp;amp; colored[y][x]) { if(y == di &amp;amp;&amp;amp; x == dj) return true; q.add(new int[] { y, x }); } } } return false; } static boolean inRange(int i, int j) { return i &amp;gt;= 1 &amp;amp;&amp;amp; j &amp;gt;= 1 &amp;amp;&amp;amp; i &amp;lt;= h &amp;amp;&amp;amp; j &amp;lt;= w; } static int getInt() { return Integer.parseInt(st.nextToken()); } static void readLine() throws IOException { st = new StringTokenizer(br.readLine()); }}" }, { "title": "AtCoder. 011 Gravy Jobs(6)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-011-Gravy-Jobs/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Gravy Jobs, Review, difficult", "date": "2021-12-30 02:50:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_kimport java.util.*;import java.io.*;//1. In schedule, the job which deadline is the longest have to go at last//-&amp;gt; Applying 1 recursively, ideal schedule is sorted in ascending order of deadlinepublic class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int n = Integer.parseInt(br.readLine()); long[] dp; LinkedList&amp;lt;int[]&amp;gt; info = new LinkedList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { st = new StringTokenizer(br.readLine()); int[] temp = new int[3]; for(int j = 0; j &amp;lt; 3; j++) temp[j] = Integer.parseInt(st.nextToken()); info.add(temp); } info.sort((l, r) -&amp;gt; l[0] - r[0]); int range = 0; dp = new long[info.get(n - 1)[0] + 1]; for(int i = 0; i &amp;lt; n; i++) { int[] newInfo = info.get(i); for(int j = newInfo[0]; j &amp;gt;= newInfo[1]; j--) { fillArr(dp, j, Math.max(dp[j], dp[j - newInfo[1]] + newInfo[2])); } } for(long e: dp ) System.out.print(e + &quot; &quot;); System.out.println(dp[dp.length - 1]); } static void fillArr(long[] arr, int idx, long v) { for(int i = idx; i &amp;lt; arr.length; i++) { if(v &amp;lt;= arr[i]) return; arr[i] = v; } }}" }, { "title": "AtCoder. 010 Score Sum Queries(2)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-010-Score-Sum-Queries/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Score Sum Queries", "date": "2021-12-30 02:50:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_jimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; StringBuilder sb = new StringBuilder(); int n = Integer.parseInt(reader.readLine()); int[] classOne = new int[n + 1]; int[] classTwo = new int[n + 1]; for(int i = 1; i &amp;lt;= n; i++) { st = new StringTokenizer(reader.readLine()); int classN = Integer.parseInt(st.nextToken()); int score = Integer.parseInt(st.nextToken()); classOne[i] = classOne[i-1]; classTwo[i] = classTwo[i-1]; if(classN == 1) classOne[i] += score; else classTwo[i] += score; } int q = Integer.parseInt(reader.readLine()); for(int i = 1; i &amp;lt;= q; i++) { st = new StringTokenizer(reader.readLine()); int l = Integer.parseInt(st.nextToken()); int r = Integer.parseInt(st.nextToken()); int sum1 = classOne[r] - classOne[l-1], sum2 = classTwo[r] - classTwo[l-1]; sb.append(sum1 + &quot; &quot; + sum2).append(&quot;\\n&quot;); } System.out.print(sb); }}" }, { "title": "AtCoder. 009 Three Point Angle(6)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-009-Three-Point-Angle/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Three Point Angle, Review", "date": "2021-12-30 02:50:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_iimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int n = Integer.parseInt(reader.readLine()); double min = Double.MAX_VALUE; int[][] p = new int[n][2]; for(int i = 0; i &amp;lt; n; i++) { st = new StringTokenizer(reader.readLine()); p[i][0] = Integer.parseInt(st.nextToken()); p[i][1] = Integer.parseInt(st.nextToken()); } for(int i = 0 ; i &amp;lt; n ; i++) { double[] sort = new double[n - 1]; // n-1 int idx = 0; for(int j = 0; j &amp;lt; n; j++) { if(i == j) continue; sort[idx++] = getAngle(p[i], p[j]); getAngle(p[i], p[j]); } Arrays.sort(sort); for(int k = 0; k &amp;lt; n - 1; k++) { double toFind = (180 + sort[k]) % 360; int l = 0, r = n-2, mid; while(l &amp;lt; r) { mid = (l + r) / 2; if(l == r - 1) { double smaller = Math.min(Math.abs(sort[l] - toFind), Math.abs(sort[r] - toFind)); min = Math.min(smaller, min); break; } if(sort[mid] &amp;lt; toFind) l = mid; else if(sort[mid] == toFind) { min = 0; break; } else r = mid; } } } if(min == Double.valueOf((int)min)) System.out.println(180 - (int)min); else System.out.println(180 - min); } static double getAngle(int[] zeroP, int[] p) { int dx, dy; dx = p[0] - zeroP[0]; dy = p[1] - zeroP[1]; double theta = Math.atan2(dy, dx); return theta &amp;gt;= 0 ? theta : (360 + theta); } // static double getAngle(int[] zeroP, int[] p) { // long dx, dy; // dx = p[0] - zeroP[0]; // dy = p[1] - zeroP[1]; // double theta = Math.acos((double)dx / Math.sqrt(dx*dx + dy*dy)) * 180 / Math.PI; // return dy &amp;gt;= 0 ? theta : (360 - theta); // }}" }, { "title": "AtCoder. 008 AtCounter(4)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-008-AtCounter(4)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, AtCounter", "date": "2021-12-30 02:47:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_himport java.util.*;import java.io.*;//my mistake : line 15 : if(arr[0] == str[j]) dp[0][j] = 1;public class Main { public static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(reader.readLine()); int con = (int)(1e9 + 7); char[] arr = reader.readLine().toCharArray(); char[] str = &quot;AtCoder&quot;.toCharArray(); long[][] dp = new long[n][7]; reader.close(); for(int j = 0; j &amp;lt; 7; j++) if(arr[0] == &#39;a&#39;) dp[0][0] = 1; for(int i = 1; i &amp;lt; n; i++) { // idx of arr for(int j = 0; j &amp;lt; 7; j++) { // dp[i][j] = dp[i-1][j]; if(arr[i] == str[j]) { if(j == 0) dp[i][j]++; else dp[i][j] += dp[i-1][j-1]; dp[i][j] %= con; } } } System.out.println(dp[n - 1][6]); }}" }, { "title": "AtCoder. 007 CP Classes(3)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-007-CP-Classes(3)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, CP Classes", "date": "2021-12-30 02:46:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_gimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br =new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; StringBuilder sb = new StringBuilder(); int[] a, b, tmp; int n, q, min; n = Integer.parseInt(br.readLine()); a = new int[n]; st = new StringTokenizer(br.readLine()); for(int i = 0; i &amp;lt; n; i++) a[i] = Integer.parseInt(st.nextToken()); Arrays.sort(a); q = Integer.parseInt(br.readLine()); b = new int[q]; for(int i = 0; i &amp;lt; q; i++) b[i] = Integer.parseInt(br.readLine()); for(int i = 0; i &amp;lt; q; i++) { int v = b[i]; int l = 0, r = a.length - 1, mid; min = Integer.MAX_VALUE; while(l &amp;lt; r - 1) { mid = (l + r) / 2; if(a[mid] &amp;gt; v) { r = mid; } else if(a[mid] == v) { l = r = mid; break; } else { l = mid; } } sb.append(Math.min(Math.abs(a[r] - v), (Math.abs(a[l] - v)))).append(&quot;\\n&quot;); } System.out.print(sb); }}" }, { "title": "AtCoder. 006 Smallest Subsequence(5)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-006-Smallest-Subsequence/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Smallest Subsequence", "date": "2021-12-30 02:45:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_fimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] argA = br.readLine().split(&quot;\\\\s&quot;); int n = Integer.parseInt(argA[0]); int k = Integer.parseInt(argA[1]); String s = br.readLine(); int idx = 0, tempIdx = 0, len = 0; char temp = 0; while(len != k) { temp = s.charAt(idx); tempIdx = idx; for(; idx &amp;lt;= n - k + len; idx++) { if(temp &amp;gt; s.charAt(idx)) { temp = s.charAt(idx); tempIdx = idx; } } idx = tempIdx + 1; lem++; sb.append(temp); } System.out.println(sb); }}" }, { "title": "AtCoder. 005 Restricted Digits(7)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-005-Restricted-Digits/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Restricted Digits, Review, difficult", "date": "2021-12-30 02:44:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_eimport java.util.*;import java.io.*;public class Main { static int con = 1000000007; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); long n; int b, k, ans = 0; int[] dp; n = Long.parseLong(st.nextToken()); b = Integer.parseInt(st.nextToken()); k = Integer.parseInt(st.nextToken()); st = new StringTokenizer(br.readLine()); dp = new int[b]; for(int i = 0; i &amp;lt; k; i++) dp[Integer.parseInt(st.nextToken()) % b] += 1; int[][] op = new int[b][b]; for(int i = 0; i &amp;lt; b; i++) { for(int j = 0; j &amp;lt; b; j++) { if(dp[j] == 0) continue; int idx = (10 * i + j) % b; op[idx][i] = dp[j]; } } long[][] finalOp = new long[b][b]; for(int i = 0; i &amp;lt; b; i++) finalOp[i][i] = 1; // ArrayList&amp;lt;int[][]&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); // al.add(0, op); // 2^i; long[][] temp = new long[b][b]; for(int i = 0; i &amp;lt; b; i++) for(int j = 0; j &amp;lt; b; j++) temp[i][j] = op[i][j]; int curIdx = 0; boolean determined = false; long v = 1; int idx = 0; n--; while(n &amp;gt; 0) { if(n % 2 == 1) { if(idx &amp;gt; curIdx) { for(int i = curIdx + 1; i &amp;lt;= idx; i++) { temp = sqr(temp); } curIdx = idx; } finalOp = mul(finalOp, temp); } n = n &amp;gt;&amp;gt; 1; idx++; } long ans1 = 0; for(int i = 0; i &amp;lt; b; i++) { ans1 += finalOp[0][i] * dp[i]; ans1 %= con; } System.out.println(ans1); } static long[][] mul(long[][] a, long[][] b) { int len = b.length; long[][] ans = new long[a.length][b[0].length]; for(int i = 0, la = a.length; i &amp;lt; la; i++) { for(int j = 0, lb = b[0].length; j &amp;lt; lb; j++) { for(int k = 0; k &amp;lt; len; k++) { ans[i][j] += a[i][k]*b[k][j]; ans[i][j] %= con; } } } return ans; } static long[] mul(long[][] a, int[] b) { long[] ans = new long[b.length]; for(int i = 0, la = a.length; i &amp;lt; la; i++) { for(int j = 0, lab = b.length; j &amp;lt; lab; j++) { ans[i] += a[i][j] * b[j]; ans[i] %= con; } } return ans; } static long[][] sqr(long[][] a) { return mul(a, a); }}" }, { "title": "AtCoder. 004 Cross Sum(2)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-004-Cross-Sum-2/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Cross Sum", "date": "2021-12-30 02:43:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_dimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); StringBuilder sb = new StringBuilder(); int h = Integer.parseInt(st.nextToken()); int w = Integer.parseInt(st.nextToken()); int[][] arr = new int[h][w]; int[] colSum = new int[w]; int[] rowSum = new int[h]; for(int i = 0; i &amp;lt; h; i++) { st = new StringTokenizer(br.readLine()); for(int j = 0; j &amp;lt; w; j++) { arr[i][j] = Integer.parseInt(st.nextToken()); } } for(int i = 0; i &amp;lt; h; i++) for(int j = 0; j &amp;lt; w; j++) rowSum[i] += arr[i][j]; for(int i = 0; i &amp;lt; w; i++) for(int j = 0; j &amp;lt; h; j++) colSum[i] += arr[j][i]; for(int i = 0; i &amp;lt; h; i++) { for(int j = 0; j &amp;lt; w; j++) sb.append(rowSum[i] + colSum[j] - arr[i][j] + &quot; &quot;); sb.append(&quot;\\n&quot;); } System.out.println(sb); }}" }, { "title": "AtCoder. 003 Longest Circular Road(4)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-003-Longest-Circular-Road-4/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Longest Circular Road", "date": "2021-12-30 02:38:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_cimport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int n = Integer.parseInt(bf.readLine()); ArrayList&amp;lt;HashSet&amp;lt;Integer&amp;gt;&amp;gt; connection = new ArrayList&amp;lt;HashSet&amp;lt;Integer&amp;gt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { connection.add(new HashSet&amp;lt;&amp;gt;()); } Stack&amp;lt;int[]&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(int i = 1; i &amp;lt; n; i++) { st = new StringTokenizer(bf.readLine()); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); connection.get(a - 1).add(b); connection.get(b - 1).add(a); } int max = 0; int farthestTown = 0; int[] temp1 = {1, 0}; stack.push(temp1); boolean[] visited = new boolean[n + 1]; while(!stack.isEmpty()) { int[] top = stack.pop(); int town = top[0]; int len = top[1]; if(visited[town]) continue; visited[town] = true; if(max &amp;lt; len) { max = len; farthestTown = town; } for(int e : connection.get(town - 1)) { if(visited[e]) continue; int[] temp2 = { e, len + 1}; stack.push(temp2); } } int[] temp3 = { farthestTown, 0}; stack.push(temp3); visited = new boolean[n + 1]; while(!stack.isEmpty()) { int[] top = stack.pop(); int town = top[0]; int len = top[1]; if(visited[town]) continue; visited[town] = true; for(int e : connection.get(town - 1)) { if(visited[e]) continue; if(max &amp;lt; len + 1) max = len + 1; int[] temp2 = {e, len + 1}; stack.push(temp2); } } System.out.println(max + 1); }}" }, { "title": "AtCoder. 002 Encyclopedia of Parentheses(3)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-002-Encyclopedia-of-Parentheses-3/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Encyclopedia of Parentheses", "date": "2021-12-30 02:38:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_bimport java.util.*;import java.io.*;public class Main{ static int n; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); if(n%2 == 1) return; char[] charArr = new char[n]; bfs(charArr, 0, 0, 0); System.out.println(sb.toString()); } static void bfs(char[] charArr, int index, int open, int close) { if(index == n) { sb.append(new String(charArr)).append(&quot;\\n&quot;); return; } if(open &amp;lt; n/2 &amp;amp;&amp;amp; close &amp;lt; n/2) { charArr[index] = &#39;(&#39;; open++; bfs(charArr, index + 1 , open, close); open--; if(open &amp;gt; close) { charArr[index] = &#39;)&#39;; close++; bfs(charArr, index + 1 , open, close); close--; } } else if(open == n/2) { for(int i = index; i &amp;lt; n; i++) charArr[i] = &#39;)&#39;; bfs(charArr, n, n/2, n/2); } }}" }, { "title": "AtCoder. 001 Yokan Party(4)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-001-Yokan-Party-4/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Yokan Party", "date": "2021-12-30 02:38:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_aimport java.util.*;import java.io.*;public class Main { public static int[] garr; public static int k, n, l; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); n = Integer.parseInt(st.nextToken()); l = Integer.parseInt(st.nextToken()); k = Integer.parseInt(br.readLine()); st = new StringTokenizer(br.readLine()); garr = new int[n + 1]; garr[0] = 0; for(int i = 1; i &amp;lt;= n; i++) { garr[i] = Integer.parseInt(st.nextToken()); } int right = 1; int left = l; int mid; while(right &amp;lt; left) { mid = (right + left) / 2 + 1; if(statisfy(mid)) right = mid; else left = mid - 1; } System.out.println(left); } static boolean statisfy(int minL) { int end, preV, preIdx, cnt; end = preV = preIdx = cnt = 0; for(int j = preIdx + 1; j &amp;lt;= n; j++) { if(garr[j] - preV &amp;gt;= minL) { preV = garr[j]; preIdx = j; if(++cnt == k) return l - preV &amp;gt;= minL ? true : false; } } return false; }}" }, { "title": "BOJ. Expression of Set (1717)", "url": "/posts/BOJ-1717/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Union Find, Expression of Set, 집합의 표현", "date": "2021-12-29 21:08:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1717import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), m = toi(line[1]); int[] rootIdx = new int[n + 1]; for(int i = 1 ; i &amp;lt;= n; i++) rootIdx[i] = i; for(int i = 0; i &amp;lt; m; i++) { line = br.readLine().split(&quot; &quot;); int a = toi(line[1]), b = toi(line[2]); if(line[0].equals(&quot;0&quot;)) { rootIdx[getRoot(rootIdx, a)] = getRoot(rootIdx, b); } else { if(a == b) sb.append(&quot;YES\\n&quot;); else sb.append(getRoot(rootIdx, a) == getRoot(rootIdx, b) ? &quot;YES\\n&quot; : &quot;NO\\n&quot;); } } print(sb); } static int getRoot(int[] arr, int idx) { if(idx == arr[idx]) return idx; return arr[idx] = getRoot(arr, arr[idx]); } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "LeetCode. 39. Combination Sum", "url": "/posts/Leetcode-39.-Combination-Sum/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Combination Sum", "date": "2021-12-29 20:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/combination-sum/class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); dfs(list, new ArrayList&amp;lt;Integer&amp;gt;(), candidates, 0, target); return list; } void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, ArrayList&amp;lt;Integer&amp;gt; ll, int[] arr, int sIdx, int diff) { if(diff == 0) { list.add(new ArrayList&amp;lt;&amp;gt;( ll)); return; } for(int i = sIdx; i &amp;lt; arr.length; i++) { if(diff &amp;lt; arr[i]) break; ll.add(arr[i]); dfs(list, ll, arr, i, diff - arr[i]); ll.remove(ll.size() - 1); } }}" }, { "title": "BOJ. Move and break wall (2206)", "url": "/posts/BOJ-2206/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Move and break wall, 벽 부수고 이동하기, Review", "date": "2021-12-28 05:56:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2206import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), m = toi(line[1]); boolean[][] canpass = new boolean[n][m]; int[] di = new int[]{ 1, 0, -1, 0 }, dj = new int[] { 0, 1, 0, -1 }; boolean[][][] visited = new boolean[n][m][2]; for(int i = 0; i &amp;lt; n; i++) { String newLine = br.readLine(); for(int j = 0; j &amp;lt; m; j++) if(newLine.charAt(j) == &#39;0&#39;) canpass[i][j] = true; } Queue&amp;lt;Info&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.add(new Info(0, 0, 1, true)); while(!q.isEmpty()) { Info info = q.poll(); int ii = info.i, ij = info.j; if(ii == n - 1 &amp;amp;&amp;amp; ij == m - 1) { print(info.cnt); return; } for(int i = 0; i &amp;lt; 4; i++) { int I = ii + di[i], J =ij + dj[i]; if(I &amp;gt;= n || I &amp;lt; 0 || J &amp;gt;= m || J &amp;lt; 0 || visited[I][J][0] &amp;amp;&amp;amp; visited[I][J][1]) continue; if(canpass[I][J]) { if(!visited[I][J][0] &amp;amp;&amp;amp; info.cb) { q.add(new Info(I, J , info.cnt + 1, true)); visited[I][J][0] = true; } else if(!visited[I][J][1] &amp;amp;&amp;amp; !info.cb) { q.add(new Info(I, J , info.cnt + 1, false)); visited[I][J][1] = true; } } else { if(!visited[I][J][1] &amp;amp;&amp;amp; info.cb) { q.add(new Info(I, J , info.cnt + 1, false)); visited[I][J][1] = true; } } } } print(-1); } static class Info { int i; int j; int cnt; boolean cb; Info(int i , int j, int cnt, boolean cb) { this.i = i; this.j = j; this.cnt = cnt; this.cb = cb; } } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Prefix sum (2042)", "url": "/posts/BOJ-2042/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Segment Tree, BOJ, Prefix sum, 구간 합 구하기", "date": "2021-12-28 01:28:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2042import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), m = toi(line[1]), k = toi(line[2]); long[] arr = new long[n]; long[] seg = new long[1 &amp;lt;&amp;lt; ((long)Math.ceil(Math.log(arr.length) / Math.log(2)) + 1)]; for(int i = 0; i &amp;lt; n; i++) arr[i] = tol(br.readLine()); init(seg, arr, 0, n - 1, 1); for(int i = 0; i &amp;lt; m + k; i++) { line = br.readLine().split(&quot; &quot;); int b = toi(line[1]); long c = tol(line[2]); if(line[0].equals(&quot;1&quot;)) { update(seg, 0, n -1, 1, b - 1, c - arr[b - 1]); arr[b - 1] = c; } else sb.append(sum(seg, 0, n -1, b - 1, (int)c - 1, 1) + &quot;\\n&quot;); } print(sb); } static long init(long[] seg, long[] arr, int l, int r, int idx) { if(l == r) return seg[idx] = arr[l]; int mid = (l + r) / 2; return seg[idx] = init(seg, arr, l , mid, 2 * idx) + init(seg, arr, mid + 1, r, 2 * idx + 1); } static boolean update(long[] seg, int l, int r, int idx, int targetIdx, long diff) { if(l &amp;gt; targetIdx || r &amp;lt; targetIdx) return false;; seg[idx] += diff; if(l == r) return true; int mid = (l + r) / 2; if(!update(seg, l, mid, 2 * idx, targetIdx, diff)) update(seg, mid + 1, r, 2 * idx + 1, targetIdx, diff); return true; } static long sum(long[] seg, int l, int r, int start, int end, int idx) { if(l &amp;gt; end || r &amp;lt; start) return 0; else if(start &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= end) return seg[idx]; int mid = (l + r) / 2; return sum(seg, l, mid, start, end, 2 * idx) + sum(seg, mid + 1, r, start, end, 2 * idx + 1); } static int toi(String s) { return Integer.parseInt(s); } static long tol(String s) { return Long.parseLong(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "BOJ. Hide and Seek (1697)", "url": "/posts/BOJ-1697/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, Hide and Seek, 숨바꼭질", "date": "2021-12-28 00:15:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1697import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(&quot; &quot;); int n = toi(line[0]), k = toi(line[1]); boolean[] visit = new boolean[k + 1]; Queue&amp;lt;int[]&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.add(new int[]{ n, 0}); int min = Integer.MAX_VALUE; while(!q.isEmpty()) { int[] top = q.poll(); int num = top[0], step = top[1]; if(num &amp;lt;= k &amp;amp;&amp;amp; visit[num]) continue; if(num == k) { min = Math.min(min, step); break; } else if(num &amp;gt; k) { min = Math.min(min, step + num - k); continue; } if(num &amp;gt;= 1) q.add(new int[]{num - 1, step + 1}); if(num &amp;lt; k) q.add(new int[] {num + 1, step + 1}); if(num &amp;lt; k) q.add(new int[] { 2 * num, step + 1}); visit[num] = true; } println(min); } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "Programmers. Find number of animals with same name", "url": "/posts/Programmers-Find-number-of-animals-with-same-name/", "categories": "Record, Code", "tags": "SQL, Coding Interview, Programmers, Find number of animals with same name, 동명 동물 수 찾기, 프로그래머스", "date": "2021-12-27 05:30:00 +0900", "snippet": "[Link] https://programmers.co.kr/learn/courses/30/lessons/59041SELECT NAME, COUNT(NAME) AS COUNTFROM ANIMAL_INSWHERE NAME IS NOT NULLGROUP BY NAMEHAVING COUNT(*) &amp;gt;= 2ORDER BY NAME ASC;" }, { "title": "Programmers. Bigest Number", "url": "/posts/Programmers-Bigest-Number/", "categories": "Record, Code", "tags": "Java, Algorithm, PriorityQueue, Coding Interview, Programmers, Bigest Number, 가장 큰 수, 프로그래머스", "date": "2021-12-27 00:56:00 +0900", "snippet": "[Link] https://programmers.co.kr/learn/courses/30/lessons/42746#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;bool compare(int a, int b) { string sa = to_string(a); string sb = to_string(b); return sa + sb &amp;gt; sb + sa;}string solution(vector&amp;lt;int&amp;gt; numbers) { string answer = &quot;&quot;; sort(numbers.begin(), numbers.end(), compare); if(numbers.at(0) == 0) return &quot;0&quot;; for(int num: numbers) answer += to_string(num); return answer;}" }, { "title": "LeetCode. 38. Count and Say", "url": "/posts/Leetcode-38.-Count-and-Say/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Count and Say", "date": "2021-12-26 12:55:00 +0900", "snippet": "[Link] https://leetcode.com/problems/count-and-say/class Solution { public String countAndSay(int n) { StringBuilder sb = new StringBuilder(); sb.append(1); rec(sb, 1, n); return sb.toString(); } public void rec(StringBuilder sb, int idx, int n) { if(idx == n) return; String s = sb.toString(); sb.setLength(0); int i = 0, j = 0, cnt = 0, len = s.length(); while(i &amp;lt; len) { char c = s.charAt(i); j = i; cnt = 1; while(j + 1 &amp;lt; len &amp;amp;&amp;amp; s.charAt(j + 1) == c) { j++; cnt++; } sb.append(cnt).append(c); i += cnt; } rec(sb, idx + 1, n); }}" }, { "title": "BOJ. Tomato (7569)", "url": "/posts/BOJ-7569/", "categories": "Record, Code", "tags": "Java, Algorithm, Heap, Coding Interview, BOJ, Tomato, 토마토", "date": "2021-12-26 10:37:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/7569//Position &amp;lt; int i, int j, int k , int step&amp;gt; =====&amp;gt; Memory exceed!!!import java.util.*;import java.io.*;public class Main { static int m, n, h; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(&quot; &quot;); int[][][] box; Queue&amp;lt;Position&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); m = toi(line[0]); n = toi(line[1]); h = toi(line[2]); box = new int[h][n][m]; int cnt = 0; for(int i = 0; i &amp;lt; h; i++) { for(int j = 0; j &amp;lt; n; j++) { line = br.readLine().split(&quot; &quot;); for(int k = 0; k &amp;lt; m; k++) if(line[k].equals(&quot;1&quot;)) { //Can&#39;t use == (compares with array address) box[i][j][k] = 1; q.add(new Position(i, j, k)); } else if(line[k].equals(&quot;0&quot;)) cnt++; else box[i][j][k] = -1; } } print(bfs(box, q, cnt)); } static class Position { int i; int j; int k; Position(int i, int j, int k) { this.i = i; this.j = j; this.k = k; } } static int bfs(int[][][] box, Queue&amp;lt;Position&amp;gt; q, int left) { int[] di = new int[]{ 1, -1, 0, 0, 0, 0 }; int[] dj = new int[]{ 0, 0, 1, -1, 0, 0 }; int[] dk = new int[]{ 0, 0, 0 , 0, 1, -1}; int max = 0; loop: while(!q.isEmpty()) { Position bottom = q.poll(); int I = bottom.i, J = bottom.j, K = bottom.k, step = box[I][J][K]; for(int i = 0; i &amp;lt; 6; i++) { int si = di[i] + I, sj = dj[i] + J, sk = dk[i] + K; if(0 &amp;lt;= si &amp;amp;&amp;amp; si &amp;lt; h &amp;amp;&amp;amp; 0 &amp;lt;= sj &amp;amp;&amp;amp; sj &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= sk &amp;amp;&amp;amp; sk &amp;lt; m &amp;amp;&amp;amp; box[si][sj][sk] == 0) { box[si][sj][sk] = step + 1; if(--left == 0) { max = Math.max(step + 1, max); break loop; } q.add(new Position(si, sj, sk)); } } max = Math.max(step, max); } return left == 0 ? max - 1 : -1; } static int toi(String s) { return Integer.parseInt(s); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" }, { "title": "LeetCode. 37. Sudoku Solver", "url": "/posts/Leetcode-37.-Sudoku-Solver/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Sudoku Solver", "date": "2021-12-26 08:40:00 +0900", "snippet": "[Link] https://leetcode.com/problems/sudoku-solver/class Solution { char[][] b; public void solveSudoku(char[][] board) { int len = board.length; b = board; solve(); } boolean solve() { for(int i = 0; i &amp;lt; 9; i++) { for(int j = 0; j &amp;lt; 9; j++) { if(b[i][j] == &#39;.&#39;) { for(char k = &#39;1&#39;; k &amp;lt;= &#39;9&#39;; k++) { if(canput(i, j, k)) { b[i][j] = k; if(solve()) return true; } } b[i][j] = &#39;.&#39;; return false; } } } return true; } boolean canput(int row, int col, char v) { for(int i = 0; i &amp;lt; 9; i++) if(b[i][col] == v || b[row][i] == v) return false; for(int si = 3 * (row / 3), i = si; i &amp;lt; si + 3; i++) for(int sj = 3*(col/3), j = sj; j &amp;lt; sj + 3; j++) if(b[i][j] == v) return false; return true; }}" }, { "title": "LeetCode. 36. Valid Sudoku", "url": "/posts/Leetcode-36.-Valid-Sudoku/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Valid Sudoku", "date": "2021-12-24 06:58:00 +0900", "snippet": "[Link] https://leetcode.com/problems/valid-sudoku/class Solution { public boolean isValidSudoku(char[][] board) { HashSet&amp;lt;Character&amp;gt; hmRow = new HashSet&amp;lt;&amp;gt;(); HashSet&amp;lt;Character&amp;gt; hmCol = new HashSet&amp;lt;&amp;gt;(); for(int i = 0, l = board.length; i &amp;lt; l; i++) { hmRow.clear(); hmCol.clear(); for(int j = 0; j &amp;lt; l; j++) { if(board[j][i] != &#39;.&#39;) { if(hmCol.contains(board[j][i])) return false; hmCol.add(board[j][i]); } if(board[i][j] != &#39;.&#39;) { if(hmRow.contains(board[i][j])) return false; hmRow.add(board[i][j]); } } } for(int i = 0; i &amp;lt; 3; i++) for(int j = 0; j &amp;lt; 3; j++) if(!checkBox(board, 3 * i, 3 * j, 3 * i + 3, 3 * j + 3)) return false; return true; } boolean checkBox(char[][] b, int sI, int sJ, int eI, int eJ) { HashSet&amp;lt;Character&amp;gt; hs = new HashSet&amp;lt;&amp;gt;(); for(int i = sI; i &amp;lt; eI; i++) { for(int j = sJ; j &amp;lt; eJ; j++) { if(b[i][j] == &#39;.&#39;) continue; if(hs.contains(b[i][j])) return false; hs.add(b[i][j]); } } return true; }}" }, { "title": "BOJ. Tell Median Value (1655)", "url": "/posts/BOJ-1655/", "categories": "Record, Code", "tags": "Java, Algorithm, Heap, Coding Interview, BOJ, Maximum heap, 가운데를 말해요", "date": "2021-12-24 04:53:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/1655import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int n = toi(br.readLine()); PriorityQueue&amp;lt;Integer&amp;gt; minPQ = new PriorityQueue&amp;lt;&amp;gt;(); PriorityQueue&amp;lt;Integer&amp;gt; maxPQ = new PriorityQueue&amp;lt;&amp;gt;(Collections.reverseOrder()); boolean odd = true; for(int i = 0; i &amp;lt; n; i++) { int x = toi(br.readLine()); if(odd) { if(maxPQ.isEmpty()) maxPQ.add(x); else { int min = minPQ.peek(); if(x &amp;lt;= min) maxPQ.add(x); else { maxPQ.add(minPQ.poll()); minPQ.add(x); } } sb.append(maxPQ.peek() + &quot;\\n&quot;); } else { int max = maxPQ.peek(); if(x &amp;gt;= max) minPQ.add(x); else { minPQ.add(maxPQ.poll()); maxPQ.add(x); } sb.append(Math.min(maxPQ.peek(), minPQ.peek())+ &quot;\\n&quot;); } odd = !odd; } sb.setLength(sb.length() - 1); System.out.print(sb); } public static int toi(String s) { return Integer.parseInt(s); }}" }, { "title": "LeetCode. 34. Find First and Last Position of Element in Sorted Array", "url": "/posts/Leetcode-34.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Binary Search, LeetCode, Find First and Last Position of Element in Sorted Array", "date": "2021-12-24 01:57:00 +0900", "snippet": "[Link] https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/class Solution { public int[] searchRange(int[] nums, int target) { int lb = -1, hb = -1, len = nums.length, l = 0, r = len - 1, mid; while(l &amp;lt;= r) { mid = (l + r) / 2; if(nums[mid] &amp;gt;= target) { r = mid - 1; if(nums[mid] == target) lb = r + 1; } else l = mid + 1; } l = 0; r = len - 1; while(l &amp;lt;= r) { mid = (l + r) / 2; if(nums[mid] &amp;lt;= target) { l = mid + 1; if(nums[mid] == target) hb = l - 1; } else r = mid - 1; } if(lb != -1 &amp;amp;&amp;amp; hb != -1) return new int[]{ lb, hb }; else return new int[] {-1, -1}; }}" }, { "title": "LeetCode. 33. Search in Rotated Sorted Array", "url": "/posts/Leetcode-33.-Search-in-Rotated-Sorted-Array/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Binary Search, LeetCode, Search in Rotated Sorted Array", "date": "2021-12-24 01:57:00 +0900", "snippet": "[Link] https://leetcode.com/problems/search-in-rotated-sorted-array/class Solution { public int search(int[] nums, int target) { int l = 0, r = nums.length - 1, mid; while(l &amp;lt;= r) { mid = (l + r) / 2; if(nums[mid] == target) return mid; if(nums[l] &amp;lt; nums[r]) { // 1 3 4 5 if(nums[mid] &amp;lt; target) l = mid + 1; else r = mid - 1; } else { //8 9 10 1 2 3 4 5 int left = l, right = r, m; while(left &amp;lt;= right) { m = (left + right) / 2; if(left == m) { if(left &amp;lt; nums.length - 1 &amp;amp;&amp;amp; nums[left] &amp;lt; nums[left + 1]) left++; break; } if(nums[m] &amp;lt; nums[left]) right = m - 1; else left = m; } if(target &amp;gt;= nums[l]) { int lt = l, rt = left, mt; while(lt &amp;lt;= rt) { mt = (lt + rt) / 2; if(nums[mt] == target) return mt; if(nums[mt] &amp;gt; target) rt = mt - 1; else lt = mt + 1; } return - 1; } else { int lt = left + 1, rt = r, mt; while(lt &amp;lt;= rt) { mt = (lt + rt) / 2; if(nums[mt] == target) return mt; if(nums[mt] &amp;gt; target) rt = mt - 1; else lt = mt + 1; } return -1; } } } return -1; }}" }, { "title": "LeetCode. 32. Longest Valid Parentheses", "url": "/posts/Leetcode-32.-Longest-Valid-Parentheses/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Longest Valid Parentheses, Review, difficult", "date": "2021-12-24 00:32:00 +0900", "snippet": "[Link] https://leetcode.com/problems/longest-valid-parentheses/class Solution { public int longestValidParentheses(String s) { Stack&amp;lt;Integer&amp;gt; stack = new Stack(); char[] chars = s.toCharArray(); int max = 0; stack.push(-1); for(int i = 0, len = chars.length; i &amp;lt; len; i++) { if(chars[i] == &#39;(&#39;) stack.push(i); else { stack.pop(); if(!stack.isEmpty()) max = Math.max(max, i - stack.peek()); else stack.push(i); } } return max; }}" }, { "title": "BOJ. Maximum heap (11279)", "url": "/posts/BOJ-11279/", "categories": "Record, Code", "tags": "Java, Algorithm, Heap, Coding Interview, BOJ, Maximum heap, 최대 힙", "date": "2021-12-23 03:42:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11279import java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { Heap heap = new Heap(); StringBuilder sb = new StringBuilder(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = atoi(br.readLine()); for(int i = 0; i &amp;lt; N; i++) { int n = atoi(br.readLine()); if(n == 0) sb.append(heap.pop()).append(&quot;\\n&quot;); else heap.insert(n); } System.out.println(sb); } public static class Heap{ ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int size; Heap() { al.add(null); } void insert(int val) { al.add(val); int idx = al.size() - 1; while(idx / 2 &amp;gt;= 1) { int pIdx = idx / 2; int parent = al.get(pIdx); if(parent &amp;lt; val) { al.set(pIdx, al.get(idx)); al.set(idx, parent); } else break; idx = pIdx; } } int pop() { int size = al.size(), idx = 1; if(size &amp;lt;= 1) return 0; int v = al.get(size - 1); int topV = al.set(1, v); al.remove(size - 1); size--; while(idx * 2 &amp;lt; size) { int l = idx * 2, r = l + 1, maxIdx; if(r &amp;lt; size) maxIdx = al.get(l) &amp;gt; al.get(r) ? l : r; else maxIdx = l; if(al.get(maxIdx) &amp;lt;= v) break; al.set(idx, al.get(maxIdx)); al.set(maxIdx, v); idx = maxIdx; } return topV; } } private static int atoi(String s) { return Integer.parseInt(s); }}" }, { "title": "Codility. ArrayInversionCount", "url": "/posts/Codility-ArrayInversionCount/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, Codility, ArrayInversionCount", "date": "2021-12-23 01:39:00 +0900", "snippet": "[Link] https://app.codility.com/programmers/trainings/4/array_inversion_count/import java.util.*;class Solution { public int solution(int[] A) { ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); int cnt = 0; list.add(A[0]); for(int i = 1; i &amp;lt; A.length; i++) { int insertIdx = findIdx(list, A[i]); if(insertIdx == list.size()) list.add(A[i]); else list.add(insertIdx, A[i]); cnt += insertIdx; } return cnt; } public int findIdx(ArrayList&amp;lt;Integer&amp;gt; list, int val) { int l = 0, r = list.size() - 1, mid; while(l &amp;lt;= r) { mid = (l + r) / 2; if(list.get(mid) &amp;gt; val) l = mid + 1; else if(list.get(mid) == val) return mid; else r = mid - 1; } return l; }}" }, { "title": "LeetCode. 35. Search Insert Position", "url": "/posts/LeetCode-35.-Search-Insert-Position/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Search Insert Position", "date": "2021-12-22 14:17:00 +0900", "snippet": "[Link] https://leetcode.com/problems/search-insert-position/class Solution { public int searchInsert(int[] nums, int target) { int l = 0, r = nums.length - 1, mid; while(l &amp;lt;= r){ mid = (l + r)/2; if(nums[mid] &amp;gt; target) r = mid - 1; else if(nums[mid] == target) return mid; else l = mid + 1; } return l; }}" }, { "title": "LeetCode. 31. Next Permutation", "url": "/posts/LeetCode-31.-Next-Permutation/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Next Permutation", "date": "2021-12-22 02:17:00 +0900", "snippet": "[Link] https://leetcode.com/problems/next-permutation/import java.util.Arrays;class Solution { public void nextPermutation(int[] nums) { int len = nums.length, max = nums[len - 1]; if(len &amp;gt; 1) { for(int i = nums.length - 2; i &amp;gt;= 0; i--) { if(nums[i] &amp;lt; max) { int insertIdx = findIdx(nums, i + 1, len - 1, nums[i]); int temp = nums[insertIdx]; nums[insertIdx] = nums[i]; nums[i] = temp; return; } else if(nums[i] &amp;gt;= max) { max = nums[i]; for(int j = i ; j &amp;lt; len - 1; j++) nums[j] = nums[j + 1]; nums[len - 1] = max; } } } } int findIdx(int[] arr, int l, int r, int val) { int mid; while(l &amp;lt;= r) { mid = (l + r) / 2; if(arr[mid] &amp;lt;= val) l = mid + 1; else if(arr[mid] == val) { while(mid + 1 &amp;lt; arr.length &amp;amp;&amp;amp; arr[++mid] == val); return mid; } else r = mid - 1; } return l; }}" }, { "title": "LeetCode. 30. Substring with Concatenation of All Words", "url": "/posts/LeetCode-30.-Substring-with-Concatenation-of-All-Words/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Substring with Concatenation of All Words", "date": "2021-12-21 02:42:00 +0900", "snippet": "[Link] https://leetcode.com/problems/substring-with-concatenation-of-all-words/class Solution { public List&amp;lt;Integer&amp;gt; findSubstring(String s, String[] words) { int wlen = words[0].length(), slen = s.length(), wn = words.length, cnt, keyNum = 0; HashMap&amp;lt;String, Integer&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); HashMap&amp;lt;String, Integer&amp;gt; cntMap = new HashMap&amp;lt;&amp;gt;(); LinkedList&amp;lt;Integer&amp;gt; answer = new LinkedList&amp;lt;&amp;gt;(); for(String word : words) { if(hm.containsKey(word)) hm.put(word, hm.get(word) + 1); else { keyNum++; hm.put(word, 1); } } for(int i = 0, upper = slen - wlen*wn; i &amp;lt;= upper; i++) { cntMap.clear(); cnt = 0; for(int j = 0; j &amp;lt; wn; j++) { String cur = s.substring(i + j * wlen, i + (j + 1) * wlen); if(hm.containsKey(cur)) { Integer oldVal = cntMap.put(cur, cntMap.getOrDefault(cur, 0) + 1); if(oldVal == null) oldVal = 0; if(oldVal == hm.get(cur) - 1) cnt++; else if(oldVal == hm.get(cur)) break; } else break; } if(cnt == keyNum) answer.add(i); } return answer; }}" }, { "title": "LeetCode. 29. Divide Two Integers", "url": "/posts/LeetCode-29.-Divide-Two-Integers/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Divide Two Integers", "date": "2021-12-21 01:42:00 +0900", "snippet": "[Link] https://leetcode.com/problems/divide-two-integers/class Solution { public int divide(int dividend, int divisor) { long quotient = 0, temp = 0, dividendL, divisorL; int cnt = 0, mask = 1, sign = 1; mask &amp;lt;&amp;lt;= 31; if((dividend &amp;amp; mask) != 0) { sign *= -1; dividendL = (long)(dividend ^ (-1)) + 1; } else dividendL = (long)dividend; if((divisor &amp;amp; mask) != 0) { sign *= -1; divisorL = (long)(divisor ^ (-1)) + 1; } else divisorL = (long)divisor; while(dividendL &amp;gt;= divisorL) { temp = divisorL; cnt = 0; while(temp &amp;lt;= dividendL) { temp &amp;lt;&amp;lt;= 1; cnt++; } temp &amp;gt;&amp;gt;= 1; cnt--; dividendL -= temp; quotient += (long)1 &amp;lt;&amp;lt; cnt; } long ans = quotient * sign; if(Integer.MAX_VALUE &amp;lt; ans) return Integer.MAX_VALUE; if(Integer.MIN_VALUE &amp;gt; ans) return Integer.MIN_VALUE; return (int)ans; }}" }, { "title": "Programmers. Stock Price", "url": "/posts/Programmers-Stock-Price/", "categories": "Record, Code", "tags": "Java, Algorithm, Stack, Coding Interview, Programmers, Stock Price, 주식 가격, 프로그래머스", "date": "2021-12-19 06:25:00 +0900", "snippet": "[Link] https://programmers.co.kr/learn/courses/30/lessons/42584?language=javaimport java.util.*;class Solution { public int[] solution(int[] prices) { int[] answer = new int[prices.length]; int polledIdx = 0, curIdx; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(curIdx = 0; curIdx &amp;lt; prices.length; curIdx++) { int price = prices[curIdx]; while(!stack.isEmpty() &amp;amp;&amp;amp; prices[stack.peek()] &amp;gt; price) { int idx = stack.pop(); answer[idx] = curIdx - idx; } stack.add(curIdx); } curIdx--; while(!stack.isEmpty()) { int idx = stack.pop(); answer[idx] = curIdx - idx; } return answer; }}" }, { "title": "Programmers. Disk Controller", "url": "/posts/Programmers-Disk-Controller/", "categories": "Record, Code", "tags": "Java, Algorithm, PriorityQueue, Coding Interview, Programmers, Disk Controller, 디스크 컨트롤러, 프로그래머스", "date": "2021-12-17 00:56:00 +0900", "snippet": "[Link] https://programmers.co.kr/learn/courses/30/lessons/42627?language=java#import java.util.Arrays;import java.util.PriorityQueue;class Solution { public int solution(int[][] jobs) { Arrays.sort(jobs, (l, r) -&amp;gt; l[0] - r[0]); int endT = 0, jobIdx = 0, sum = 0, len = jobs.length; PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;int[]&amp;gt;((l,r)-&amp;gt;l[1]-r[1]); while(jobIdx &amp;lt; len) { while(jobIdx &amp;lt; len &amp;amp;&amp;amp; endT &amp;gt;= jobs[jobIdx][0]) pq.add(jobs[jobIdx++]); if(pq.size() == 0) endT = jobs[jobIdx][0]; else { int[] timeInfo = pq.poll(); endT = endT + timeInfo[1]; sum += endT - timeInfo[0]; } } while(pq.size() != 0) { int[] timeInfo = pq.poll(); endT = endT + timeInfo[1]; sum += endT - timeInfo[0]; } return sum / len; }}" }, { "title": "BOJ. Closest two Point (2261)", "url": "/posts/BOJ-2261/", "categories": "Record, Code", "tags": "Java, Algorithm, Stack, Coding Interview, BOJ, Closest two Point, Review, difficult", "date": "2021-12-14 00:42:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/2261import java.util.*;import java.util.stream.Stream;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int[] line; int n = Integer.parseInt(br.readLine()); Point[] p = new Point[n]; for(int i = 0; i &amp;lt; n; i++) { line = getLine(br); p[i] = new Point(line[0], line[1]); } Arrays.sort(p, (l,r) -&amp;gt; l.x - r.x); System.out.print(binSearch(p, 0, n - 1, Integer.MAX_VALUE)); } private static int binSearch(Point[] p, int start, int end, int min) { // (2 -&amp;gt; 3Points) Under 3 Points(3 points -&amp;gt; 1 , 2 -&amp;gt; 1 is not searched) if(end - start &amp;lt;= 2) { for(int i = start; i &amp;lt;= end; i++) { for(int j = i + 1; j &amp;lt;= end; j++) { int dis = dis(p[i], p[j]); if(dis &amp;lt; min) min = dis; } } return min; } int mid = (start + end) / 2; int tempMin = Math.min(binSearch(p, start, mid, min), binSearch(p, mid + 1, end, min)); min = Math.min(min, tempMin); return Math.min(midSearch(p, start, end, tempMin), min); } private static int midSearch(Point[] p, int start, int end, int lrMin) { ArrayList&amp;lt;Point&amp;gt; al = new ArrayList&amp;lt;&amp;gt;(); int min = Integer.MAX_VALUE, mid = (start + end) / 2; for(int i = start; i &amp;lt;= end; i++) { int xDiff = p[i].x - p[mid].x; if(xDiff * xDiff &amp;lt; lrMin) al.add(p[i]); } al.sort((l, r) -&amp;gt; l.y - r.y); for(int i = 0; i &amp;lt; al.size(); i++) { Point lowP = al.get(i); for(int j = i + 1; j &amp;lt; al.size(); j++) { int yDiff = al.get(j).y - lowP.y; if(yDiff * yDiff &amp;lt; lrMin) { int dis = dis(lowP, al.get(j)); if(dis &amp;lt; min) min = dis; } else break; } } return min; } private static int dis(Point p1, Point p2) { return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y); } public static class Point { int x; int y; Point(int x, int y) { this.x = x; this.y = y; } } private static int[] getLine (BufferedReader br) throws IOException { return Stream.of(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); }}" }, { "title": "LeetCode. 28. Implement strStr()", "url": "/posts/LeetCode-28.-Implement-strStr()/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Implement strStr()", "date": "2021-12-13 16:42:00 +0900", "snippet": "[Link] https://leetcode.com/problems/implement-strstr/class Solution { public int strStr(String haystack, String needle) { int hayIdx = 0, needleIdx = 0, nlen = needle.length(), lenDiff = haystack.length() - nlen; char[] hay = haystack.toCharArray(), need = needle.toCharArray(); if(needle.length() == 0) return 0; while(hayIdx &amp;lt;= lenDiff) { int hayIdxCp = hayIdx; needleIdx = 0; for(int i = 0; i &amp;lt; needle.length(); i++) { if(hay[hayIdxCp++] != need[i]) break; if(i == nlen - 1) return hayIdx; } hayIdx++; } return -1; }}" }, { "title": "LeetCode. 27. Remove Element", "url": "/posts/LeetCode-27.-Remove-Element/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Remove Element", "date": "2021-12-13 16:21:00 +0900", "snippet": "[Link] https://leetcode.com/problems/remove-element/class Solution { public int removeElement(int[] nums, int val) { int updateIdx = 0; for(int e: nums) { if(e == val) continue; nums[updateIdx++] = e; } return updateIdx; }}" }, { "title": "LeetCode. 26. Remove Duplicates from Sorted Array", "url": "/posts/LeetCode-26.-Remove-Duplicates-from-Sorted-Array/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, Remove Duplicates from Sorted Array", "date": "2021-12-13 14:21:00 +0900", "snippet": "[Link] https://leetcode.com/problems/remove-duplicates-from-sorted-array/class Solution { public int removeDuplicates(int[] nums) { int newIdx = 0, curIdx = 1; while(curIdx &amp;lt; nums.length) { if(nums[curIdx] != nums[newIdx]) nums[++newIdx] = nums[curIdx]; curIdx++; } return newIdx + 1; }}" }, { "title": "BOJ. Bigest square in histogram (6549)", "url": "/posts/BOJ-6549/", "categories": "Record, Code", "tags": "Java, Algorithm, Stack, Coding Interview, BOJ, Bigest square in histogram", "date": "2021-12-13 05:19:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/6549import java.util.*;import java.io.*;public class Main{ public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line; int n, w = 0; long max = 0; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); StringBuilder sb = new StringBuilder(); while(true) { max = 0; line = br.readLine().split(&quot; &quot;); n = atoi(line[0]); long[] ha = new long[line.length - 1]; for(int i = 0; i &amp;lt; ha.length; i++) ha[i] = atol(line[i + 1]); int i = 0; if(n == 0) break; stack.clear(); while(i &amp;lt; n) { long h = ha[i]; if(!stack.isEmpty()) { if(ha[stack.peek()] &amp;lt;= h) { stack.push(i++); } else { while(!stack.isEmpty() &amp;amp;&amp;amp; ha[stack.peek()] &amp;gt;= h) { long height = ha[stack.pop()], width = stack.isEmpty() ? i : i - 1 - stack.peek(); max = Math.max(max, height * width); } stack.push(i++); } } else { stack.push(i++); } } i = n; while(!stack.isEmpty()) { long height = ha[stack.pop()], width = stack.isEmpty() ? n : n - 1 - stack.peek(); max = Math.max(max, height * width); } sb.append(max + &quot;\\n&quot;); } System.out.println(sb); } public static int atoi(String s) { return Integer.parseInt(s); } public static long atol(String s) { return Long.parseLong(s); }}" }, { "title": "LeetCode. 25. Reverse Nodes in k-Group", "url": "/posts/LeetCode-25.-Reverse-Nodes-in-k-Group/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, List, Reverse Nodes in k-Group", "date": "2021-12-11 21:25:00 +0900", "snippet": "[Link] https://leetcode.com/problems/reverse-nodes-in-k-group//** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode curNode = head, tailNode = null, headNode = null, node = curNode; if(k == 1) return head; loop: while(curNode != null) { node = curNode; ListNode tempHead = node; for(int i = 0; i &amp;lt; k - 1; i++) { node = node.next; if(node == null) break loop; } node = curNode.next; for(int i = 0; i &amp;lt; k - 1; i++) { ListNode nextNode = node.next; node.next = tempHead; tempHead = node; if(i != k - 2) node = nextNode; else { if(tailNode != null) tailNode.next = tempHead; else headNode = tempHead; tailNode = curNode; curNode = nextNode; } } } tailNode.next = curNode; return headNode; }}" }, { "title": "LeetCode. 24. Swap Nodes in Pairs", "url": "/posts/LeetCode-24.-Swap-Nodes-in-Pairs/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, List, Swap Nodes in Pairs, Review, difficult", "date": "2021-12-10 19:39:00 +0900", "snippet": "[Link] https://leetcode.com/problems/swap-nodes-in-pairs//** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode curNode = head, initHead = null, tailNode = null; if(curNode == null || curNode.next == null) return head; while(curNode != null &amp;amp;&amp;amp; curNode.next != null) { ListNode desNode = curNode.next.next; curNode.next.next = curNode; if(tailNode == null) initHead = curNode.next; else tailNode.next = curNode.next; tailNode = curNode; curNode = desNode; } if(curNode == null) tailNode.next = null; else tailNode.next = curNode; return initHead; }}" }, { "title": "LeetCode. 23. Merge k Sorted Lists", "url": "/posts/LeetCode-23.-Merge-k-Sorted-Lists/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, LeetCode, List, Merge k Sorted Lists", "date": "2021-12-10 18:46:00 +0900", "snippet": "[Link] https://leetcode.com/problems/merge-k-sorted-lists/Slow runtime…Can improve this by unsing priorityque./** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode curNode = new ListNode(); ListNode initNode = curNode; int min; while(true) { ListNode minNode = new ListNode(Integer.MAX_VALUE); int minIdx = -1; for(int i = 0; i &amp;lt; lists.length; i++) { ListNode node = lists[i]; if(node == null) continue; if(minNode.val &amp;gt; node.val) { minNode = node; minIdx = i; } } if(minIdx &amp;gt;= 0) { curNode.next = minNode; lists[minIdx] = lists[minIdx].next; } else break; curNode = curNode.next; } return initNode.next; }}" }, { "title": "LeetCode. 21. Merge Two Sorted Lists", "url": "/posts/LeetCode-21.-Merge-Two-Sorted-Lists/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Merge Two Sorted Lists", "date": "2021-12-09 13:08:00 +0900", "snippet": "[Link] https://leetcode.com/problems/merge-two-sorted-lists//** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode nullNode = new ListNode(); ListNode curNode = nullNode; ListNode node1 = list1, node2 = list2; while(node1 != null &amp;amp;&amp;amp; node2 != null) { if(node1.val &amp;lt; node2.val) { curNode.next = node1; curNode = node1; node1 = node1.next; if(node1 == null) break; } else { curNode.next = node2; curNode = node2; node2 = node2.next; if(node2 == null) break; } } if(node1 == null &amp;amp;&amp;amp; node2 != null) curNode.next = node2; else if(node1 != null &amp;amp;&amp;amp; node2 == null) curNode.next = node1; return nullNode.next; }}" }, { "title": "LeetCode. 10. Regular Expression Matching", "url": "/posts/LeetCode-10.-Regular-Expression-Matching/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Regular Expression Matching", "date": "2021-12-09 02:28:00 +0900", "snippet": "[Link] https://leetcode.com/problems/regular-expression-matching/class Solution { public boolean isMatch(String s, String p) { return test(s, p, 0, 0); } public boolean test(String s, String p, int sIdx, int pIdx) { if(pIdx &amp;gt;= p.length()) return sIdx == s.length() ? true : false; if(sIdx == s.length()) { if(pIdx + 1 &amp;lt; p.length()) return p.charAt(pIdx + 1) == &#39;*&#39; ? test(s, p, sIdx, pIdx + 2) : false; else return false; } else { if(p.charAt(pIdx) == &#39;.&#39;) { if(pIdx + 1 &amp;lt; p.length() &amp;amp;&amp;amp; p.charAt(pIdx + 1) == &#39;*&#39;) { //. * for(int i = sIdx; i &amp;lt;= s.length(); i++) if(test(s, p, i, pIdx + 2)) return true; return false; } else return test(s,p, sIdx + 1, pIdx + 1); //only . } else { //alphabet if(pIdx + 1 &amp;lt; p.length() &amp;amp;&amp;amp; p.charAt(pIdx + 1) == &#39;*&#39;) { //alphabet * for(int i = sIdx; i &amp;lt;= s.length(); i++) { if(test(s, p, i, pIdx + 2)) return true; if(i!= s.length() &amp;amp;&amp;amp; s.charAt(i) != p.charAt(pIdx)) break; } return false; } else return s.charAt(sIdx) == p.charAt(pIdx) ? test(s,p, sIdx + 1, pIdx + 1) : false; } } }}" }, { "title": "LeetCode. 20. Valid Parentheses", "url": "/posts/LeetCode-20.-Valid-Parentheses/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Stack, Valid Parentheses", "date": "2021-12-04 02:44:00 +0900", "snippet": "[Link] https://leetcode.com/problems/valid-parentheses/class Solution { public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; s.length(); i++) { char c = s.charAt(i); if(c == &#39;(&#39; || c== &#39;{&#39; || c == &#39;[&#39;) stack.push(c); else if(stack.isEmpty() || stack.pop() != c - (c == &#39;)&#39; ? 1 : 2)) return false; } return stack.isEmpty() ? true : false; }}" }, { "title": "LeetCode. 17. Letter Combinations of a Phone Number", "url": "/posts/LeetCode-17.-Letter-Combinations-of-a-Phone-Number/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, DFS, Letter Combinations of a Phone Number", "date": "2021-12-04 02:44:00 +0900", "snippet": "[Link] https://leetcode.com/problems/letter-combinations-of-a-phone-number/class Solution { int len; public List&amp;lt;String&amp;gt; letterCombinations(String digits) { if(digits.length() == 0) return new ArrayList&amp;lt;String&amp;gt;(); ArrayList&amp;lt;String&amp;gt; answer = new ArrayList&amp;lt;String&amp;gt;(); ArrayList&amp;lt;ArrayList&amp;lt;Character&amp;gt;&amp;gt; dialNum = new ArrayList&amp;lt;&amp;gt; (); StringBuilder sb = new StringBuilder(); int curIdx = 0, number; for(int i = 2; i &amp;lt; 10; i++) { if(i == 7 || i == 9) number = 4; else number = 3; ArrayList&amp;lt;Character&amp;gt; temp = new ArrayList&amp;lt;&amp;gt;(); for(int j = 0; j &amp;lt; number; j++) temp.add((char)(&#39;a&#39;+ curIdx++)); dialNum.add(temp); } len = dialNum.size(); dfs(digits, 0, dialNum, sb, answer); return answer; } void dfs(String digits, int index, ArrayList&amp;lt;ArrayList&amp;lt;Character&amp;gt;&amp;gt; dialNum, StringBuilder sb, ArrayList&amp;lt;String&amp;gt; answer) { if(index == digits.length()) { answer.add(sb.toString()); return; } for(char c: dialNum.get(digits.charAt(index) - &#39;2&#39;)) { sb.append(c); dfs(digits, index + 1, dialNum, sb, answer); sb.setLength(Math.max(0, sb.length() - 1)); } }}" }, { "title": "AtCoder. 021 Come Back in One Piece(5)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-21-Come-Back-in-One-Piece-5/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Graph, SCC, Tarjan's algorithm", "date": "2021-11-28 03:02:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_uUsing class would make code lot more readable and easy to understand but I wanted to solved it fast since it’s late.import java.util.*;import java.io.*;public class Main { public static int[] parentArr; public static boolean[] end; public static int cnt = 1; public static long ans = 0; public static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); public static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; edge = new ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;();; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(&quot; &quot;); int n = atoi(line[0]), m = atoi(line[1]); parentArr = new int[n + 1]; end = new boolean[n + 1]; for(int i = 0; i &amp;lt;= n; i++) edge.add(new ArrayList&amp;lt;Integer&amp;gt;()); for(int i = 0; i &amp;lt; m; i++) { line = br.readLine().split(&quot; &quot;); edge.get(atoi(line[0])).add(atoi(line[1])); } for(int i = 1; i &amp;lt;= n; i++) if(parentArr[i] == 0) dfs(i); System.out.println(ans); } public static int dfs(int v) { int parent, count = 0; parentArr[v] = parent = cnt++; stack.push(v); for(int desV : edge.get(v)) { if(parentArr[desV] == 0) parent = Math.min(parent, dfs(desV)); else if(!end[desV]) parent = Math.min(parent, parentArr[desV]); } if(parent == parentArr[v]) { while(true) { count++; int pop = stack.pop(); end[pop] = true; if(pop == v) break; } ans += count * (count - 1l)/2; } return parent; } public static int atoi(String s) { return Integer.parseInt(s); }}" }, { "title": "Graph theory. Strongly Connected Component(SCC)", "url": "/posts/Graph-theory-Strongly-Connected-Component/", "categories": "Record, Code", "tags": "Graph theory, Algorithm, Strongly Connected Component, SCC, Tarjan's algorithm, Kosaraju's algorithm", "date": "2021-11-26 09:00:00 +0900", "snippet": "#Strongly Connected ComponentIn directed graph,SCC means two components which are reachable in both ways#Algorithm (to get SCC)– Kosaraju’s algorithm(DFS)– Tarjan’s algorithm#Tarjan’s algorithm(DFS)/** edges = { ...fromVertex: [ ... toVertex ] }*/stack_global; // stacksccIdx = 1; //to distinguish the node we haven&#39;t visit.parent; // parent sccIdx of nodeend; // if formed an SCC and poped out of stackfor (vertex of vertexs) if (parent[vertex] != 0) dfs(vertex);function dfs(vertex) { parent[vertex] = tmpParent = sccIdx++; //every time dfs is called, sccIdx increase and the value is idential stack_global.push(vertex); for (toVertex of edges[vertex]) { if (parent[toVertex] !== 0) tmpParent = min(tmpParent, dfs(toVertex)); else if (!end[toVertex]) tmpParent = min(tmpParent, parent[toVertex]); } if (tmpParent == parent[vertex]) { //pop out nodes that form one SCC group while (true) { top = stack.pop(); localSCC.push(top); end[top] = true; /* the reason we don&#39;t do this before return this function lets&#39; assume we do this before return and think of dfs called: parent =&amp;gt; ...node1 =&amp;gt; node2=&amp;gt; parent then, parent[node2] = parent.SCCIdx, end[parent] = true; back to node1, since end[node2] = true, node1.SCCIdx is not updated to node2.SCCIdx which is parent.SCCIdx */ if (top == vertex) break; } } return tmpParent;}#Kosaraju’s algorithm(DFS)/** edges = { ...fromVertex: [ ... toVertex ] }*/stack_global;sccIdx = 1; //to distinguish the node we haven&#39;t visit.visit;end; // if formed an SCC and poped out of stackrev_edges; // reverse directed graphfor (vertex of vertexs) if (parent[vertex] != 0) visitDFS(vertex, stack_global, edges);//initialize visit to falsewhile (!stack_global.isEmpty()) { top = stack_global.pop(); if (!visit[top]) visitDFS(top, SCC, rev_edges);}function visitDFS(vertex, stack, edges) { stack.push([vertex, sccIdx++]); visit[vertex] = true; for (toVertext of edges[vertex]) if (!visit[toVertex]) visitDFS(toVertex, stack);}" }, { "title": "LeetCode. 19. Remove Nth Node From End of List", "url": "/posts/LeetCode-19.-Remove-Nth-Node-From-End-of-List/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Remove Nth Node From End of List", "date": "2021-11-26 06:54:00 +0900", "snippet": "[Link] https://leetcode.com/problems/remove-nth-node-from-end-of-list//** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode zero = new ListNode(0); zero.next = head; ListNode tailHead, curNode; curNode = tailHead = zero; for(int i = 0; i &amp;lt; n; i++) curNode = curNode.next; while(true) { curNode = curNode.next; if(curNode == null) break; tailHead = tailHead.next; } tailHead.next = tailHead.next.next; return zero.next; }}" }, { "title": "LeetCode. 1. Two Sum", "url": "/posts/LeetCode-1.-Two-Sum/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Two Sum", "date": "2021-11-19 23:03:00 +0900", "snippet": "[Link] https://leetcode.com/problems/two-sum/class Solution { public int[] twoSum(int[] nums, int target) { HashMap&amp;lt;Integer, Integer&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; nums.length; i++) hm.put(nums[i], i); for(int i = 0; i &amp;lt; nums.length; i++) if(hm.containsKey(target - nums[i]) &amp;amp;&amp;amp; (i != hm.get(target-nums[i]))) return new int[] { i, hm.get(target - nums[i]) }; return null; }}" }, { "title": "LeetCode. 94.Binary Tree Inorder Traversal", "url": "/posts/LeetCode-94.-Binary-Tree-Inorder-Traversal/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Binary Tree Inorder Traversal", "date": "2021-11-17 23:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/binary-tree-inorder-traversal/Using Recursive call(Top - Bottom)/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { LinkedList&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); if(root == null) return list; lnr(root, list); return list; } public void lnr(TreeNode node, List&amp;lt;Integer&amp;gt; list) { if(node.left != null) lnr(node.left, list); list.add(node.val); if(node.right != null) lnr(node.right, list); }}Using Stack(Bottom-Up)function inorderTraversal(root) { const result = [], stack = []; if (root == null) return result; stack.push(root); topNode = root; while (stack.length != 0) { topNode = stack[stack.length - 1]; while (topNode.left != null &amp;amp;&amp;amp; !topNode.left.visit) { topNode = topNode.left; stack.push(topNode); } topNode = stack.pop(); topNode.visit = true; result.push(topNode.val); if (topNode.right != null &amp;amp;&amp;amp; !topNode.right.visit) stack.push(topNode.right); } return result;}" }, { "title": "LeetCode. 540. Single Element in a Sorted Array", "url": "/posts/LeetCode-540.-Single-Element-in-a-Sorted-Array/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Binary Search, Single Element in a Sorted Array", "date": "2021-11-17 23:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/single-element-in-a-sorted-array/class Solution { public int singleNonDuplicate(int[] nums) { int start = 0, end = nums.length - 1, mid; while(start &amp;lt;= end) { mid = (start + end) / 2; boolean pre = false, post = false; if(mid &amp;gt; 0 &amp;amp;&amp;amp; nums[mid - 1] == nums[mid]) { if((mid &amp;amp; 1) == 0) pre = true; else post = true; } else if(mid &amp;lt; nums.length - 1 &amp;amp;&amp;amp; nums[mid + 1] == nums[mid]) { if((mid &amp;amp; 1) == 0) post = true; else pre = true; } if(pre) end = mid - 1; else if(post) start = mid + 1; else return nums[mid]; } return 0; }}" }, { "title": "LeetCode. 94.Binary Tree Inorder Traversal", "url": "/posts/LeetCode-461.-Hamming-Distance/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Binary Tree Inorder Traversal", "date": "2021-11-17 23:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/hamming-distance/class Solution { public int hammingDistance(int x, int y) { int bitX, bitY, cnt = 0; if(x &amp;lt; y) { int tmp = x; x = y; y = tmp; } while(x &amp;gt; 0) { bitX = x &amp;amp; 1; bitY = y &amp;amp; 1; if(bitX != bitY) cnt++; x = x&amp;gt;&amp;gt;1; y = y&amp;gt;&amp;gt;1; } return cnt; }}" }, { "title": "BOJ. Sums of subsets (11659)", "url": "/posts/BOJ-11659/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Segment Tree, Coding Interview, BOJ, Sums of subsets", "date": "2021-11-17 14:11:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/11659I solved this with segment tree since I wanted to pratice it.It’s actually faster just using sum[i]: sum of arr[0] ~ arr[i]import java.util.*;import java.io.*;public class Main { public static void main(String args[]) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(&quot; &quot;); int n = atoi(line[0]), m = atoi(line[1]); int[] nums = new int[n]; line = br.readLine().split(&quot; &quot;); int size = (int)Math.ceil((Math.log(n)/Math.log(2))); size = 1 &amp;lt;&amp;lt; (size + 1); int[] seg = new int[size]; for(int i = 0; i &amp;lt; n; i++) { nums[i] = atoi(line[i]); } init(seg, nums, 0, n - 1, 1); for(int i = 0; i &amp;lt; m; i++) { line = br.readLine().split(&quot; &quot;); int start = atoi(line[0]) - 1, end = atoi(line[1]) - 1; System.out.println(sum(seg, start, end, 0, n - 1, 1)); } } public static int init(int[] seg, int[] arr, int l, int r, int idx) { if(l == r) return seg[idx] = arr[l]; int mid = (l + r) / 2; return seg[idx] = init(seg, arr, l, mid, 2 * idx) + init(seg, arr, mid + 1, r, 2 * idx + 1); } public static int sum(int[] seg, int start, int end, int l, int r, int idx) { if(r &amp;lt; start || l &amp;gt; end) return 0; if(start &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= end) { return seg[idx]; } int mid = (l + r) / 2; return sum(seg, start, end, l, mid, idx * 2) + sum(seg, start, end, mid + 1, r, idx * 2 + 1); } public static int atoi(String s) { return Integer.parseInt(s); }}" }, { "title": "LeetCode. 53. Maximum Subarray", "url": "/posts/LeetCode-53.-Maximum-Subarray/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Maximum Subarray", "date": "2021-11-16 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/maximum-subarray/import java.util.Arrays;import java.util.LinkedList;import java.util.List;class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new LinkedList&amp;lt;&amp;gt; (); int l = nums.length; Arrays.sort(nums); for(int i = 0; i &amp;lt; l - 3; i++) { // i j start end if(i != 0 &amp;amp;&amp;amp; nums[i-1] == nums[i]) continue; if(nums[i] * 4 &amp;gt; target) break; for(int j = i+1; j &amp;lt; l - 2; j++) { if(j != i+1 &amp;amp;&amp;amp; nums[j-1] == nums[j]) continue; int start = j+1, end = l - 1,targetNum = target - nums[i] - nums[j]; while(start &amp;lt; end) { if(nums[start] + nums[end] == targetNum) { List&amp;lt;Integer&amp;gt; ele = Arrays.asList(nums[i], nums[j], nums[start] , nums[end]); list.add(ele); while(start &amp;lt; end &amp;amp;&amp;amp; nums[start] == nums[start + 1]) start++; while(start &amp;lt; end &amp;amp;&amp;amp; nums[end - 1] == nums[end]) end--; start++; end--; } else if(nums[start] + nums[end] &amp;lt; targetNum) start++; else end--; } } } return list; }}" }, { "title": "LeetCode. 13. Roman to Integer", "url": "/posts/LeetCode-13.-Roman-to-Integer/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Roman to Integer", "date": "2021-11-14 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/roman-to-integer/import java.util.HashMap;class Solution { public HashMap&amp;lt;Character, Integer&amp;gt; hm = new HashMap&amp;lt;&amp;gt;(); public int romanToInt(String s) { int l = s.length(), sum = 0; String str; for(int i = l - 1; i &amp;gt;= 0; i--) { char c = s.charAt(i); if(hm.get(c) == null) { hm.put(c, i); } } for(int i = 0; i &amp;lt; l ; i++) { char c = s.charAt(i); if(c == &#39;I&#39;) sum += mul(&#39;V&#39;,&#39;X&#39;, i) * getNum(c); else if(c == &#39;X&#39;) sum += mul(&#39;L&#39;,&#39;C&#39;, i) * getNum(c); else if(c == &#39;C&#39;) sum += mul(&#39;D&#39;,&#39;M&#39;, i) * getNum(c); else sum += getNum(c); } return sum; } int mul(char x, char y, int i) { int max = Integer.MIN_VALUE; if(hm.containsKey(x)) max = hm.get(x); if(hm.containsKey(y)) max = Math.max(max, hm.get(y)); return max &amp;lt; i ? 1 : -1; } boolean startWithOne(char c) { return (c == &#39;I&#39; || c == &#39;X&#39; || c == &#39;C&#39;) ? true : false; } int getNum(char c) { if(c == &#39;I&#39;) return 1; else if(c == &#39;V&#39;) return 5; else if(c == &#39;X&#39;) return 10; else if(c == &#39;L&#39;) return 50; else if(c == &#39;C&#39;) return 100; else if(c == &#39;D&#39;) return 500; else return 1000; }}" }, { "title": "LeetCode. 83. Remove Duplicates from Sorted List", "url": "/posts/LeetCode-83.-Remove-Duplicates-from-Sorted-List/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, LinkedList, Remove Duplicates from Sorted List", "date": "2021-11-13 12:12:00 +0900", "snippet": "[Link] https://leetcode.com/problems/remove-duplicates-from-sorted-list//** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null) return null; ListNode node = head, tmpNode = head.next; int val = head.val; while(tmpNode != null) { if(val != tmpNode.val) { node.next = tmpNode; node = node.next; val = tmpNode.val; } else tmpNode = tmpNode.next; } node.next = null; return head; }}" }, { "title": "AtCoder. 019 Pick Two(6)", "url": "/posts/%E7%AB%B6%E3%83%97%E3%83%AD%E5%85%B8%E5%9E%8B-90-%E5%95%8F-019-Pick-Two(6)/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, AtCoder, Pick Two", "date": "2021-11-12 16:26:00 +0900", "snippet": "[Link] https://AtCoder.jp/contests/typical90/tasks/typical90_simport java.util.*;import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int n = atoi(bf.readLine()); String[] split = bf.readLine().split(&quot; &quot;); int[] a = new int[2*n]; int[][] dp = new int[2*n][2*n]; for(int i = 0; i &amp;lt; 2 * n; i++) a[i] = atoi(split[i]); for(int i = 0; i &amp;lt; 2 * n; i++) { for(int j = (((i%2)&amp;amp;1)==0) ? 1 : 0; j &amp;lt; i; j+=2) { int min = Integer.MAX_VALUE; for(int k = j; k &amp;lt; i; k+=2) min = Math.min(min, Math.abs(a[i] - a[k]) + (k &amp;gt; j ? dp[j][k - 1] : 0) + (k + 1 &amp;lt; i - 1 ? dp[k + 1][i - 1] : 0)); dp[j][i] = min; } } System.out.println(dp[0][2 * n - 1]); } static int atoi(String s) { return Integer.parseInt(s); }}" }, { "title": "LeetCode. 14. Longest Common Prefix", "url": "/posts/LeetCode-14.-Longest-Common-Prefix.-Longest-Common-Prefix/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Longest Common Prefix", "date": "2021-11-12 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/longest-common-prefix/import java.util.Arrays;import java.util.LinkedList;import java.util.List;class Solution { public String longestCommonPrefix(String[] strs) { String s = strs[0]; int idx = strs[0].length() - 1; for(int i = 1; i &amp;lt; strs.length; i++) { idx = Math.min(strs[i].length() - 1, idx); for(int j = 0; j &amp;lt;= idx; j++) { if(s.charAt(j) != strs[i].charAt(j)) { idx = j - 1; break; } } } return s.substring(0, idx + 1); }}" }, { "title": "Contact", "url": "/posts/Info-Contact/", "categories": "Record, Code", "tags": "Contact, Info, Developer", "date": "2021-11-12 14:11:00 +0900", "snippet": "Emailblueblue900@gmail.comblueblueriz1646@daum.netPhoneJapan +81) 80-9003-7413Githttps://github.com/0ArchLinux0PortFolioTop 10 (personal taste)Recent" }, { "title": "LeetCode. 9. Palindrome Number", "url": "/posts/LeetCode-9.-Palindrome-Number/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Palindrome Number", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/palindrome-number/class Solution { public boolean isPalindrome(int x) { if(x &amp;lt; 0) return false; String s = String.valueOf(x); int l = s.length(); boolean isPalindrome = true; if(l % 2 == 0) { //0 1 2 3 for(int i = 0; i &amp;lt;= l/2 - 1; i++) { if(s.charAt(i) != s.charAt(l - i - 1)) return false; } } else { for(int i = 0; i &amp;lt;= l/2 - 1; i++) { // 0 1 2 (3) if(s.charAt(i) != s.charAt(l - i - 1)) return false; } } return true; }}" }, { "title": "LeetCode. 7. Reverse Integer", "url": "/posts/LeetCode-7.-Reverse-Integer/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Reverse Integer", "date": "2021-08-21 14:11:00 +0900", "snippet": "Reverse Integer[Link] https://leetcode.com/problems/reverse-integer/class Solution { public int reverse(int x) { if(x == 0) return 0; int sign = 1; long ln = new Long(x), ans = 0; if(ln &amp;lt; 0) sign = -1; while(ln != 0) { ans *= 10; ans += ln%10; ln = ln/10; } if(ans &amp;gt;= (long)Integer.MIN_VALUE &amp;amp;&amp;amp; ans &amp;lt;= (long)Integer.MAX_VALUE) return (int)ans; else return 0; }}" }, { "title": "LeetCode. 6. ZigZag Conversion", "url": "/posts/LeetCode-6.-ZigZag-Conversion/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, ZigZag Conversion", "date": "2021-08-21 14:11:00 +0900", "snippet": "ZigZag Conversion[Link] https://leetcode.com/problems/zigzag-conversion/import java.util.*;class Solution { public String convert(String s, int numRows) { if(numRows == 1) return s; StringBuilder sb = new StringBuilder(); ArrayList&amp;lt;StringBuilder&amp;gt; al = new ArrayList&amp;lt;&amp;gt; (); int inc = 1; int h = 0; for(int i = 0; i &amp;lt; numRows; i++) { StringBuilder sb2 = new StringBuilder (); al.add(sb2); } for(int i = 0; i &amp;lt; s.length(); i++) { StringBuilder sb2 = al.get(h); sb2.append(s.charAt(i)); h+=inc; if(h == numRows - 1) inc = -1; else if(h == 0) inc = 1; } for(int i = 0; i &amp;lt; numRows; i++) { sb.append(al.get(i)); } return sb.toString(); }}" }, { "title": "LeetCode. 5. Longest Palindromic Substring", "url": "/posts/LeetCode-5.-Longest-Palindromic-Substring/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Longest Palindromic Substring", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/longest-palindromic-substring/class Solution { public String longestPalindrome(String s) { int max = 0, startIdx = 0, endIdx = 0, len = s.length(); for(int i = 0; i &amp;lt; s.length(); i++) { int start = i, end1 = i, end2 = i+1, end; boolean continue1 = true, continue2 = true; while(start &amp;gt;= 0 &amp;amp;&amp;amp; (continue1 || continue2)) { if(continue1 == true) { if(end1 &amp;lt; len &amp;amp;&amp;amp; s.charAt(start) == s.charAt(end1)) end1++; else continue1 = false; } if(continue2 == true) { if(end2 &amp;lt; len &amp;amp;&amp;amp; s.charAt(start) == s.charAt(end2)) end2++; else continue2 = false; } if(continue1 || continue2) start--; } // System.out.println(i + &quot; , &quot; + start + &quot; , &quot; + end1 + &quot; , &quot; + end2); // end1--; // end2--; end = end1 &amp;gt; end2 ? end1 : end2; if(max &amp;lt; end - ++start + 1) { max = end - start + 1; startIdx = start; endIdx = end -1; } } // System.out.println(startIdx + &quot; , &quot; + endIdx + &quot; max: &quot; + max); return s.substring(startIdx, endIdx + 1); }}" }, { "title": "LeetCode. 4.Median of Two Sorted Arrays", "url": "/posts/LeetCode-4.-Median-of-Two-Sorted-Arrays/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Median of Two Sorted Arrays", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/median-of-two-sorted-arrays/class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int len = nums1.length + nums2.length; int[] merged = new int[len]; int index1 = 0, index2 = 0; for(int i = 0; i &amp;lt; len; i++) { if(index1 &amp;lt; nums1.length &amp;amp;&amp;amp; index2 &amp;lt; nums2.length) { if(nums1[index1] &amp;gt; nums2[index2]) merged[i] = nums2[index2++]; else merged[i] = nums1[index1++]; } else if(index1 &amp;lt; nums1.length) { for(int j = i; j &amp;lt; len; j++) { merged[j] = nums1[index1++]; } break; } else if(index2 &amp;lt; nums2.length) { for(int j = i; j &amp;lt; len; j++) { merged[j] = nums2[index2++]; } break; } } if(len%2 == 0) { return (double)(merged[(len-1)/2] + merged[len/2])/2; } else return merged[(len-1)/2]; }}" }, { "title": "LeetCode. 4 Median of Two Sorted Arrays", "url": "/posts/LeetCode-4-Median-of-Two-Sorted-Arrays/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, JavaScript, Algorithm, Coding Interview, LeetCode, Median of Two Sorted Arrays", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/median-of-two-sorted-arrays/class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int len = nums1.length + nums2.length; int[] merged = new int[len]; int index1 = 0, index2 = 0; for(int i = 0; i &amp;lt; len; i++) { if(index1 &amp;lt; nums1.length &amp;amp;&amp;amp; index2 &amp;lt; nums2.length) { if(nums1[index1] &amp;gt; nums2[index2]) merged[i] = nums2[index2++]; else merged[i] = nums1[index1++]; } else if(index1 &amp;lt; nums1.length) { for(int j = i; j &amp;lt; len; j++) { merged[j] = nums1[index1++]; } break; } else if(index2 &amp;lt; nums2.length) { for(int j = i; j &amp;lt; len; j++) { merged[j] = nums2[index2++]; } break; } } if(len%2 == 0) { return (double)(merged[(len-1)/2] + merged[len/2])/2; } else return merged[(len-1)/2]; }}" }, { "title": "LeetCode. 3. Longest Substring Without Repeating Characters", "url": "/posts/LeetCode-3.-Longest-Substring-Without-Repeating-Characters/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Longest Substring Without Repeating Characters", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/longest-substring-without-repeating-characters/import java.util.*;class Solution { public int lengthOfLongestSubstring(String s) { int start = 0; int max = 0; HashSet&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;Character&amp;gt;(); for(int i = 0; i &amp;lt; s.length(); i++) { while(set.contains(s.charAt(i))) { set.remove(s.charAt(start++)); } set.add(s.charAt(i)); max = Math.max(max, set.size()); } return max; }}" }, { "title": "LeetCode. 16. 3Sum Closest", "url": "/posts/LeetCode-16.-3Sum-Closest/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, JavaScript, Algorithm, Coding Interview, LeetCode, 3Sum Closest", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/3sum-closest/function radixSort(array) { let max; let digitArr = new Array(10); for (let i = 0; i &amp;lt; digitArr.length; i++) { digitArr[i] = []; } for (let i = 0; i &amp;lt; array.length; i++) { if (i === 0 || max &amp;lt; array[i]) { max = array[i]; } } let maxLog = Math.log10(max) + 1; for (let digit = 1; digit &amp;lt;= maxLog; digit++) { let digit10 = Math.pow(10, digit); let tempArr = []; for (let i = 0; i &amp;lt; array.length; i++) { if (digit === 1) { digitArr[array[i] % digit10].push(array[i]); } else { tempDigit = Math.floor(((array[i] % digit10) * 10) / digit10); digitArr[tempDigit].push(array[i]); } } for (let i = 0; i &amp;lt; digitArr.length; i++) { while (digitArr[i].length !== 0) { tempArr.push(digitArr[i][0]); digitArr[i].shift(); } } array = [...tempArr]; } return array;}" }, { "title": "LeetCode. 15. 3Sum", "url": "/posts/LeetCode-15.-3Sum/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, 3Sum", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/3sum/import java.util.*;class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) { Arrays.sort(nums); // for(List&amp;lt;Integer&amp;gt; e: nums) for() List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new LinkedList&amp;lt;&amp;gt; (); for(int i = 0; i &amp;lt; nums.length - 2; i++) { if(nums[i] &amp;gt; 0) break; if(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; int start = i + 1, end = nums.length - 1; int sum = (-1) * nums[i]; while(start &amp;lt; end) { if(nums[start] + nums[end] &amp;gt; sum) end--; else if(nums[start] + nums[end] == sum) { list.add(Arrays.asList(nums[i], nums[start], nums[end])); while(start &amp;lt; end &amp;amp;&amp;amp; nums[start] == nums[start+1]) start++; while(start &amp;lt; end &amp;amp;&amp;amp; nums[end] == nums[end-1]) end--; start++; end--; } else start++; } } return list; }}" }, { "title": "LeetCode. 12.Integer to Roman", "url": "/posts/LeetCode-12.Integer-to-Roman/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Integer to Roman", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/integer-to-roman/class Solution { public String intToRoman(int num) { int[] arr = new int[4]; // 0 : 1st digit 1: 2st ... StringBuilder s = new StringBuilder(); for(int i = 0; i &amp;lt; 4; i++) { int digit = num % 10; num /= 10; arr[i] = digit; } if(arr[3] != 0) { s.append(&quot;M&quot;.repeat(arr[3])); } if(arr[2]!=0) { if(arr[2] == 4) s.append(&quot;CD&quot;); else if(arr[2] == 9) s.append(&quot;CM&quot;); else { if(arr[2] &amp;gt;= 5) { s.append(&quot;D&quot;); arr[2] -= 5; } s.append(&quot;C&quot;.repeat(arr[2])); } } if(arr[1]!=0) { if(arr[1] == 4) s.append(&quot;XL&quot;); else if(arr[1] == 9) s.append(&quot;XC&quot;); else { if(arr[1] &amp;gt;= 5) { s.append(&quot;L&quot;); arr[1] -= 5; } s.append(&quot;X&quot;.repeat(arr[1])); } } if(arr[0]!=0) { if(arr[0] == 4) s.append(&quot;IV&quot;); else if(arr[0] == 9) s.append(&quot;IX&quot;); else { if(arr[0] &amp;gt;= 5) { s.append(&quot;V&quot;); arr[0] -= 5; } s.append(&quot;I&quot;.repeat(arr[0])); } } return s.toString(); }}" }, { "title": "LeetCode. 11. Container With Most Water", "url": "/posts/LeetCode-11.-Container-With-Most-Water/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, Java, Algorithm, Coding Interview, LeetCode, Container With Most Water", "date": "2021-08-21 14:11:00 +0900", "snippet": "[Link] https://leetcode.com/problems/container-with-most-water/class Solution { public int maxArea(int[] height) { int start = 0, end = height.length - 1, max = 0; while(start &amp;lt; end) { max = Math.max(max, (end - start) * Math.min(height[end], height[start])); if(height[start] &amp;lt; height[end]) { // 1 3 start++; } else { end--; } } return max; }}" }, { "title": "Sort. Radix Sort", "url": "/posts/Sort-Radix-Sort/", "categories": "Record, Code", "tags": "Code Block, Code Snippet, JavaScript, Radix, Code, Radix, Sort, Coding Interview", "date": "2021-08-21 08:53:00 +0900", "snippet": "Radix SortTime Complexity: O(nw) (n: number of items, w: length of item) Space Complexity: O(n+w)function radixSort(array) { let max; let digitArr = new Array(10); for (let i = 0; i &amp;lt; digitArr.length; i++) { digitArr[i] = []; } for (let i = 0; i &amp;lt; array.length; i++) { if (i === 0 || max &amp;lt; array[i]) { max = array[i]; } } let maxLog = Math.log10(max) + 1; for (let digit = 1; digit &amp;lt;= maxLog; digit++) { let digit10 = Math.pow(10, digit); let tempArr = []; for (let i = 0; i &amp;lt; array.length; i++) { if (digit === 1) { digitArr[array[i] % digit10].push(array[i]); } else { tempDigit = Math.floor(((array[i] % digit10) * 10) / digit10); digitArr[tempDigit].push(array[i]); } } for (let i = 0; i &amp;lt; digitArr.length; i++) { while (digitArr[i].length !== 0) { tempArr.push(digitArr[i][0]); digitArr[i].shift(); } } array = [...tempArr]; } return array;}" }, { "title": "BOJ. Tree (4803)", "url": "/posts/BOJ-4803/", "categories": "Record, Code", "tags": "Java, Algorithm, Coding Interview, BOJ, DFS, Tree, Data Structure", "date": "2021-01-10 18:01:00 +0900", "snippet": "[Link] https://www.acmicpc.net/problem/4803import java.util.*;import java.io.*;public class Main { static BufferedReader br; static int max = 0, maxIdx = 0; public static void main(String[] args) throws IOException { br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); String[] line; Node[] nodes; boolean[] visit; Node node; int cntTot = 0; int caseNum = 1; while(true) { line = getLine(); int n = toi(line[0]), m = toi(line[1]), treeNum = 0; nodes = new Node[n]; for(int i = 0; i &amp;lt; n; i++) nodes[i] = new Node(i); visit = new boolean[n]; if(n == 0 &amp;amp;&amp;amp; m == 0) break; for(int i = 0; i &amp;lt; m; i++) { line = getLine(); int a = toi(line[0]) - 1, b = toi(line[1]) - 1; nodes[a].list.add(b); nodes[b].list.add(a); } Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; n; i++) { if(visit[i]) continue; q.clear(); q.add(nodes[i]); treeNum += bfs(q, nodes, visit); } if(treeNum == 0) sb.append(&quot;Case &quot; + caseNum + &quot;: No trees.&quot;); else if(treeNum == 1) sb.append(&quot;Case &quot; + caseNum + &quot;: There is one tree.&quot;); else sb.append(&quot;Case &quot; + caseNum + &quot;: A forest of &quot; + treeNum + &quot; trees.&quot;); caseNum++; sb.append(&quot;\\n&quot;); } print(sb); } static int bfs(Queue&amp;lt;Node&amp;gt; q, Node[] nodes, boolean[] visit) { int vCnt = 0, adjCnt = 0; while(!q.isEmpty()) { Node cur = q.poll(); vCnt++; adjCnt += cur.list.size(); if(visit[cur.idx]) continue; visit[cur.idx] = true; for(int e : cur.list) { if(visit[e]) continue; q.add(nodes[e]); } } if(adjCnt == 2 * vCnt - 2) return 1; return 0; } static class Node { int idx; ArrayList&amp;lt;Integer&amp;gt; list; public Node(int idx) { this.idx = idx; list = new ArrayList&amp;lt;&amp;gt;(); } } static int toi(String s) { return Integer.parseInt(s); } static String[] getLine() throws IOException { return br.readLine().split(&quot; &quot;); } static &amp;lt;T&amp;gt; void print(T s) { System.out.print(s); } static &amp;lt;T&amp;gt; void println(T s) { System.out.println(s); }}" } ]
